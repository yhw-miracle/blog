<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <title>python之进程 - 痛点就是起点</title>
    <link href="/images/logo.jpg" rel="shortcut icon">
<link href="/atom.xml" rel="alternate" type="application/rss+xml">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
<meta content="text/html; charset=utf-8" http-equiv="content-type">


  </head>
  <body>
    <header>
  <a id="go-back-home" href="/"><img src="/images/logo.jpg" alt="Home" width="53" height="59"></a>
  <p>痛点就是起点</p>
  <p>Speaking is as important as doing!</p>
</header>

    <div id="container">
      <div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/ToYou">ToYou</a>
  
    <a class="main" href="/categories">Categories</a>
  
    <a class="main" href="/atom.xml">RSS</a>
  
</div>

      <section class="paging">
  
    <div class="left">
      <a href="/2018/08/01/python之多线程/">
        ‹
      </a>
    </div>
  
  
    <div class="right">
      <a href="/2018/07/30/python之IO编程/">
        ›
      </a>
    </div>
  
</section>

      <div class="content">
        <section class="post">
          <h1>
            <div class="date">2018-07-31</div>
            python之进程
          </h1>
          <p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，另一种是使用 multiprocessing 模块。这两种方法的区别在于前者适用于 Unix/Linux 操作系统，对 Windows 系统不支持，后者则是跨平台的实现方式。</p>
<h3 id="1-使用-os-模块中的-fork-方法实现多进程"><a href="#1-使用-os-模块中的-fork-方法实现多进程" class="headerlink" title="1. 使用 os 模块中的 fork 方法实现多进程"></a>1. 使用 os 模块中的 fork 方法实现多进程</h3><p>python 的 os 模块封装了常见的系统调用，其中就有 fork 方法。fork 方法来自于 Unix/Linux 操作系统中提供的一个 fork 系统调用，这个方法非常特殊。普通方法都是调用一次，返回一次。而fork 方法是调用一次，返回两次，原因在操作系统将当前系统（父进程）复制出一份进程（子进程），这两个进程几乎完全相同，于是 fork 方法分别在父进程和子进程中返回。子进程中永远返回 0，父进程中返回的是子进程的 ID。具体情况，见如下代码，其中，os 模块中的 getpid 方法用于返回当前进程的 ID，getppid 方法用于获取父进程的 ID。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'current Process (%s) start ...'</span> % (os.getpid())</span><br><span class="line">    pid = os.fork()</span><br><span class="line">    <span class="keyword">if</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'error in fork.'</span></span><br><span class="line">    <span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'I (%s) create a child process (%s)'</span> % (os.getpid(), pid)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'I am child process (%s) and my parent process is (%s)'</span> % (os.getpid(), os.getppid())</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-32-10.png" alt=""></p>
<h3 id="2-使用-multiprocessing-模块创建多进程"><a href="#2-使用-multiprocessing-模块创建多进程" class="headerlink" title="2. 使用 multiprocessing 模块创建多进程"></a>2. 使用 multiprocessing 模块创建多进程</h3><p>multiprocessing 模块提供了一个 Process 类来描述进程对象。创建子进程时，只需要传入一个执行函数和函数参数，即可完成一个 Process 实例的创建，用 start() 方法启动进程，用 join() 实现进程间的同步。下面，用一个例子来演示说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_process</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Child process %s (%s) Running...'</span> % (name, os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Parent process %s.'</span> % os.getpid()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=run_process, args=(str(i),))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Process will start.'</span></span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Process end.'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-38-25.png" alt=""></p>
<p>进程具有并发性，共享性，独立性和异步性，以上代码中子进程输出语句说明了进程的异步性。</p>
<h3 id="3-multiprocessing-模块提供了-Pool-类来代表进程池对象"><a href="#3-multiprocessing-模块提供了-Pool-类来代表进程池对象" class="headerlink" title="3. multiprocessing 模块提供了 Pool 类来代表进程池对象"></a>3. multiprocessing 模块提供了 Pool 类来代表进程池对象</h3><p>以上两种创建进程的方法在启动大量子进程时，需要手动限制进程数量，显得太过繁琐，而使用进程池批量创建子进程的方式更加方便。</p>
<p>multiprocessing 模块提供了 Pool 类来代表进程池对象，Pool 类可以提供制定数量的进程供用户调用，默认大小是 CPU 的核数。当有新的请求提交到 Pool 中时，如果进程池还没有满，那么就会创建一个新的进程用来执行该请求；如果进程池中的进程数已经达到规定的最大值，那么该请求就好等待，直到池中有进程结束，才会创建新的进程来处理它。下面，用代码来演示进程池对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Task %s (pid = %s) is running...'</span> % (name, os.getpid())</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Task %s end.'</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'current process %s.'</span> % os.getpid()</span><br><span class="line">    p = Pool(processes=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(run_task, args=(i,))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Waiting for all subprocess done...'</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'All subprocess done.'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-56-10.png" alt=""></p>
<h3 id="4-进程间通信"><a href="#4-进程间通信" class="headerlink" title="4. 进程间通信"></a>4. 进程间通信</h3><p>操作系统中存在大量进程，那么进程间的通信是必不可少的。python 提供了 Queue 和 Pipe 两张方式实现进程间的通信，两张区别在于，Pipe 常用来在两个进程间通信，Queue 用来在多个进程间实现通信。</p>
<h4 id="4-1-Queue-实现进程通信"><a href="#4-1-Queue-实现进程通信" class="headerlink" title="4.1 Queue 实现进程通信"></a>4.1 Queue 实现进程通信</h4><p>Queue 是多进程安全的队列，可以使用 Queue 实现多进程间的数据传递，有两个方法 Put 和 Get 可以进行 Queue 操作。</p>
<blockquote>
<p>Put 方法用以插入数据到队列中，它还有两个可选数据：blocked 和 timeout。如果 blocked 为 True （默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间；如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该队列以满，会立即抛出 Queue.Full 异常。</p>
</blockquote>
<blockquote>
<p>Get 方法可以从队列读取并且删除一个元素。Get 方法也有两个可选参数：blocked 和 timeout。如果 blocked 为 True （默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常；如果 blocked 为 False，有两张情况：如果队列有元素可以用，则立即会返回该值；否则，如果队列为空，立即抛出 Queue.Empty 异常。</p>
</blockquote>
<p>下面用代码来演示 Queue 实现进程间通信。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_write</span><span class="params">(q, urls)</span>:</span></span><br><span class="line">    print(<span class="string">'Process (%s) is writing...'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        q.put(url)</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % url)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process (%s) is reading...'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        url = q.get(<span class="keyword">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue...'</span> % url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    process_write1 = Process(target=process_write, args=(q, [<span class="string">'url1'</span>, <span class="string">'url2'</span>, <span class="string">'url3'</span>]))</span><br><span class="line">    process_write2 = Process(target=process_write, args=(q, [<span class="string">'url4'</span>, <span class="string">'url5'</span>, <span class="string">'url6'</span>]))</span><br><span class="line">    process_reader = Process(target=process_read, args=(q,))</span><br><span class="line"></span><br><span class="line">    process_write1.start()</span><br><span class="line">    process_write2.start()</span><br><span class="line">    process_reader.start()</span><br><span class="line"></span><br><span class="line">    process_write1.join()</span><br><span class="line">    process_write2.join()</span><br><span class="line"></span><br><span class="line">    process_reader.terminate()</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/Screenshot%20from%202018-07-31%2013-20-31.png" alt=""></p>
<h4 id="4-2-Pipe-实现进程通信"><a href="#4-2-Pipe-实现进程通信" class="headerlink" title="4.2 Pipe 实现进程通信"></a>4.2 Pipe 实现进程通信</h4><p>Pipe 通常用来在两个进程间进行通信，两个进程分别位于管道的两端。Pipe 方法返回 (conn1, conn2) 代表管道的两端，该方法还有 duplex 参数，如果 duplex 参数为 True （默认值），那么这个管道是全双工模式，也就是管道两端均可以同时接收和返送数据；如果 duplex 参数为 False，conn1 只负责接收消息，conn2 只负责发送消息。</p>
<p>send 和 recv 方法分别是发送和接收消息的方法，如果没有消息可接收，recv 方法会一直阻塞，如果管道关闭，那么 recv 方法会抛出 EOFError。下面通过代码来演示 Pipe 实现进程通信。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing, random, os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_send</span><span class="params">(pipe, urls)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        print(<span class="string">'Process (%s) send: %s'</span> % (os.getpid(), url))</span><br><span class="line">        pipe.send(url)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_recv</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'Process (%s) recv: %s'</span> % (os.getpid(), pipe.recv()))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pipe = multiprocessing.Pipe()</span><br><span class="line">    p1 = multiprocessing.Process(target=process_send, args=(pipe[<span class="number">0</span>], [<span class="string">'url'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]))</span><br><span class="line">    p2 = multiprocessing.Process(target=process_recv, args=(pipe[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.terminate()</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/Screenshot%20from%202018-07-31%2013-34-23.png" alt=""></p>

          <br>
<p> from yhw-miracle</p>
<p align="center"><img src="/images/qrcode_for_gh_5efb2780ab44_258.jpg" alt="痛点就是起点"></p>
<p align="center">算法和代码的世界不仅是学习的痛点，而且是成功的起点。欢迎关注，共同进步！</p>

        </section>
      </div>
      
      <!--<div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/ToYou">ToYou</a>
  
    <a class="main" href="/categories">Categories</a>
  
    <a class="main" href="/atom.xml">RSS</a>
  
</div>
-->
    </div>
    <footer>
  <span class="muted">&copy; 2016 - 2019 yhw-miracle. All Rights Reserved.</span><br>
  <!--<a href='https://github.com/saintwinkle/hexo-theme-scribble' class='muted'>built with Hexo using Scribble theme</a>-->
  <img src="/images/logo.jpg" width="53" height="59" alt="痛点就是起点">
</footer>

  </body>
</html>
