<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <title>python之多线程 - 痛点就是起点</title>
    <link href="/images/logo.jpg" rel="shortcut icon">
<link href="/atom.xml" rel="alternate" type="application/rss+xml">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
<meta content="text/html; charset=utf-8" http-equiv="content-type">


  </head>
  <body>
    <header>
  <a id="go-back-home" href="/"><img src="/images/logo.jpg" alt="Home" width="53" height="59"></a>
  <p>痛点就是起点</p>
  <p>Speaking is as important as doing!</p>
</header>

    <div id="container">
      <div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/ToYou">ToYou</a>
  
    <a class="main" href="/categories">Categories</a>
  
    <a class="main" href="/atom.xml">RSS</a>
  
</div>

      <section class="paging">
  
    <div class="left">
      <a href="/2018/08/02/协程/">
        ‹
      </a>
    </div>
  
  
    <div class="right">
      <a href="/2018/07/31/python之进程/">
        ›
      </a>
    </div>
  
</section>

      <div class="content">
        <section class="post">
          <h1>
            <div class="date">2018-08-01</div>
            python之多线程
          </h1>
          <p>线程是进程中可以同时运行的不同程序，有时被称为轻量进程，是系统独立调度和分派的基本单位。多线程运行有很多优点：</p>
<blockquote>
<ol>
<li>可以把运行时间长的任务放到后台去处理。</li>
<li>程序的运行速度可能会加快。</li>
<li>用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>
<li>在一些需要等待的任务实现上，比如用户输入、文件读写好人网络收发数据等，线程就可以释放一些珍贵的系统资源，避免内存占用。</li>
</ol>
</blockquote>
<h3 id="1-Python-中线程实现"><a href="#1-Python-中线程实现" class="headerlink" title="1. Python 中线程实现"></a>1. Python 中线程实现</h3><p>python 中提供了两个模块：thread 和 threading 实现多进程，thread 是低级模块，threading 是高级模块，是对 thread 的封装。在绝大数情况下，我们只需要使用 threading 这个高级模块就能实现多线程。</p>
<p>使用 threading 实现多线程有两种方法，一种是把一个函数传入并创建 Thread 实例，然后调用 start 方法开始执行；另一种是直接继承 threading.Thread 类并创建自定义线程类，然后重写 <strong>init</strong> 方法和 run 方法。下面就分别介绍这两种实现多线程的方法。</p>
<h4 id="1-1-创建-Thread-实例"><a href="#1-1-创建-Thread-实例" class="headerlink" title="1.1 创建 Thread 实例"></a>1.1 创建 Thread 实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, time, threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_run</span><span class="params">(urls)</span>:</span></span><br><span class="line">    print(<span class="string">'Current (%s) is running...'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        print(<span class="string">'%s ---&gt; %s'</span> % (threading.current_thread().name, url))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line">    print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'%s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=thread_run, name=<span class="string">'Thread1'</span>, args=([<span class="string">'url1'</span>, <span class="string">'url2'</span>, <span class="string">'url3'</span>],))</span><br><span class="line">    t2 = threading.Thread(target=thread_run, name=<span class="string">'Thread2'</span>, args=([<span class="string">'url4'</span>, <span class="string">'url5'</span>, <span class="string">'url6'</span>],))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/August/Screenshot%20from%202018-08-01%2012-41-20.png" alt=""></p>
<h4 id="1-2-创建自定义线程类"><a href="#1-2-创建自定义线程类" class="headerlink" title="1.2 创建自定义线程类"></a>1.2 创建自定义线程类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, urls)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line">        self.urls = urls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Current (%s) is running...'</span> % threading.current_thread().name)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.urls:</span><br><span class="line">            print(<span class="string">'%s ---&gt; %s'</span> % (threading.current_thread().name, url))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'%s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t1 = MyThread(name=<span class="string">'Thread1'</span>, urls=[<span class="string">'url1'</span>, <span class="string">'url2'</span>, <span class="string">'url3'</span>])</span><br><span class="line">    t2 = MyThread(name=<span class="string">'Thread2'</span>, urls=[<span class="string">'url4'</span>, <span class="string">'url5'</span>, <span class="string">'url6'</span>])</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/August/Screenshot%20from%202018-08-01%2012-44-33.png" alt=""></p>
<h3 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h3><p>如果多个线程共同对某个数据修改，则可能会出现不可预料的结果。为了保证数据的正确性，我们需要对多个进行同步。Python 中使用 Thread 对象的 Lock 和 RLock 对象实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于每次只允许一个线程操作的资源，可以将该资源放到 acquire 和 release 方法之间。</p>
<blockquote>
<p>对于 Lock 对象，如果一个线程连续两次进行 acquire 操作，那么由于第一次 acquire 没有 release，第二次 require 将挂起线程，这会导致 Lock 对象永远不会 release，使得线程死锁。</p>
</blockquote>
<blockquote>
<p>RLock 对象允许一个线程多次对其进行 acquire 操作，因为在其内部通过一个变量 counter 维护线程 acquire 的次数，而且每一次的 acquire 操作必须有一个 release 操作与之对应，在所有的 release 操作完成后，别的线程才能申请该 RLock 对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line">myLock = threading.RLock()</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            myLock.acquire()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'%s locked, number: %d'</span> % (threading.current_thread().name, num))</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">4</span>:</span><br><span class="line">                myLock.release()</span><br><span class="line">                print(<span class="string">'%s released, number: %d'</span> % (threading.current_thread().name, num))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'%s released, number: %d'</span> % (threading.current_thread().name, num))</span><br><span class="line"></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            myLock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    thread1 = MyThread(<span class="string">'Thread1'</span>)</span><br><span class="line">    thread2 = MyThread(<span class="string">'Thread2'</span>)</span><br><span class="line"></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/August/Screenshot%20from%202018-08-01%2013-03-49.png" alt=""></p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>在 python 的原始解释器中存在着 GIL(Global Interpreter Lock，全局解释器锁)，因此在解释执行 python 代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到 I/O 操作或者操作次数达到一定数目时才会释放 GIL。由于全局解释器锁的存在，在进行多线程操作时，不能调用多个 CPU 内核，只能利用一个内核，所以在进行 CPU 密集型操作的时候，不推荐使用多线程，更倾向于多进程；对于 IO 密集型操作，多线程可以明显提高效率。</p>

          <br>
<p> from yhw-miracle</p>
<p align="center"><img src="/images/qrcode_for_gh_5efb2780ab44_258.jpg" alt="痛点就是起点"></p>
<p align="center">算法和代码的世界不仅是学习的痛点，而且是成功的起点。欢迎关注，共同进步！</p>

        </section>
      </div>
      
      <!--<div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/ToYou">ToYou</a>
  
    <a class="main" href="/categories">Categories</a>
  
    <a class="main" href="/atom.xml">RSS</a>
  
</div>
-->
    </div>
    <footer>
  <span class="muted">&copy; 2016 - 2019 yhw-miracle. All Rights Reserved.</span><br>
  <!--<a href='https://github.com/saintwinkle/hexo-theme-scribble' class='muted'>built with Hexo using Scribble theme</a>-->
  <img src="/images/logo.jpg" width="53" height="59" alt="痛点就是起点">
</footer>

  </body>
</html>
