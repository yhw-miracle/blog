<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <title>协程 - 痛点就是起点</title>
    <link href="/images/logo.jpg" rel="shortcut icon">
<link href="/atom.xml" rel="alternate" type="application/rss+xml">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
<meta content="text/html; charset=utf-8" http-equiv="content-type">


  </head>
  <body>
    <header>
  <a id="go-back-home" href="/"><img src="/images/logo.jpg" alt="Home" width="53" height="59"></a>
  <p>痛点就是起点</p>
  <p>Speaking is as important as doing!</p>
</header>

    <div id="container">
      <div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/ToYou">ToYou</a>
  
    <a class="main" href="/categories">Categories</a>
  
    <a class="main" href="/atom.xml">RSS</a>
  
</div>

      <section class="paging">
  
    <div class="left">
      <a href="/2018/08/03/分布式进程/">
        ‹
      </a>
    </div>
  
  
    <div class="right">
      <a href="/2018/08/01/python之多线程/">
        ›
      </a>
    </div>
  
</section>

      <div class="content">
        <section class="post">
          <h1>
            <div class="date">2018-08-02</div>
            协程
          </h1>
          <p>协程(coroutine)，又称微线程，纤程，是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。</p>
<p>协程需要用户自己编写调度逻辑，对于 CPU 来说，协程其实是单线程，CPU 不需要考虑怎么去调度、切换上下文，这样就省去了 CPU 的切换开销，因此协程在一定程度上有好于多线程。</p>
<h3 id="1-python-实现协程"><a href="#1-python-实现协程" class="headerlink" title="1. python 实现协程"></a>1. python 实现协程</h3><p>第三方库　gevent 提供了比较完善的协程支持，gevent 是一个基于协程的 python 网络数据库，使用 greenlet 在　libev 事件循环顶部提供了一个有高级别并发性的　API。主要特性有以下几点。</p>
<blockquote>
<ol>
<li>基于　libev 的快速事件循环，Linux　上是　epoll 机制。</li>
<li>基于　greenlet 的轻量级执行单元。</li>
<li>API 复用了 python 标准库里的内容。</li>
<li>支持 SSL 的协作式　sockets。</li>
<li>可通过线程池或　c-ares 实现 DNS 查询。</li>
<li>通过　monkey patching 功能使得第三方模块变成协作式。</li>
</ol>
</blockquote>
<p>gevent 对协程的支持，本质上是　greenlet 在实现切换工作。greenlet 工作流程如下：假如进行访问网络的　IO 操作，出现阻塞，greenlet 就显式切换到另一段没有阻塞的代码段执行，直到原先的阻塞状况消失以后，再自动切换回原来的代码段继续处理。因此，greenlet 是一种合理安排的串行方式。</p>
<p>由于 IO 操作非常耗时，经常使程序处于等待状态，有了　greenlet 自动切换协程，保证总有　greenlet 在运行，而不是等待　IO，这就是协程一般比多线程效率高的原因。由于切换在　IO 操作时自动完成，所以　gevent 需要修改　python 自带的一些标准库，将一些常见的阻塞，如　socket、select 等地方实现协程跳转，这一过程在启动时通过　monkey patch 完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent, urllib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'visit ---&gt; %s'</span> % url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(url)</span><br><span class="line">        data = response.read()</span><br><span class="line">        print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    urls = [<span class="string">'http://github.com'</span>, <span class="string">'https://www.python.org'</span>, <span class="string">'http://yhw-miracle.win'</span>]</span><br><span class="line">    greenLets = [gevent.spawn(run_task, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    gevent.joinall(greenLets)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/August/Screenshot%20from%202018-08-02%2013-12-37.png" alt=""></p>
<p>以上程序主要使用　gevent 中的　spawn 方法和　joinall 方法。spawn 方法是用来形成协程，joinall 方法是添加这些协程任务，并且启动运行。从结果可以看出，3 个网络操作是并发执行的，运行结束顺序不同，但其实只有一个线程。</p>
<h3 id="2-协程中池的实现"><a href="#2-协程中池的实现" class="headerlink" title="2. 协程中池的实现"></a>2. 协程中池的实现</h3><p>gevent 中还提供了对池的支持。当拥有动态数量的 gevent 需要进行并发管理时，如限制并发数，可以使用池来实现，这在处理大量的网络和　IO 操作时是非常需要的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'visit ---&gt; %s'</span> % url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'%d bytes received from %s.'</span> % (len(urllib2.urlopen(url).read()), url))</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line">    urls = [<span class="string">'http://github.com'</span>, <span class="string">'https://www.python.org'</span>, <span class="string">'http://yhw-miracle.win'</span>]</span><br><span class="line">    pool.map(run_task, urls)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018/August/Screenshot%20from%202018-08-02%2013-27-30.png" alt=""></p>
<p>运行结果可看出，Pool 对象实现了对协程的并发数量管理，代码中规定协程中的池容量为 2，因此程序是先执行前两个任务，当其中一个任务完成是，才会执行第三个任务，达到了限制并发数的目的。</p>

          <br>
<p> from yhw-miracle</p>
<p align="center"><img src="/images/qrcode_for_gh_5efb2780ab44_258.jpg" alt="痛点就是起点"></p>
<p align="center">算法和代码的世界不仅是学习的痛点，而且是成功的起点。欢迎关注，共同进步！</p>

        </section>
      </div>
      
      <!--<div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/ToYou">ToYou</a>
  
    <a class="main" href="/categories">Categories</a>
  
    <a class="main" href="/atom.xml">RSS</a>
  
</div>
-->
    </div>
    <footer>
  <span class="muted">&copy; 2016 - 2019 yhw-miracle. All Rights Reserved.</span><br>
  <!--<a href='https://github.com/saintwinkle/hexo-theme-scribble' class='muted'>built with Hexo using Scribble theme</a>-->
  <img src="/images/logo.jpg" width="53" height="59" alt="痛点就是起点">
</footer>

  </body>
</html>
