<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>分布式进程</title>

  <link rel="stylesheet" href="/assets/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>分布式进程 | yhw-miracle’s Blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="分布式进程" />
<meta name="author" content="yhw-miracle" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="分布式进程是指将 Process 进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。python 中实现分布式进程要用到 multiprocessing 模块，该模块不仅支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。" />
<meta property="og:description" content="分布式进程是指将 Process 进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。python 中实现分布式进程要用到 multiprocessing 模块，该模块不仅支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。" />
<link rel="canonical" href="http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B" />
<meta property="og:url" content="http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B" />
<meta property="og:site_name" content="yhw-miracle’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-03T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"分布式进程是指将 Process 进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。python 中实现分布式进程要用到 multiprocessing 模块，该模块不仅支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。","author":{"@type":"Person","name":"yhw-miracle"},"@type":"BlogPosting","url":"http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B","headline":"分布式进程","dateModified":"2018-08-03T00:00:00+08:00","datePublished":"2018-08-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>YHW-MIRACLE</h1>
    </a>
    <div class="header-links">
      <a href="/all_posts">
    <h2 class="header-link">All_Posts | </h2>
</a>
<a href="/about">
    <h2 class="header-link">About | </h2>
</a>
<a href="/categories">
    <h2 class="header-link">Categories | </h2>
</a>
<a href="/tags">
    <h2 class="header-link">Tags</h2>
</a>
<!--<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2 align="center">分布式进程</h2>
  <img src="/images/authorize.png" />
  <center>
    yhw-miracle writed in <time datetime="2018-08-03T00:00:00+08:00" class="by-line">August 3rd, 2018</time>
  </center>
  <p>分布式进程是指将 Process 进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。python 中实现分布式进程要用到 multiprocessing 模块，该模块不仅支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。</p>

<p>分布式进程可以用在做爬虫程序中，利用一个服务进程作为调度者，将不同任务分布到其他机器上的进程上，利用网络通信进行管理，提高爬虫程序的效率。下面举例说明分布式进程在爬虫程序中应用。</p>

<blockquote>
  <p>需求：以爬取某个网站上所以图片为例</p>
</blockquote>

<blockquote>
  <p>如果使用多进程，一般是用一个进程负责抓取图片的链接地址，将链接地址放到本地队列中(Queue)，另一个进程负责从队列中读取链接地址并进行下载和存储到本地。</p>
</blockquote>

<blockquote>
  <p>如果使用分布式进程来完成这一需求，需要一台机器负责抓取链接，将链接地址放到队列中(Queue)，这时候需要将队列共享到网络中，便于其他机器中的进程可以访问到，其他机器上的进程负责读取链接并下载存储。分布式进程就是将这一过程进行了封装，相当于本地队列的网络化。</p>
</blockquote>

<p>要实现上述需求，可以编写服务进程，负责抓取链接地址，共享到网络队列上；编写任务进程，负责读取网络队列上的链接地址，并下载存储。</p>

<h4 id="11-服务进程编写过程">1.1 服务进程编写过程：</h4>
<blockquote>
  <ol>
    <li>建立队列　Queue，用来进行进程间的通信。服务进程创建任务队列　taskQueue，用来作为传递任务给任务进程的通道；服务进程创建结果队列　resultQueue，作为任务进程完成任务后回复服务进程的通道。在分布式多进程中，需要通过　QueueManager 获得的　Queue 接口来添加任务。</li>
    <li>把第一步创建的队列在网络上注册，共享给其他机器上的进程，注册后获得网络队列，相当于本地队列的映像。</li>
    <li>建立一个对象　(QueueManager(BaseManager))　实例 manager，绑定端口和验证口令。然后，启动该实例，监管信息通道。</li>
    <li>通过管理实例的方法获得网络访问的　Queue 对象，即把网络队列实体化可以使用的本地队列。</li>
    <li>创建任务到本地队列中，自动上传任务到网络队列中，分配给任务进程进行处理。</li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># coding:utf-8
</span>
<span class="kn">import</span> <span class="nn">random</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>

<span class="c1"># 第一步： 建立 taskQueue 和 resultQueue ，用了存放任务和结果
</span><span class="n">taskQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
<span class="n">resultQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="c1"># 第二步： 把创建的两个队列注册在网络上，利用 register 方法，callable 参数关联了 Queue 对象
</span>    <span class="c1"># 将 Queue 对象在网络上暴露
</span>    <span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">'getTaskQueue'</span><span class="p">,</span> <span class="nb">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">taskQueue</span><span class="p">)</span>
    <span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">'getResultQueue'</span><span class="p">,</span> <span class="nb">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">resultQueue</span><span class="p">)</span>

    <span class="c1"># 第三步： 绑定端口 8001，设置验证口令'yhw-miracle'（这个相当于对象的初始化）
</span>    <span class="n">manager</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s">''</span><span class="p">,</span> <span class="mi">8001</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="s">'yhw-miracle'</span><span class="p">)</span>

    <span class="c1"># 启动管理，监听信息通道
</span>    <span class="n">manager</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># 第四步： 通过管理实例的方法获得通过网络访问的 Queue 对象
</span>    <span class="n">task</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">getTaskQueue</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">getResultQueue</span><span class="p">()</span>

    <span class="c1"># 第五步： 添加任务
</span>    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'ImageUrl_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'put task </span><span class="si">%</span><span class="s">s ...'</span> <span class="o">%</span> <span class="n">url</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="c1"># 获取返回的结果
</span>    <span class="k">print</span><span class="p">(</span><span class="s">'try get result ...'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'result is </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>

    <span class="c1"># 关闭管理
</span>    <span class="n">manager</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="12-任务进程编写过程">1.2 任务进程编写过程：</h4>
<blockquote>
  <ol>
    <li>使用　QueueManager 注册用于获取　Queue 的方法名称，任务进程只能通过名称来获取网络上的 Queue。</li>
    <li>连接服务器，保持端口和验证口令与服务进程一致。</li>
    <li>获取网络上的　Queue，进行本地化。</li>
    <li>从 taskQueue 获取任务，并把结果写入 resultQueue。</li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># coding:utf-8
</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>


<span class="c1"># 创建类似的 QueueManager
</span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="c1"># 第一步： 使用 QueueManager 注册用于获取 Queue 的方法名称
</span>    <span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">'getTaskQueue'</span><span class="p">)</span>
    <span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">'getResultQueue'</span><span class="p">)</span>

    <span class="c1"># 第二步： 连接到服务器
</span>    <span class="n">serverAddr</span> <span class="o">=</span> <span class="s">'127.0.0.1'</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Connect to server </span><span class="si">%</span><span class="s">s ...'</span> <span class="o">%</span> <span class="n">serverAddr</span><span class="p">)</span>
    <span class="c1"># 端口和验证口令注意保持与服务进程完全一致
</span>    <span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="n">serverAddr</span><span class="p">,</span> <span class="mi">8001</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="s">'yhw-miracle'</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

    <span class="c1"># 第三步： 获取 Queue 对象
</span>    <span class="n">task</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">getTaskQueue</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">getResultQueue</span><span class="p">()</span>

    <span class="c1"># 第四步： 从 task 队列获取任务，并把结果写入到 result 队列
</span>    <span class="k">while</span><span class="p">(</span><span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">empty</span><span class="p">()):</span>
        <span class="n">imageUrl</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'run task download </span><span class="si">%</span><span class="s">s ...'</span> <span class="o">%</span> <span class="n">imageUrl</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s">'</span><span class="si">%</span><span class="s">s ---&gt; success'</span> <span class="o">%</span> <span class="n">imageUrl</span><span class="p">)</span>

    <span class="c1"># 处理结束
</span>    <span class="k">print</span><span class="p">(</span><span class="s">'worker exit.'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/images/2018/August/Screenshot%20from%202018-08-03%2013-31-06.png" alt="" /></p>

<p><img src="/images/2018/August/Screenshot%20from%202018-08-03%2013-31-15.png" alt="" /></p>

<p>小结：其实这是一个简单但真正的分布式进程，把代码稍加改造，启动多个任务进程，就可以把任务分不到多台机器上，实现大规模的分布式爬虫。</p>

</article>


	<div class="tags">
	<img src="/images/tag.png" />
	
		<a href="/tag/python">python</a>
	
		<a href="/tag/分布式进程">分布式进程</a>
	
	</div>






	<div class="categories">
	<img src="/images/category.png" />
	
	  <a href="/category/知识总结">知识总结</a>
	
	</div>




<div class="pagination">
    上一篇：
    
      <a href="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" class="previous">
        <img src="/images/previous.png" />
      </a>
    
  
    | 下一篇：
    
      <a href="/%E5%8D%8F%E7%A8%8B" class="next">
        <img src="/images/next.png" />
      </a>
    
  </div>


      </section>
    </div>
  </div>

  

  <div align="center" id="qecode_img">
  <hr />
  <p>欢迎关注，我们一起进行认知迭代！</p>
  <img src="/images/qrcode_for_gh_5efb2780ab44_258.jpg" /><br />
  痛点就是起点
</div>

<footer>
  <!-- <a href="https://blogs.yhw-miracle.cn">
    <span>
        <b>yhw-miracle</b>
    </span>
    
    <span>© 2016 - 2019</span>
  </a> -->
</footer>

<div align="center" style="font-size: 13px;">
  <hr />
  <span>&copy; 2016 - 2019</span>基于
  <a href="https://jekyllrb.com">jekyll</a> | 
  <a href="https://github.com">Github Pags</a> | 
  By <a href="blogs.yhw-miracle.cn">yhw-miracle</a>
</div>


  <!--  -->
</body>
</html>