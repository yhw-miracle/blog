<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>python之进程</title>

  <link rel="stylesheet" href="/assets/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>python之进程 | yhw-miracle’s Blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="python之进程" />
<meta name="author" content="yhw-miracle" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，另一种是使用 multiprocessing 模块。这两种方法的区别在于前者适用于 Unix/Linux 操作系统，对 Windows 系统不支持，后者则是跨平台的实现方式。" />
<meta property="og:description" content="进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，另一种是使用 multiprocessing 模块。这两种方法的区别在于前者适用于 Unix/Linux 操作系统，对 Windows 系统不支持，后者则是跨平台的实现方式。" />
<link rel="canonical" href="http://localhost:4000/python%E4%B9%8B%E8%BF%9B%E7%A8%8B" />
<meta property="og:url" content="http://localhost:4000/python%E4%B9%8B%E8%BF%9B%E7%A8%8B" />
<meta property="og:site_name" content="yhw-miracle’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，另一种是使用 multiprocessing 模块。这两种方法的区别在于前者适用于 Unix/Linux 操作系统，对 Windows 系统不支持，后者则是跨平台的实现方式。","author":{"@type":"Person","name":"yhw-miracle"},"@type":"BlogPosting","url":"http://localhost:4000/python%E4%B9%8B%E8%BF%9B%E7%A8%8B","headline":"python之进程","dateModified":"2018-07-31T00:00:00+08:00","datePublished":"2018-07-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/python%E4%B9%8B%E8%BF%9B%E7%A8%8B"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>YHW-MIRACLE</h1>
    </a>
    <div class="header-links">
      <a href="/all_posts">
    <h2 class="header-link">All_Posts | </h2>
</a>
<a href="/about">
    <h2 class="header-link">About | </h2>
</a>
<a href="/categories">
    <h2 class="header-link">Categories | </h2>
</a>
<a href="/tags">
    <h2 class="header-link">Tags</h2>
</a>
<!--<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2 align="center">python之进程</h2>
  <img src="/images/authorize.png" />
  <center>
    yhw-miracle writed in <time datetime="2018-07-31T00:00:00+08:00" class="by-line">July 31st, 2018</time>
  </center>
  <p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，另一种是使用 multiprocessing 模块。这两种方法的区别在于前者适用于 Unix/Linux 操作系统，对 Windows 系统不支持，后者则是跨平台的实现方式。</p>

<h3 id="1-使用-os-模块中的-fork-方法实现多进程">1. 使用 os 模块中的 fork 方法实现多进程</h3>
<p>python 的 os 模块封装了常见的系统调用，其中就有 fork 方法。fork 方法来自于 Unix/Linux 操作系统中提供的一个 fork 系统调用，这个方法非常特殊。普通方法都是调用一次，返回一次。而fork 方法是调用一次，返回两次，原因在操作系统将当前系统（父进程）复制出一份进程（子进程），这两个进程几乎完全相同，于是 fork 方法分别在父进程和子进程中返回。子进程中永远返回 0，父进程中返回的是子进程的 ID。具体情况，见如下代码，其中，os 模块中的 getpid 方法用于返回当前进程的 ID，getppid 方法用于获取父进程的 ID。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'current Process (</span><span class="si">%</span><span class="s">s) start ...'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'error in fork.'</span>
    <span class="k">elif</span> <span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'I (</span><span class="si">%</span><span class="s">s) create a child process (</span><span class="si">%</span><span class="s">s)'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'I am child process (</span><span class="si">%</span><span class="s">s) and my parent process is (</span><span class="si">%</span><span class="s">s)'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">())</span>
</code></pre></div></div>

<p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-32-10.png" alt="" /></p>

<h3 id="2-使用-multiprocessing-模块创建多进程">2. 使用 multiprocessing 模块创建多进程</h3>
<p>multiprocessing 模块提供了一个 Process 类来描述进程对象。创建子进程时，只需要传入一个执行函数和函数参数，即可完成一个 Process 实例的创建，用 start() 方法启动进程，用 join() 实现进程间的同步。下面，用一个例子来演示说明。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="k">def</span> <span class="nf">run_process</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Child process </span><span class="si">%</span><span class="s">s (</span><span class="si">%</span><span class="s">s) Running...'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'Parent process </span><span class="si">%</span><span class="s">s.'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_process</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),))</span>
        <span class="k">print</span> <span class="s">'Process will start.'</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">'Process end.'</span>
</code></pre></div></div>

<p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-38-25.png" alt="" /></p>

<p>进程具有并发性，共享性，独立性和异步性，以上代码中子进程输出语句说明了进程的异步性。</p>

<h3 id="3-multiprocessing-模块提供了-pool-类来代表进程池对象">3. multiprocessing 模块提供了 Pool 类来代表进程池对象</h3>
<p>以上两种创建进程的方法在启动大量子进程时，需要手动限制进程数量，显得太过繁琐，而使用进程池批量创建子进程的方式更加方便。</p>

<p>multiprocessing 模块提供了 Pool 类来代表进程池对象，Pool 类可以提供制定数量的进程供用户调用，默认大小是 CPU 的核数。当有新的请求提交到 Pool 中时，如果进程池还没有满，那么就会创建一个新的进程用来执行该请求；如果进程池中的进程数已经达到规定的最大值，那么该请求就好等待，直到池中有进程结束，才会创建新的进程来处理它。下面，用代码来演示进程池对象。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">os</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">random</span>


<span class="k">def</span> <span class="nf">run_task</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'Task </span><span class="si">%</span><span class="s">s (pid = </span><span class="si">%</span><span class="s">s) is running...'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">'Task </span><span class="si">%</span><span class="s">s end.'</span> <span class="o">%</span> <span class="n">name</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'current process </span><span class="si">%</span><span class="s">s.'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">run_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,))</span>
    <span class="k">print</span> <span class="s">'Waiting for all subprocess done...'</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">'All subprocess done.'</span>
</code></pre></div></div>

<p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-56-10.png" alt="" /></p>

<h3 id="4-进程间通信">4. 进程间通信</h3>
<p>操作系统中存在大量进程，那么进程间的通信是必不可少的。python 提供了 Queue 和 Pipe 两张方式实现进程间的通信，两张区别在于，Pipe 常用来在两个进程间通信，Queue 用来在多个进程间实现通信。</p>

<h4 id="41-queue-实现进程通信">4.1 Queue 实现进程通信</h4>
<p>Queue 是多进程安全的队列，可以使用 Queue 实现多进程间的数据传递，有两个方法 Put 和 Get 可以进行 Queue 操作。</p>

<blockquote>
  <p>Put 方法用以插入数据到队列中，它还有两个可选数据：blocked 和 timeout。如果 blocked 为 True （默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间；如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该队列以满，会立即抛出 Queue.Full 异常。</p>
</blockquote>

<blockquote>
  <p>Get 方法可以从队列读取并且删除一个元素。Get 方法也有两个可选参数：blocked 和 timeout。如果 blocked 为 True （默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常；如果 blocked 为 False，有两张情况：如果队列有元素可以用，则立即会返回该值；否则，如果队列为空，立即抛出 Queue.Empty 异常。</p>
</blockquote>

<p>下面用代码来演示 Queue 实现进程间通信。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
<span class="kn">import</span> <span class="nn">os</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">random</span>


<span class="k">def</span> <span class="nf">process_write</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">urls</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Process (</span><span class="si">%</span><span class="s">s) is writing...'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Put </span><span class="si">%</span><span class="s">s to queue...'</span> <span class="o">%</span> <span class="n">url</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">process_read</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Process (</span><span class="si">%</span><span class="s">s) is reading...'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Get </span><span class="si">%</span><span class="s">s from queue...'</span> <span class="o">%</span> <span class="n">url</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">process_write1</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_write</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="s">'url1'</span><span class="p">,</span> <span class="s">'url2'</span><span class="p">,</span> <span class="s">'url3'</span><span class="p">]))</span>
    <span class="n">process_write2</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_write</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="s">'url4'</span><span class="p">,</span> <span class="s">'url5'</span><span class="p">,</span> <span class="s">'url6'</span><span class="p">]))</span>
    <span class="n">process_reader</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_read</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>

    <span class="n">process_write1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">process_write2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">process_reader</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">process_write1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">process_write2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="n">process_reader</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/images/2018/Screenshot%20from%202018-07-31%2013-20-31.png" alt="" /></p>

<h4 id="42-pipe-实现进程通信">4.2 Pipe 实现进程通信</h4>
<p>Pipe 通常用来在两个进程间进行通信，两个进程分别位于管道的两端。Pipe 方法返回 (conn1, conn2) 代表管道的两端，该方法还有 duplex 参数，如果 duplex 参数为 True （默认值），那么这个管道是全双工模式，也就是管道两端均可以同时接收和返送数据；如果 duplex 参数为 False，conn1 只负责接收消息，conn2 只负责发送消息。</p>

<p>send 和 recv 方法分别是发送和接收消息的方法，如果没有消息可接收，recv 方法会一直阻塞，如果管道关闭，那么 recv 方法会抛出 EOFError。下面通过代码来演示 Pipe 实现进程通信。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">multiprocessing</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">os</span><span class="p">,</span> <span class="n">time</span>


<span class="k">def</span> <span class="nf">process_send</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">urls</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Process (</span><span class="si">%</span><span class="s">s) send: </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">url</span><span class="p">))</span>
        <span class="n">pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">process_recv</span><span class="p">(</span><span class="n">pipe</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Process (</span><span class="si">%</span><span class="s">s) recv: </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">()))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pipe</span><span class="p">()</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_send</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="s">'url'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_recv</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span>

    <span class="n">p1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">p1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/images/2018/Screenshot%20from%202018-07-31%2013-34-23.png" alt="" /></p>

</article>


	<div class="tags">
	<img src="/images/tag.png" />
	
		<a href="/tag/python">python</a>
	
		<a href="/tag/进程">进程</a>
	
	</div>






	<div class="categories">
	<img src="/images/category.png" />
	
	  <a href="/category/知识总结">知识总结</a>
	
	</div>




<div class="pagination">
    上一篇：
    
      <a href="/python%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B" class="previous">
        <img src="/images/previous.png" />
      </a>
    
  
    | 下一篇：
    
      <a href="/python%E4%B9%8BIO%E7%BC%96%E7%A8%8B" class="next">
        <img src="/images/next.png" />
      </a>
    
  </div>


      </section>
    </div>
  </div>

  

  <div align="center" id="qecode_img">
  <hr />
  <p>欢迎关注，我们一起进行认知迭代！</p>
  <img src="/images/qrcode_for_gh_5efb2780ab44_258.jpg" /><br />
  痛点就是起点
</div>

<footer>
  <!-- <a href="https://blogs.yhw-miracle.cn">
    <span>
        <b>yhw-miracle</b>
    </span>
    
    <span>© 2016 - 2019</span>
  </a> -->
</footer>

<div align="center" style="font-size: 13px;">
  <hr />
  <span>&copy; 2016 - 2019</span>基于
  <a href="https://jekyllrb.com">jekyll</a> | 
  <a href="https://github.com">Github Pags</a> | 
  By <a href="blogs.yhw-miracle.cn">yhw-miracle</a>
</div>


  <!--  -->
</body>
</html>