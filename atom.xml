<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>痛点就是起点</title>
  
  <subtitle>Speaking is as important as doing!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-15T11:33:43.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yhw-miracle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解基础爬虫架构</title>
    <link href="http://yoursite.com/2019/01/15/%E8%AF%A6%E8%A7%A3%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/01/15/详解基础爬虫架构/</id>
    <published>2019-01-14T16:00:01.000Z</published>
    <updated>2019-01-15T11:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础爬虫框架主要包括五大模块，分别为<code>URL</code>管理器、<code>HTML</code>下载器、<code>HTML</code>解析器、数据存储器和爬虫调度器。它们之间关系如下图所示。</p><p><img src="/images/2019/Jan/2.png" alt=""></p><p><code>URL</code>管理器负责管理<code>URL</code>链接，维护已爬取的<code>URL</code>集合和为未爬取的<code>URL</code>集合，并提供外部访问接口。</p><p><code>HTML</code>下载器负责从<code>URL</code>管理器中获取未爬取的<code>URL</code>链接，并下载相应的<code>HTML</code>网页。</p><p><code>HTML</code>解析器负责解析<code>HTML</code>下载器下载的网页信息，解析出的信息交给数据存储器，解析出的新的<code>URL</code>链接交给<code>URL</code>管理器。</p><p>数据存储器负责将<code>HTML</code>解析器解析出来的数据通过文件或数据库的形式存储起来。</p><p>爬虫调度器负责统筹以上四个模块之间协调工作。</p><p>以爬取百度百科<code>100</code>条词条的词条标题、摘要和链接为例。</p><h3 id="URL管理器"><a href="#URL管理器" class="headerlink" title="URL管理器"></a><code>URL</code>管理器</h3><p><code>URL</code>管理器维护了两个变量，已爬取<code>URL</code>集合和未爬取<code>URL</code>集合；对外提供了四类访问这两个变量的方法，包括是否有待爬取的<code>URL</code>、获取未爬取的<code>URL</code>、添加新的<code>URL</code>到未爬取集合中、已爬取<code>URL</code>集合和未爬取<code>URL</code>集合的大小。</p><p><code>URL</code>管理器需要对爬取的<code>URL</code>进行去重处理，常见的去重方案有三种，分别是内存去重、关系数据库去重和缓存数据库去重。</p><p>两个变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.new_urls = set()</span><br><span class="line">self.old_urls = set()</span><br></pre></td></tr></table></figure></p><p>六个方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">have_new_url(self)</span><br><span class="line">get_new_url(self)</span><br><span class="line">add_new_url(self, url)</span><br><span class="line">add_new_urls(self, urls)</span><br><span class="line">new_url_size(self)</span><br><span class="line">old_url_size(self)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.new_urls = set()</span><br><span class="line">        self.old_urls = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">have_new_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断是否有待爬取的 url</span></span><br><span class="line"><span class="string">        :return: 待爬取的 url 集合的大小</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.new_url_size() != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取待爬取的 url</span></span><br><span class="line"><span class="string">        :return: 一个待爬取的 url</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_url = self.new_urls.pop()</span><br><span class="line">        <span class="keyword">if</span> new_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.old_urls.add(new_url)</span><br><span class="line">            <span class="keyword">return</span> new_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_url</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        添加一个待爬取的 url</span></span><br><span class="line"><span class="string">        :param url:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.new_urls <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.old_urls:</span><br><span class="line">            self.new_urls.add(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_urls</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        添加待爬取的 url 集合</span></span><br><span class="line"><span class="string">        :param urls:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> urls <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(urls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.add_new_url(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_url_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        待爬取的 url 集合的大小</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.new_urls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">old_url_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        已爬取的 url 集合的大小</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.old_urls)</span><br></pre></td></tr></table></figure><h3 id="HTML下载器"><a href="#HTML下载器" class="headerlink" title="HTML下载器"></a><code>HTML</code>下载器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        user_agent = <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span> \</span><br><span class="line">                     <span class="string">"Chrome/71.0.3578.98 Safari/537.36"</span></span><br><span class="line">        headers = &#123;<span class="string">"User-Agent"</span>: user_agent&#125;</span><br><span class="line">        req = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> req.status_code == <span class="number">200</span>:</span><br><span class="line">            req.encoding = <span class="string">"utf-8"</span></span><br><span class="line">            <span class="keyword">return</span> req.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="HTML解析器"><a href="#HTML解析器" class="headerlink" title="HTML解析器"></a><code>HTML</code>解析器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re, urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parser</span><span class="params">(self, page_url, html_content)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param page_url:</span></span><br><span class="line"><span class="string">        :param html_content:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> page_url <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> html_content <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        soup = BeautifulSoup(html_content, <span class="string">"lxml"</span>)</span><br><span class="line">        new_urls = self.get_new_urls(page_url, soup)</span><br><span class="line">        new_data = self.get_new_data(page_url, soup)</span><br><span class="line">        <span class="keyword">return</span> new_urls, new_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_urls</span><span class="params">(self, page_url, soup)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param page_url:</span></span><br><span class="line"><span class="string">        :param soup:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_urls = set()</span><br><span class="line">        links = soup.find_all(<span class="string">"a"</span>, href=re.compile(<span class="string">r'/item/(%\w+)+/\d+'</span>))</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            new_url = link[<span class="string">"href"</span>]</span><br><span class="line">            new_full_url = urlparse.urljoin(page_url, new_url)</span><br><span class="line">            new_urls.add(new_full_url)</span><br><span class="line">        <span class="keyword">return</span> new_urls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_data</span><span class="params">(self, page_url, soup)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param page_url:</span></span><br><span class="line"><span class="string">        :param soup:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        data[<span class="string">"url"</span>] = page_url.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">        title = soup.find(<span class="string">"dd"</span>, class_=<span class="string">"lemmaWgt-lemmaTitle-title"</span>).find(<span class="string">"h1"</span>)</span><br><span class="line">        data[<span class="string">"title"</span>] = title.string.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">        summary = soup.find(<span class="string">"div"</span>, class_=<span class="string">"lemma-summary"</span>)</span><br><span class="line">        data[<span class="string">"summary"</span>] = summary.get_text().encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h3 id="数据存储器"><a href="#数据存储器" class="headerlink" title="数据存储器"></a>数据存储器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataOutput</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.datas = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.datas.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_html</span><span class="params">(self)</span>:</span></span><br><span class="line">        headers = [<span class="string">"url"</span>, <span class="string">"title"</span>, <span class="string">"summary"</span>]</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"baike.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp_csv = csv.DictWriter(fp, headers)</span><br><span class="line">            fp_csv.writeheader()</span><br><span class="line">            fp_csv.writerows(self.datas)</span><br></pre></td></tr></table></figure><h3 id="爬虫调度器"><a href="#爬虫调度器" class="headerlink" title="爬虫调度器"></a>爬虫调度器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> URLManager <span class="keyword">import</span> URLManager</span><br><span class="line"><span class="keyword">from</span> HtmlDownloader <span class="keyword">import</span> HtmlDownloader</span><br><span class="line"><span class="keyword">from</span> HtmlParser <span class="keyword">import</span> HtmlParser</span><br><span class="line"><span class="keyword">from</span> DataOutput <span class="keyword">import</span> DataOutput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.manager = URLManager()</span><br><span class="line">        self.downloader = HtmlDownloader()</span><br><span class="line">        self.parser = HtmlParser()</span><br><span class="line">        self.output = DataOutput()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self, root_url)</span>:</span></span><br><span class="line">        self.manager.add_new_url(root_url)</span><br><span class="line">        <span class="keyword">while</span>(self.manager.have_new_url() <span class="keyword">and</span> self.manager.old_url_size() &lt; <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                new_url = self.manager.get_new_url()</span><br><span class="line">                html = self.downloader.download(new_url)</span><br><span class="line">                new_urls, data = self.parser.parser(new_url, html)</span><br><span class="line">                self.manager.add_new_urls(new_urls)</span><br><span class="line">                self.output.store_data(data)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"已经爬取 %s 个链接"</span> % self.manager.old_url_size()</span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"crawl failed."</span></span><br><span class="line">                <span class="keyword">print</span> e</span><br><span class="line">        self.output.output_html()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    spider = Spider()</span><br><span class="line">    spider.crawl(<span class="string">"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基础爬虫框架主要包括五大模块，分别为&lt;code&gt;URL&lt;/code&gt;管理器、&lt;code&gt;HTML&lt;/code&gt;下载器、&lt;code&gt;HTML&lt;/code&gt;解析器、数据存储器和爬虫调度器。它们之间关系如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019/Ja
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫框架" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>python实现邮件发送</title>
    <link href="http://yoursite.com/2019/01/15/python%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>http://yoursite.com/2019/01/15/python实现邮件发送/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-15T11:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在爬虫开发中，爬虫运行过程中遇到异常或服务器遇到问题时，我们可以采用发送邮件，及时报告爬虫程序当前故障问题。</p><p>邮件发送协议是<code>SMTP</code>，<code>python</code>内置对<code>SMTP</code> 的支持，可以发送纯文本邮件、<code>HTML</code> 邮件已经带附件的邮件。<code>python</code>中对<code>SMTP</code>支持有 <code>smtpplib</code>和<code>email</code>模块，<code>email</code> 负责构造邮件，<code>smtplib</code>负责发送邮件。</p><p>1.以网易的邮件发送服务器为例<code>smtp.163.com</code>，需要开启网易邮箱的<code>smtp</code>功能。</p><p>2.构造纯文本邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">"你好，世界！"</span>, <span class="string">"plain"</span>, <span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure></p><p>构造<code>html</code>邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">"&lt;a href='https://yhw-miracle.win/'&gt;my blog&lt;/a&gt;"</span>, <span class="string">"html"</span>, <span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure></p><p>3.设置发件人信息、收件人信息和邮件主题信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from_addr = <span class="string">"yhw_software@163.com"</span></span><br><span class="line">password = <span class="string">"********"</span></span><br><span class="line"></span><br><span class="line">to_addr = <span class="string">"yhw_software@qq.com"</span></span><br><span class="line"></span><br><span class="line">smtp_server = <span class="string">"smtp.163.com"</span></span><br><span class="line"></span><br><span class="line">msg[<span class="string">'From'</span>] = format_addr(<span class="string">"我是 &lt;%s&gt;"</span> % from_addr)</span><br><span class="line">msg[<span class="string">"To"</span>] = format_addr(<span class="string">"你是 &lt;%s&gt;"</span> % to_addr)</span><br><span class="line">msg[<span class="string">"Subject"</span>] = Header(<span class="string">"晚安"</span>, <span class="string">"utf-8"</span>).encode()</span><br></pre></td></tr></table></figure></p><p>4.发送邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>完整代码如下所示。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">"utf-8"</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from_addr = <span class="string">"yhw_software@163.com"</span></span><br><span class="line">password = <span class="string">"*********"</span></span><br><span class="line"></span><br><span class="line">to_addr = <span class="string">"yhw_software@qq.com"</span></span><br><span class="line"></span><br><span class="line">smtp_server = <span class="string">"smtp.163.com"</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">"晚上好！"</span>, <span class="string">"plain"</span>, <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">msg[<span class="string">'From'</span>] = format_addr(<span class="string">"我是 &lt;%s&gt;"</span> % from_addr)</span><br><span class="line">msg[<span class="string">"To"</span>] = format_addr(<span class="string">"你是 &lt;%s&gt;"</span> % to_addr)</span><br><span class="line">msg[<span class="string">"Subject"</span>] = Header(<span class="string">"晚安"</span>, <span class="string">"utf-8"</span>).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在爬虫开发中，爬虫运行过程中遇到异常或服务器遇到问题时，我们可以采用发送邮件，及时报告爬虫程序当前故障问题。&lt;/p&gt;
&lt;p&gt;邮件发送协议是&lt;code&gt;SMTP&lt;/code&gt;，&lt;code&gt;python&lt;/code&gt;内置对&lt;code&gt;SMTP&lt;/code&gt; 的支持，可以发送纯文
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="邮件发送" scheme="http://yoursite.com/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>提取多媒体文件</title>
    <link href="http://yoursite.com/2019/01/14/%E6%8F%90%E5%8F%96%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/01/14/提取多媒体文件/</id>
    <published>2019-01-13T16:00:01.000Z</published>
    <updated>2019-01-15T11:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用 python 爬取多媒体文件，存储它们有两种方式，一是只存储 url 链接，二是将文件下载下来。存储文件链接可以将文件的链接信息存储到 json 文件或 csv 文件；下载文件需要用到 urllib 模块提供的 urlretrieve() 函数，urlretrieve() 函数可以将远程数据下载到本地。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlretrieve(url,filename=<span class="keyword">None</span>,reporthook=<span class="keyword">None</span>,data=<span class="keyword">None</span>,context=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>参数 filename 是指存储的本地路径；reporthook 是一个回调函数，当连接到服务器以及传输完毕相应的数据块，会调用该回调函数，一般用于显示下载进度。</p><p>以爬取天堂网图片为例 <a href="http://www.ivsky.com/tupian/ziranfengguang/" target="_blank" rel="noopener">http://www.ivsky.com/tupian/ziranfengguang/</a>，下载图片的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span><span class="params">(blocknum, blocksize, totalsize)</span>:</span></span><br><span class="line">    per = <span class="number">100.0</span> * blocknum * blocksize / totalsize</span><br><span class="line">    <span class="keyword">if</span> per &gt; <span class="number">100</span>:</span><br><span class="line">        per = <span class="number">100</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"当前下载进度： %d"</span> % per</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_agent = <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span> \</span><br><span class="line">             <span class="string">"Chrome/71.0.3578.98 Safari/537.36"</span></span><br><span class="line">headers = &#123;<span class="string">"User-Agent"</span>: user_agent&#125;</span><br><span class="line">req = requests.get(<span class="string">"http://www.ivsky.com/tupian/ziranfengguang/"</span>, headers=headers)</span><br><span class="line"></span><br><span class="line">html = etree.HTML(req.text)</span><br><span class="line">img_urls = html.xpath(<span class="string">".//img/@src"</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> img_url <span class="keyword">in</span> img_urls:</span><br><span class="line">    urllib.urlretrieve(img_url, <span class="string">"./images/img"</span>+str(i)+<span class="string">".jpg"</span>, schedule)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/images/2019/Jan/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用 python 爬取多媒体文件，存储它们有两种方式，一是只存储 url 链接，二是将文件下载下来。存储文件链接可以将文件的链接信息存储到 json 文件或 csv 文件；下载文件需要用到 urllib 模块提供的 urlretrieve() 函数，urlretrieve
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多媒体文件" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6/"/>
    
      <category term="下载" scheme="http://yoursite.com/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据存储为json和csv</title>
    <link href="http://yoursite.com/2019/01/14/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%BAjson%E5%92%8Ccsv/"/>
    <id>http://yoursite.com/2019/01/14/数据存储为json和csv/</id>
    <published>2019-01-13T16:00:00.000Z</published>
    <updated>2019-01-14T08:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>进行 python 爬虫时，我们需要将数据存储起来。对于小数据量，我们可以存储到 json 文件或 csv 文件。</p><h3 id="json存储"><a href="#json存储" class="headerlink" title="json存储"></a>json存储</h3><p>Python 对 json 文件的操作是通过 JSON 模块实现的，分为编码和解码两个过程。</p><p>编码是指将 python 对象转换为 json 对象，常用的函数是 dump() 和 dumps()，区别是 dump() 将 python 对象转换为 json 对象，并将 json 对象通过文件流写入文件，dumps() 函数是返回字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dumps(obj,skipkeys=<span class="keyword">False</span>,ensure_ascii=<span class="keyword">True</span>,check_circular=<span class="keyword">True</span>,allow_nan=<span class="keyword">True</span>,cls=<span class="keyword">None</span>,indent=<span class="keyword">None</span>,separators=<span class="keyword">None</span>,encoding=<span class="string">'utf-8'</span>,default=<span class="keyword">None</span>,sort_keys=<span class="keyword">False</span>,**kw)</span><br><span class="line">dumps(obj,skipkeys=<span class="keyword">False</span>,ensure_ascii=<span class="keyword">True</span>,check_circular=<span class="keyword">True</span>,allow_nan=<span class="keyword">True</span>,cls=<span class="keyword">None</span>,indent=<span class="keyword">None</span>,separators=<span class="keyword">None</span>,encoding=<span class="string">'utf-8'</span>,default=<span class="keyword">None</span>,sort_keys=<span class="keyword">False</span>,**kw)</span><br></pre></td></tr></table></figure><p>解码是指将 json 对象转换为 python 对象，常用的函数为 load() 和loads()，区别是 load() 是将 json 对象转换为 python 对象，并将 python 对象写入到文件，而 loads() 是返回字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load(fp,encoding=<span class="keyword">None</span>,cls=<span class="keyword">None</span>,object_hook=<span class="keyword">None</span>,parse_float=<span class="keyword">None</span>,parse_int=<span class="keyword">None</span>,parse_constant=<span class="keyword">None</span>,object_pairs_hook=<span class="keyword">None</span>,**kw)</span><br><span class="line">loads(s,encoding=<span class="keyword">None</span>,cls=<span class="keyword">None</span>,object_hook=<span class="keyword">None</span>,parse_float=<span class="keyword">None</span>,parse_int=<span class="keyword">None</span>,parse_constant=<span class="keyword">None</span>,object_pairs_hook=<span class="keyword">None</span>,**kw)</span><br></pre></td></tr></table></figure><h3 id="csv存储"><a href="#csv存储" class="headerlink" title="csv存储"></a>csv存储</h3><p>CSV(Comma-Separated Values，逗号分隔值，有时也称为字符分隔值)，其文件是以纯文本形式存储表格数据。CSV 文件由任意数目的记录组成，记录间以换行符分隔，每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号和制表符。CSV 文件示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID,Username,Password,Age,Country</span><br><span class="line"></span><br><span class="line">1001,yhw,123456,24,China</span><br><span class="line"></span><br><span class="line">1002,Mary,654321,25,USA</span><br><span class="line"></span><br><span class="line">1003,Jack,123567,22,English</span><br></pre></td></tr></table></figure><p>Python 通过 csv 库来读写 csv 文件。Python 写 csv 文件，需要用到 write 对象，然后按行写每一个记录；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">header = (<span class="string">"ID"</span>, <span class="string">"Username"</span>, <span class="string">"Password"</span>, <span class="string">"Age"</span>, <span class="string">"Country"</span>)</span><br><span class="line">rows = [(<span class="number">1001</span>, <span class="string">"yhw"</span>, <span class="string">"123456"</span>, <span class="number">24</span>, <span class="string">"China"</span>),</span><br><span class="line">        (<span class="number">1002</span>, <span class="string">"Mary"</span>, <span class="string">"654321"</span>, <span class="number">25</span>, <span class="string">"USA"</span>),</span><br><span class="line">        (<span class="number">1003</span>, <span class="string">"Jack"</span>, <span class="string">"123567"</span>, <span class="number">22</span>, <span class="string">"English"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test3.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp_csv = csv.writer(fp)</span><br><span class="line">    fp_csv.writerow(header)</span><br><span class="line">    fp_csv.writerows(rows)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">rows = [&#123;<span class="string">"ID"</span>: <span class="number">1001</span>, <span class="string">"Username"</span>: <span class="string">"yhw"</span>, <span class="string">"Password"</span>: <span class="string">"123456"</span>, <span class="string">"Age"</span>: <span class="number">24</span>, <span class="string">"Country"</span>: <span class="string">"China"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"ID"</span>: <span class="number">1002</span>, <span class="string">"Username"</span>: <span class="string">"Mary"</span>, <span class="string">"Password"</span>: <span class="string">"654321"</span>, <span class="string">"Age"</span>: <span class="number">25</span>, <span class="string">"Country"</span>: <span class="string">"USA"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"ID"</span>: <span class="number">1003</span>, <span class="string">"Username"</span>: <span class="string">"Jack"</span>, <span class="string">"Password"</span>: <span class="string">"123567"</span>, <span class="string">"Age"</span>: <span class="number">22</span>, <span class="string">"Country"</span>: <span class="string">"English"</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test3.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">fp_csv = csv.DictWriter(fp, header)</span><br><span class="line">    fp_csv.writeheader()</span><br><span class="line">    fp_csv.writerows(rows)</span><br></pre></td></tr></table></figure><p>Python 读取 csv 文件需要用到 reader 对象，然后同样是按行读取每一条记录。要读取特定字段信息，python 可以利用索引、命名元祖、字典这三种方式访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test3.csv"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># 遍历记录</span></span><br><span class="line">    fp_csv = csv.reader(fp)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> fp_csv:</span><br><span class="line">        <span class="keyword">print</span> row</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 索引</span></span><br><span class="line">    fp_csv = csv.reader(fp)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> fp_csv:</span><br><span class="line">        <span class="keyword">print</span> row[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 命名元组</span></span><br><span class="line">    fp_csv = csv.reader(fp)</span><br><span class="line">    header = next(fp_csv)</span><br><span class="line">    Row = namedtuple(<span class="string">"Row"</span>, header)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> fp_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        <span class="keyword">print</span> row.Username, row.Password</span><br><span class="line">        <span class="keyword">print</span> row</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字典</span></span><br><span class="line">    fp_csv = csv.DictReader(fp)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> fp_csv:</span><br><span class="line">        <span class="keyword">print</span> row.get(<span class="string">"Username"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行 python 爬虫时，我们需要将数据存储起来。对于小数据量，我们可以存储到 json 文件或 csv 文件。&lt;/p&gt;
&lt;h3 id=&quot;json存储&quot;&gt;&lt;a href=&quot;#json存储&quot; class=&quot;headerlink&quot; title=&quot;json存储&quot;&gt;&lt;/a&gt;jso
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
      <category term="csv" scheme="http://yoursite.com/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>总结BeautifulSoup</title>
    <link href="http://yoursite.com/2019/01/13/%E6%80%BB%E7%BB%93BeautifulSoup/"/>
    <id>http://yoursite.com/2019/01/13/总结BeautifulSoup/</id>
    <published>2019-01-12T16:00:00.000Z</published>
    <updated>2019-01-13T09:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.BeautifulSoup4 支持 python 标准库(html.parser)、lxml、html5lib 这些解析器解析文档。</p><p>2.格式化输出文档内容 print soup.prettify()，会自动补全文档。</p><p>3.BeautifulSoup4 将复杂的 html 文档转换成一个复杂的树形结构，每一个节点是 python 对象，所有的对象有四种：Tag、NavigableString、BeautifulSoup、Comment。</p><p>4.Tag 查找的是文档中第一个符合内容的标记，有两个属性：name 和 attrs，分别为获取标记的名称和属性，.attrs 返回的是字典类型，也可以用 [] 和 get() 来获取特定的属性内容。</p><p>5.NavigableString 表示的是标记内部的字符串，可以用 .string 来获取。</p><p>6.BeautifulSoup 表示的是文档的全部内容，.name 返回的是 [document]，.attrs 返回的是 {}。</p><p>7.Comment 表示的是文档的注释内容，用 .string 可以获取去掉注释符号的注释内容，可以用 type() == bs4.element.Comment 来判断该字符串是否为注释。</p><p>8.BeautifulSoup 将 html 文档转换为文档树，支持子节点、父节点、兄弟节点和前后节点进行遍历文档树。</p><p>9.获取子节点的属性有 contents、children、descendants。contents 以列表的形式返回直接子节点信息；children 返回的是直接子节点迭代器，可以用 for in 循环遍历；descentants 返回的子孙节点迭代器，可以用 for in 循环遍历。</p><p>10.获取子节点内容的属性有 string、strings、stripped_strings。string 返回的是标记最内部的内容；strings 返回的是标记内部字符串的迭代器，可以用 for in 循环遍历，包括空格和换行；stripped_string 是去掉 strings 中的空格和换行。</p><p>11.获取节点的父节点的属性是 parent，获取节点的父辈节点的属性是 parents，返回父辈节点的迭代器，可以使用 for in 循环遍历。 </p><p>12.获取节点的兄弟节点的属性有 next_sibling，next_siblings 和 previous_sibling，previous_siblings。节点的兄弟节点包括字符串节点（字符串、空格、换行）。</p><p>13.获取节点的前后节点的属性有 next_element，next_elements 和 previous_element，previous_elements。同样前后节点也包括字符串节点。</p><p>14.搜索文档树的方法主要是一系列 find 方法，以列表的形式返回。以 find_all(name, attrs, recursive, text, limit, **kwargs) 为例，其中 name 参数以节点的名称来搜索文档树；attrs 参数以节点的属性信息来搜索文档树，以字典形式给出；text 参数以节点的内容来搜索文档树；kwargs 参数可以以不是 python 内置的关键字参数来搜索文档树，包括标记的 class 属性，id 属性等。name、attrs、text、kwargs 参数支持字符串、正则表达式、列表、TRUE（匹配任何值）。recursive 参数为 False 时，BeautifulSoup 会搜索直接子节点，limit 会限制 BeautifulSoup 搜索节点的个数。</p><p>15.BeautifulSoup 还支持 CSS 语法来搜索文档树，使用的方法是 select()，返回的类型是列表类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.BeautifulSoup4 支持 python 标准库(html.parser)、lxml、html5lib 这些解析器解析文档。&lt;/p&gt;
&lt;p&gt;2.格式化输出文档内容 print soup.prettify()，会自动补全文档。&lt;/p&gt;
&lt;p&gt;3.Beautiful
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="BeautifulSoup" scheme="http://yoursite.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>备份是一个好工具</title>
    <link href="http://yoursite.com/2019/01/11/%E5%A4%87%E4%BB%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/01/11/备份是一个好工具/</id>
    <published>2019-01-11T07:00:00.000Z</published>
    <updated>2019-01-11T07:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="故事发生"><a href="#故事发生" class="headerlink" title="故事发生"></a>故事发生</h3><p>我是 1 月 5 号晚上使用 ubuntu 系统时，由于编程需要，决定重装 python 3。可是，我在终端中输入卸载原来 python 3 命令“sudo apt-get remove python3”，回车后，先是一系列检测 python 3 所有的程序包，终端中输出有九百多兆大小，我想都没想，直接按了个 y，卸载任务就这样开始执行了。大概持续了5分钟左右，随着卸载任务进行，我发现桌面上的火狐浏览器、chrome 浏览器都都不见了，才意识到我刚刚此举的严重性。等我第二天再打开 ubutnu 系统时，此时的系统已经没有任务栏了，可惜的是，我当时沉浸在深深的自责中，没有截图来记录这一“伟大”的实验。这个现象应该是那个命令卸载了一些系统程序，导致部分系统组件不能正常显示。没办法，此时最好的办法就是重装系统了。</p><h3 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h3><p>在我开始安装 ubuntu16.04 系统时，快要安装成功时，系统却提示引导安装失败（我电脑是window 10 + ubuntu 16.04 双系统，引导失败，意味着双系统安装失败，只能使用 ubuntu 16.04 系统）。虽然，有方法可以修复引导，可是完美主义兼懒癌晚期的我岂能容下这个小瑕疵，尝试三次，依然是引导安装失败，我才悻悻地决定重新安装 windows 10系统 + ubuntu 18.04 系统。</p><p>有时候不是我们愿意犯错，而是每一次犯错之前，我们都希望这一次会成功，所以，判断出确定的错误是多么实用的能力。</p><h3 id="前路曲折，每步需谨慎"><a href="#前路曲折，每步需谨慎" class="headerlink" title="前路曲折，每步需谨慎"></a>前路曲折，每步需谨慎</h3><p>走到这一步，我想既然都重装双系统了，那还不如来个“从头再来”，前进路上坑多了，自然会想到回来，去另外一条路。于是，我开始备份数据，从 ubuntu 16.04 系统到 windows 10 系统，而且采用的是最原始的备份方式，拷贝到 U 盘中去。不得不说，300 多 G 数据的备份耗费了五六小时，此时我只有感叹备份效率太低，渴求备份技术能够突破。</p><p>这里，我要强烈地吐槽一下 ubuntu 系统，人机交互做得太差了！我在复制 ubuntu 16.04 系统中的数据，进度条跑完，我就弹出 U 盘，按理说，这应该是很正确的做法。可是，当我再进入 windows 10 系统，准备复制 windows 10 中的数据时，我在 windows 10 中打开 ubuntu 中复制的数据，发现大多数文件都已乱码，只有小部分数据完好的，很显然，数据拷贝没有完成，可是 ubuntu 中复制进度条已经跑完呀。这里，windows 10 系统做得挺好的，因为从一个磁盘复制到另一个磁盘，不可能一个单位一个单位地复制，需要借助中间缓冲区域，即缓冲区。Windows 10 系统复制文件的进度条百分比展示的是文件到缓冲区的数量，而进度条结束表明文件复制结束。进度条百分比虽然到 100%，但是进度条不一定结束。此时，我只有感叹眼见不一定为实。</p><h3 id="备份时遗留的坑是恢复时付出的汗水"><a href="#备份时遗留的坑是恢复时付出的汗水" class="headerlink" title="备份时遗留的坑是恢复时付出的汗水"></a>备份时遗留的坑是恢复时付出的汗水</h3><p>双系统安装完后，接下来的任务就是恢复数据，让电脑恢复如初。因为我之前博客是利用 hexo 搭建的，备份数据时导致以前很多博客文章文件拷贝失败，而且我之前弄的博客没有任何备份机制，我只有无奈地采取从网页文件中复制出来，人工地进行恢复博客文件，好在，一切都顺利进行，电脑恢复如初了。</p><p>写到这里，我深有体会，任何一项工程，凡是加上时间这一因素，数据增长的速度会很惊人的。如果当初在设计该工程时，要么就祈求这个工程永不宕机；要么就考虑备份机制，就设计出好用且方便的备份工具来。很显然，永不宕机的可能性很低，应该这样说，是高效且好用的备份机制保证了长时间不宕机的可能。时间在不停地推着我们前进，但是我们也应该时不时去回顾过去，分析过去，展望未来，让我们更平稳地前进。因此，备份是一个好工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;故事发生&quot;&gt;&lt;a href=&quot;#故事发生&quot; class=&quot;headerlink&quot; title=&quot;故事发生&quot;&gt;&lt;/a&gt;故事发生&lt;/h3&gt;&lt;p&gt;我是 1 月 5 号晚上使用 ubuntu 系统时，由于编程需要，决定重装 python 3。可是，我在终端中输入卸载原来 
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="时间" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="备份" scheme="http://yoursite.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>2018总结</title>
    <link href="http://yoursite.com/2019/01/01/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/01/2018总结/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-01-09T12:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>得到 APP 创始人罗振宇曾说过，一个好的自我介绍就是四条，任何场合自我介绍，你总有几秒到几十秒甚至几分钟的考虑时间，你可以在这时间里心里考虑这四件事。</p><p>第一件事，在有限的时间里，我必须给大家介绍那些硬的信息事什么，比如我叫什么名字，我是哪的人，哪个学校毕业的，这都叫硬信息。但请注意，只是第一层，这就是简历那个部分。</p><p>第二件事，你现在想，我为什么来到这个场合？我跟这个场合的关系的是什么？</p><p>第三件事，我能够提供给大家的价值的是什么？</p><p>第四件事，我在这儿需要获得大家的帮助是什么？</p><p>在做 2018 年总结前，我先正式的写一段自我介绍。</p><p>我叫痛点就是起点，今天我来复盘自己的 2018 年，这里是我的 2018 年总结。这份总结是自我剖析的产物，是引领我 2019 年成长的旗帜，希望各位不吝赐教，共同成长。</p><p>时光荏苒，2018 年过去了，回顾这一年，我草草地毕业，被动地接受社会的洗礼，甚至在“修身”和“齐家”这两个目标没有明确的执行计划。总之，从 2 月份确认考研失败以来，我的2018 年是纠结的，是迷茫的，是灰色的。</p><p>2018 年，有几个词句真的是触动到了我。</p><p><strong>自杀式单身</strong>，指的是一直 单身又不主动扩展社交范围去认识新朋友，却每天幻想着能拥有爱情的行为。2018 年的我，不，应该是我人生的前四分之一（以百岁人生为目标）都在诠释这个词，内心渴望充满友谊的聚会，希望有那个她能够与我协同进化，执行 Yes 和 and 的心法，可是一次又一次我却认为孤独很好，一个人世界充满着的奇幻和乐趣。</p><p><strong>投资自己是最大的投资。</strong>2018 年，由年初美国的贸易保护，一直持续到年尾，到很多公司被爆出大量裁员，很多投资者纷纷发表言论，2018 的冬天格外冷，认为这个冬天投资自己是最大的投资。其实，这句话无论什么时候都是正确的，无论外部环境好与坏，投资自己，提高自己的认知能力，熟练自己的用脑程度，这些都是必要的。这个世界，走的快的人会把走得慢的落下，认知能力高的终究把能力低的人甩下，向上层阶级涌动的道路一直都很拥挤，阶级下滑的路去畅通无阻。</p><p><strong>小趋势是影响趋势的趋势，带来改变的改变。</strong>这句话，出自罗振宇的《时间的朋友·第4场》跨年演讲。关于小趋势，我想回顾一下我过去二十几年。我是一位 95 后，自我出生时，国家执行计划生育政策，“只生一个好”，“生男生女一个样”，等等，而我就是这样的高压政策下来到了这个世界，可能是让我明白我的出生来之不易，希望我明白韶光易逝，劝君善待时间；2007年，我正碰上了小学五年制改六年制，可能是让我明白学生年代的宝贵性，希望我好好珍惜这短暂的学生年代；2011 年夏，我参加完中考，只因为中考分数差点，而不得不选择人们眼中稍差的学校，可是三年的高中生涯让我明白优秀是相对的，成绩是过去的，而成长却是一直陪伴我们始终的；2014 年我步入了大学的门槛，而这一切可能是上天故意安排的，偏偏我们这一届一个班，偏偏我们这一届教学计划是老计划，偏偏在大学快结束时，我才明白过来，所谓的教育，只不过是便于管理。2018 年，我毕业了，在缺乏社会经验，应该说是很缺乏社会经验，面对未来的生活和失败的考研的经历，我又一次跳进去，由社会的浪潮推着前进，全然不知这一切的小趋势。也许，这就是生活吧，它糟糕得要命，容不得你有半点重来的机会，但你会爱上它的。</p><p>2019 年已经到来，我只希望这一年我能一直成长，时刻感受、抓住并记录身边的小趋势。2019 年，我想发下一个大愿，未来十二年，公众号日更，继续英语学习，并定期推送计算机专业知识以及其他知识的学习，每天成长一点。<strong>简单来说，未来十二年，公众号日更，每天推送自己的学习和思考内容。</strong>2019 年加油，忘了说了，2019 年是我的本命年，本命年，加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;得到 APP 创始人罗振宇曾说过，一个好的自我介绍就是四条，任何场合自我介绍，你总有几秒到几十秒甚至几分钟的考虑时间，你可以在这时间里心里考虑这四件事。&lt;/p&gt;
&lt;p&gt;第一件事，在有限的时间里，我必须给大家介绍那些硬的信息事什么，比如我叫什么名字，我是哪的人，哪个学校毕业的
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>考研政治选择题命题人思路</title>
    <link href="http://yoursite.com/2018/11/09/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98%E5%91%BD%E9%A2%98%E4%BA%BA%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/11/09/考研政治选择题命题人思路/</id>
    <published>2018-11-08T16:00:00.000Z</published>
    <updated>2019-01-09T12:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="马原"><a href="#马原" class="headerlink" title="马原"></a>马原</h3><h4 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h4><ol><li>人类社会发展的根本动力：社会基本矛盾。易将重要动力与根本动力混为一谈，如，阶级斗争是重要动力。</li><li>马克思主义之所以具有如此强大的生命力：实践性，科学性，革命性。</li><li>马克思主义鲜明特征：实践性，科学性，革命性，人民性，发展性。</li><li>马克思主义包含马哲、政经和科社，其中马哲是基础，方法；政经是主体内容；科社是归宿。</li><li>矛盾是普遍存在，和谐社会也存在矛盾（非对抗性）。</li><li>共产主义社会：物质财富极大丰富、人民精神境界极大提高、每个人自由而全面发展。</li><li>自由是尊重规律和不牺牲别人的自由。</li><li>科学性表现在按照世界的本来面目去认识世界。<h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4></li><li>不彻底的唯物主义：自然观上是唯物主义，历史观上是唯心主义。</li><li>不彻底的唯心主义：否认物质与意识的同一性。</li><li>马克思在哲学史上两大贡献：辩证唯物主义和历史唯物主义；理论上是两大贡献：唯物史观和剩余价值。</li><li>唯物主义与唯心主义：物质与意识何者为第一性；可知论与不可知论：思维和存在是否具有同一性；辩证法和1形而上学：世界是怎样发展的；唯物史观和唯心史观：社会意识和社会存在何者为第一性。</li><li>夸大规律，导致宿命论；夸大主观能动性，导致唯意志论。</li><li>意识的能动作用具有两面性。错误论述：意识的能动作用使事物向正确方向发展。错误论述：只有正确的意识才能反作用于客观事物。</li><li>正确论述：意识能够改造（创造）客观事物。</li><li>物质是运动的基础和承担者；运动的原因和根据是矛盾；运动的根本属性和存在方式是时空；静止是过去运动的结果和未来运动的出发点。</li><li>错误论述：唯心主义哲学同人类认识伴随始终。</li><li>错误论述：物质的各种实物的总和。“实物”，“总和”。物质是…的抽象。</li><li>意识和物质是对立统一；在一定范围，只对立（只统一）。</li><li>错误论述：鬼神观念是人脑对鬼神的虚幻反映。意识是对物质的反映。</li><li>正确论述：意识只是对客观存在近似的反映。错误论述：意识不能准确、完整地反映客观存在。</li><li>意识和物质的统一性：意识对物质具有相对独立性。</li><li>错误论述：电脑和机器人也能进行某些实践活动。</li><li>错误论述：人类能够发现、改造、创造客观规律。正确论述：人类可以发现规律，改变规律起作用的条件和方式。正确论述：人类能够发现、认识、利用客观规律。<h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4></li><li>事物内部的肯定反面和否定反面的对立统一运动，表现形式是螺旋式上升的过程；实质是事物自我完善和发展的过程。</li><li>感性认识与理性认识是深浅区别，不是对错区别。</li><li>假象是错误的现象；错觉是错误的感觉。</li><li>主观辩证法与客观辩证法是反映与被反映的关系。</li><li>自然规律与社会规律的联系是客观性。它们的区别是：自然规律是盲目的，自发的，没有主观参与，精确重复；社会规律是有意识的，自觉的，主客观相互制约，是一种趋势。</li><li>矛盾的解决：矛盾一方克服另外一方；矛盾双方达到谐同运动的状态；矛盾双方毁灭，转化为新矛盾。</li><li>矛盾的斗争性寓于同一性之中。</li><li>普遍和特殊，一般和个别，共性和个性。</li><li>矛盾的普遍性寓于（存在于）特殊性之中。必然性寓于偶然性之中。</li><li>外因只能通过内因才能起作用。</li><li>社会规律实现的特点是既有不以人的意志为转移的规律，又有人的主观能动性。</li><li>错误论述：新事物在任何时候都能战胜旧事物。正确论述：新事物一定会战胜旧事物。</li><li>正确论述：凡是在历史上产生的都会在历史上灭亡。<h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4></li><li>正确论述：认识是实践的先导。错误论述：认识先于实践。</li><li>正确论述：实践作为检验真理的标准即是确定的，又是不确定的。</li><li>旧唯物主义认识论：直观反映论；辩证唯物主义认识论：能动反映论。</li><li>唯物主义认识论：反映论；唯心主义认识论：先验论。</li><li>正确论述：感性认识是理性认识的基础。</li><li>唯心主义观点：理性认识能够建构认识对象。</li><li>正确论述：认识的根本目的是实践。错误论述：认识的根本目的是通过现象认识本质。这类错误论述一般将认识的根本目的论述为其他。</li><li>哲学概念之间有级别高低，没有重要高低。</li><li>错误论述：真理和谬误没有原则界限。</li><li>错误论述：科学实验是社会存在的基础。实践包括物质生产，政治实践和科学实验，其中物质生产是社会存在的基础。</li><li>错误论述：理性认识能指导人们推动事物的发展。正确论述：；理性认识能够指导人们推动或阻碍事物的发展。</li><li>感性认识和理性认识是深浅区别，不是对错区别。</li><li>正确论述：真理只能是主观对客观事物近似正确即相对正确的反映。</li><li>真理与价值，规律与能动。真理，规律（该这么做），价值，能动（想怎么做）。</li><li>正确论述：认识的基础是实践。错误论述：感性认识是认识的基础。只能说感性认识的认识的第一个阶段。</li><li>正确论述：实践决定认识的产生和发展。</li><li>正确论述：实践是认识的唯一来源。</li><li>正确论述：实践是实现思想目的的感性物质活动。实践过程体现主体的目的，受主体的意识指导，体现主体的能动性。</li><li>错误论述；认识只是客体在主体的头脑中的直接再现。这是一种直观（机械）反映论。</li><li>错误论述：对同一件事件的不同看法可以都是正确的。违背了真理的一元性。</li><li>有用未必是真理，真理一定是有用的。</li><li>人类的认识能力是无限和有限的统一，至上性和非至上性的统一。</li><li>自由的条件性：认识上，认知越多，越自由；实践上，尊重客观规律，尊重别人的自由。</li><li>事物发展和人类的认识能力有待发展决定了真理的相对性。<h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4></li><li>社会存在决定社会意识。</li><li>错误论述：社会心理可以左右社会发展方向。</li><li>生产方式是生产力和生产关系的统一；社会形态是经济基础和上层建筑的统一；人的本质是一切社会关系的总和；生产力是劳动资料、劳动对象和劳动力的统一；生产资料是劳动资料和劳动对象的统一。</li><li>错误论述：人类的活动目的本身就是历史规律。</li><li>错误论述：人民群众的意志就是历史的发展方向。</li><li>错误论述：人们在实践活动中所形成的各种社会关系属于社会存在范畴。生产关系是属于社会存在范畴。</li><li>生产关系是生产的形式，是人们在生产过程中结成的人与人的物质利益关系。</li><li>错误论述：社会基本矛盾都可以通过自我完善和自我发展的方式加以解决。社会基本矛盾在剥削社会是对抗性的，在非剥削社会是对抗性的。</li><li>人类社会的发展是由物质力量决定的，并受精神力量影响的。</li><li>错误论述：社会发展是由多种力量最终决定的。</li><li>人性包括自然属性和社会属性，社会属性是本质属性。<h4 id="政治经济学"><a href="#政治经济学" class="headerlink" title="政治经济学"></a>政治经济学</h4></li><li>商品的交换是解决商品内在的使用价值和价值的矛盾。</li><li>错误论述：使用价值越高，所含价值就越高。</li><li>正确论述：使用价值是价值的物质承担者。</li><li>资本的本质是在物的外壳掩盖下的一种社会关系。价值、资本、货币的本质是人与人的关系。</li><li>工资是劳动者必要劳动时间创造的价值（剩余劳动被资本家无偿占有），是劳动力的价值（本质），是劳动力的价格（本质），表现为了劳动的价格（掩盖资本主义剥削的实质）。</li><li>行业，部门（生产资料部门和生活资料部门），全社会。</li><li>利润被看作全部预付资本的产物，而剩余价值不是（c+v—&gt;r,v—&gt;m）。</li><li>利润和剩余价值的相同点：剩余价值和利润在量上是相等的；剩余价值和利润归根到底都是由工人的劳动创造出来的。</li><li>错误论述：资本输出是区分自由竞争和垄断两个发展阶段的根本标志。</li><li>商品本质上体现的是人与人之间的关系，是把人与人之间的关系物化了。</li><li>错误论述：商品之所以成为商品是因为它是劳动产品。进行交换的劳动产品的商品。</li><li>价值规律是内容是商品的价值是由生产商品的社会必要劳动时间决定的；商品交换以价值量为基础，按照等价原则进行。</li><li>价值规律的表现形式的价格围绕价值、生产价格、垄断价格上下波动，在不同阶段表现形式会不同。</li><li>价值规律的作用是价值规律可能造成商品生产者的两极分化。</li><li>劳动是劳动力的使用，它不是商品，没有价值或价格。</li><li>错误论述：如果竞争不复存在，垄断企业就没有动力和压力壮大自己的实力。垄断企业壮大的内因是获得更多的利润，外因是竞争。</li><li>错误论述：对于资本输出国来说，垄断资本的扩张只有积极作用，没有不利影响。</li><li>正确论述：从整个社会来看，商品的价格总额仍然等于商品的价值总量。</li><li>私人资本所有制、股份、国家、法人资本所有制。<h4 id="科学社会主义"><a href="#科学社会主义" class="headerlink" title="科学社会主义"></a>科学社会主义</h4></li><li>社会关系的高度和谐体现在国家消亡，阶级消亡，工业与农业、城市与乡村、脑力劳动与体力劳动—“三大差别”消失，人、自然及社会都达成和谐。</li><li>错误论述：苏联模式是一条完全适合俄国国情的社会主义道路。<h3 id="思修法基"><a href="#思修法基" class="headerlink" title="思修法基"></a>思修法基</h3><h4 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h4></li><li>是否爱自己的骨肉同胞是检验一个人爱国的试金石。爱灿烂文化是爱国的摇篮、精神基因。</li><li>民族精神：伟大的梦想精神，伟大的团结精神，伟大的奋斗精神，伟大的创造精神。</li><li>在社会主义社会，实现人生价值的标准是个体对社会和他人做贡献。</li><li>个人与社会、个人与他人关系的核心为利益关系。</li><li>社会主义核心价值观需要践行，贯穿实践当中，不是理想。</li><li>错误论述：爱国主义是永恒的。<h4 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h4></li><li>道德的功能：认识功能（行为前）、规范功能（行为中）、调节功能（行为后）。</li><li>维护公共生活秩序的基本手段是道德和法律。</li><li>基本国策：对外开放、一国两制、保护环境、节约资源、男女平等。</li><li>男女平等是道德要求，也是法律要求，还是基本国策，不是政治要求。</li><li>爱国主义是道德要求，也是法律要求，还是政治要求。</li><li>社会主义核心价值观的道义 力量：先进性、人民性、真实性。</li><li>错误论述：有序的公共生活是提高社会成员物质生活质量的基本保证。错误在于物质。</li><li>错误论述：个人品德是维护社会成员之间最基本的社会关系秩序的最起码的道德要求。</li><li>个人品德是经济社会发展进程中重要的主体精神力量。<h4 id="法律修养"><a href="#法律修养" class="headerlink" title="法律修养"></a>法律修养</h4></li><li>既是权利又是义务：劳动、教育。</li><li>未来中国法治国家发展和宪政之路的基本价值取向是保障公民的自由平等。</li><li>中国特色社会主义法律体系中，法律是主干，宪法是统帅。</li><li>《中华人民共和国香港特别行政区基本法》属于宪法相关法。</li><li>法律运行的环节来看，法律公正包括立法公正和执法公正；法律公正的内涵来看，法律公正包括实体公正和程序公正。</li><li>法律强制的主体是国家（主动主体）、社会成员（被动主体）与社会组织（被动主体）。</li><li>错误论述：公民在法律判决面前一律平等。</li><li>正确论述：公民在适用法律上一律平等。</li><li>法律适用的主体是国家司法机关（法院、检察院）及其公职人员。</li><li>宪法的修改需由1/5以上的全国人大代表提议，2/3以上全国人大代表通过。</li><li>我国社会主义法律的本质特征是阶级性与人民性的统一，科学性和先进性的统一。</li><li>国家机关包括行政机关、司法机关、军事机关、权力机关。</li><li>思想道德和法律在调解领域、调解方式、调解目标等方面存在很大不同。</li><li>公正司法是维护社会公平正义的最后一道防线。</li><li>法律权利和义务之间的关系包括：结构上的相关关系、总量上的等值关系和功能上的互补关系。</li><li>行政复议：执法部门和群众之间。</li><li>契约自由是商法中的基本原则。<h3 id="史纲"><a href="#史纲" class="headerlink" title="史纲"></a>史纲</h3><h4 id="旧民主主义革命时期"><a href="#旧民主主义革命时期" class="headerlink" title="旧民主主义革命时期"></a>旧民主主义革命时期</h4></li><li>争取名族独立和人民解放是解放民族复兴的前提。</li><li>洋务运动时期的民用工业的性质是资本主义性质，官督商办。</li><li>中国近代思想的共同主题是救亡图存。</li><li>导致中国近代历次反侵略战争失败的原因包括：社会制度腐败，经济技术落后。</li><li>维新派自身的局限性：不敢否定封建主义、对帝国主义抱有幻想、惧怕人民群众；客观原因：民族资产阶级力量弱小。</li><li>封建主义，政治上：封建君主专制制度；经济上：封建土地剥削制度。</li><li>辛亥革命的任务：反帝反封；纲领：不反帝且反封不彻底；结果：打击了帝国主义和封建主义。<h4 id="新民主主义革命时期"><a href="#新民主主义革命时期" class="headerlink" title="新民主主义革命时期"></a>新民主主义革命时期</h4></li><li>新民主主义革命与旧民主主义革命的区别：革命指导思想、革命前途和革命领导权。其中革命领导权是区分的根本标志。</li><li>中国的民族民主革命是无产阶级领导的资产阶级民主革命，但客观上属于世界无产阶级社会主义革命的一部分是在十月革命后。</li><li>主观主义的实质就是理论脱离实际；表现形式：教条主义、经验主义。</li><li>阶级局限性（主观原因），敌人太强大（客观原因），自身力量弱小（客观原因）。</li><li>大革命失败到土地革命兴起的转折点是八七会议。</li><li>无产阶级反帝反封的态度最坚决。</li><li>洛川会议开启了全面的全民族抗战新阶段。</li><li>正确论述：农民是中国革命的主力军，无产阶级是中国革命最基本的动力。错误论述：农民是中国革命最基本的动力。</li><li>错误论述：民族资产阶级没有提出明确的革命纲领。正确论述：民族资产阶级没有提出科学的革命纲领。</li><li>构成人民民主专政主要联盟的阶级是工人阶级、农民阶级和城市小资产阶级。各革命阶级联合专政中的阶级是工、农、小、民。<h4 id="新中国时期"><a href="#新中国时期" class="headerlink" title="新中国时期"></a>新中国时期</h4></li><li>20世纪的中国经历了三次历史性巨变：辛亥革命、中华人民共和国的成立和社会主义制度的确立、改革开放。</li><li>新民主主义社会的五种经济成分：社会主义国营经济、合作化经济、个体经济、国家资本主义、私人资本主义。</li><li>社会主义革命是反资反私。</li><li>首次科学阐述思想路线是《矛盾论》、《实践论》；思想路线在全党范围内确立是在延安整风运动；重新确立实事求是的思想路线是在十一届三中全会。<h3 id="毛中特"><a href="#毛中特" class="headerlink" title="毛中特"></a>毛中特</h3><h4 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h4></li><li>毛泽东思想开始形成：大革命到土地革命；走向成熟：遵义会议到抗日战争；写入党章：中共七大；继续发展：建国后。</li><li>毛泽东思想的活的灵魂：实事求是（精髓）、群众路线和独立自主；邓小平理论的活的灵魂（精髓）：解放思想，实事求是。</li><li>十一届六中全会，发表的《关于建国以来党的若干历史问题的决议》：评价毛泽东和毛泽东思想；对社会主义初级阶段的主要矛盾作了表述；首次使用社会主义初级阶段的概念（系统论述并作为国情加以把握在十三大）。</li><li>中国革命的基本问题：农民问题；首要问题：分清敌友问题；中心问题：无产阶级的领导权问题。</li><li>新民主主义革命时期最重要的关系：与农民；最根本的经验：与资产阶级的关系。</li><li>错误论述：“剥削阶级的脏东西”主要是指小资产阶级思想。</li><li>新中国成立是中国人民成为国家和社会的主人；社会主义改造完成是广大劳动人民成为国家和社会的主人。<h4 id="中国特色社会主义理论体系之邓、三、科"><a href="#中国特色社会主义理论体系之邓、三、科" class="headerlink" title="中国特色社会主义理论体系之邓、三、科"></a>中国特色社会主义理论体系之邓、三、科</h4></li><li>社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</li><li>社会主义的根本原则是共同富裕和公有制。</li><li>依据—&gt;国情；前提—&gt;稳定；根本保证—&gt;党的领导（制度）；重要保障—&gt;法律；战略支撑—&gt;国防军队；出发点，落脚点，归宿—&gt;人；立足点—&gt;独立自主，自力更生。</li><li>非公有制经济是中国特色社会主义经济的重要组成部分，是社会主义市场经济的重要组成部分，为社会主义服务。</li><li>按劳分配以外的多种分配方式的实质是按对生产要素的占有情况进行分配。</li><li>社会主义初级阶段的长期性从根本上取决于中国进入社会主义的历史条件，建设社会主义所需要的物质基础；决定了党的基本路线和基本纲领和社会主义初级阶段的主要矛盾。<h4 id="习近平新时代中国特色社会主义思想"><a href="#习近平新时代中国特色社会主义思想" class="headerlink" title="习近平新时代中国特色社会主义思想"></a>习近平新时代中国特色社会主义思想</h4></li><li>全面深化改革、全面依法治国和全面从严治党是战略举措，全面建成小康社会是战略目标。</li><li>市场作用保证更少的资源生产尽可能多的产品，配置资源有效率。</li><li>习近平新时代中国特色社会主义思想的核心要义是坚持和发展中国特色社会主义。</li><li>根本任务：解放和发展生产力；总任务：实现社会主义现代化和中华民族伟大复兴；中国共产党和中国政府的三大历史任务：实现祖国统一，社会主义现代化，维护世界和平；中国共产党的历史使命：统揽伟大斗争、伟大工程、伟大事业、伟大梦想，在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴。</li><li>四个全面：“鸟之两翼，车之双轮”—&gt;全面深化改革和全面依法治国；引领性环节—&gt;全面建成小康；突破性环节、先导性环节—&gt;全面深化改革；重要组成部分—&gt;全面依法治国和全面从严治党。</li><li>四个意识：政治意识、核心意识、看齐意识和大局意识。</li><li>错误论述：非公有制经济在促进共同富裕进程中具有重要作用。共同富裕需要公有制经济，政府的宏观调控来实现。</li><li>再分配调节机制的主要手段有：税收、社会保障、转移支付。增加财产性收入是初次分配的手段。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;马原&quot;&gt;&lt;a href=&quot;#马原&quot; class=&quot;headerlink&quot; title=&quot;马原&quot;&gt;&lt;/a&gt;马原&lt;/h3&gt;&lt;h4 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h4&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="考研政治" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>内务整理有感</title>
    <link href="http://yoursite.com/2018/09/30/%E5%86%85%E5%8A%A1%E6%95%B4%E7%90%86%E6%9C%89%E6%84%9F/"/>
    <id>http://yoursite.com/2018/09/30/内务整理有感/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2019-01-09T12:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在整理内务时，我无意中在高数书上发现我曾经摘抄的一段话，这段话是“<strong>生活最重要，我很优秀，但并不一定一直要去最好的地方。优秀是为了让自己有更多的选择，当我可以选择时，我甚至可以去放羊。</strong>”</p><p>努力让自己成为一个优秀的人，在哪不重要！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在整理内务时，我无意中在高数书上发现我曾经摘抄的一段话，这段话是“&lt;strong&gt;生活最重要，我很优秀，但并不一定一直要去最好的地方。优秀是为了让自己有更多的选择，当我可以选择时，我甚至可以去放羊。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;努力让自己成为一个优秀的人，在哪不重
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="论优秀" scheme="http://yoursite.com/tags/%E8%AE%BA%E4%BC%98%E7%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>中秋快乐</title>
    <link href="http://yoursite.com/2018/09/24/%E4%B8%AD%E7%A7%8B%E5%BF%AB%E4%B9%90/"/>
    <id>http://yoursite.com/2018/09/24/中秋快乐/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2019-01-09T12:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018/September/mid-autumn.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2018/September/mid-autumn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>初识BeautifulSoup</title>
    <link href="http://yoursite.com/2018/08/09/%E5%88%9D%E8%AF%86BeautifulSoup/"/>
    <id>http://yoursite.com/2018/08/09/初识BeautifulSoup/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2019-01-13T09:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>BeautifulSoup 是一个可以从 HTML 或 XML 文件中提取数据的 python 库，它能通过解析器实现文档的查找提取和修改等功能。</p><h3 id="1-BeautifulSoup-的安装"><a href="#1-BeautifulSoup-的安装" class="headerlink" title="1. BeautifulSoup 的安装"></a>1. BeautifulSoup 的安装</h3><p>对于 BeautifulSoup，目前推荐使用的是 BeautifulSoup 4，BeautifulSoup 3　已经停止开发了。安装 BeautifulSoup 4 有四种方式。</p><blockquote><ol><li>最新版的 Debain 或 Ubuntu 系统可以通过系统的软件包管理来安装，sudo apt-get install Python-bs4。</li><li>BeautifulSoup 4 通过 PyPi 发布，可以通过 easy_install 或 pip 来安装，easy_install beautifulsoup4　或 pip install beautifulsoup4。</li><li>通过源码安装，BeautifulSoup 4 的源码地址为<a href="https://pypi.python.org/pypi/beautifulsoup4/" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4/</a>，下载源码，解压后，运行命令 python setup.py install 即可完成安装。</li><li>通过 PyCharm　里 Project Interpreter 安装 BeautifulSoup 4。</li></ol></blockquote><p><img src="/images/2018/August/Screenshot%20from%202018-08-09%2012-55-42.png" alt=""></p><p>BeautifulSoup 支持 Python 标准库中的 HTML 解析器，还支持一些第三方解析器，如，lxml，html5lib 等，安装这些解析器方法与安装 BeautifulSoup 4 类似。</p><table><thead><tr><th>解析器</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python 标准库</td><td>Python 的内置标准库，执行速度适中，文档容错能力强</td><td>Python 早期版本文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>速度快，文档容错能力强</td><td>需要安装 C 语言库</td></tr><tr><td>lxml xml 解析器</td><td>速度快，唯一支持 xml 的解析器</td><td>需要安装 c　语言库</td></tr><tr><td>html5lib</td><td>最好的容错性，以浏览器方式解析文档，生成 HTML5 格式的文档</td><td>速度慢，不依赖外部扩展</td></tr></tbody></table><h3 id="2-BeautifulSoup-的使用"><a href="#2-BeautifulSoup-的使用" class="headerlink" title="2. BeautifulSoup 的使用"></a>2. BeautifulSoup 的使用</h3><p>BeautifulSoup 将复杂的 HTML 文档转换成一个复杂的树形结构，每个节点是 python 对象，这些对象可以归纳为 Tag、NavigableString、BeautifulSoup、Comment。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 测试文档　--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>my blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>One<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>Two</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.cn/one"</span> <span class="attr">class</span>=<span class="string">"one"</span> <span class="attr">id</span>=<span class="string">"link1"</span>&gt;</span><span class="comment">&lt;!-- one --&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.cn/two"</span> <span class="attr">class</span>=<span class="string">"two"</span> <span class="attr">id</span>=<span class="string">"link2"</span>&gt;</span><span class="comment">&lt;!-- two --&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> and</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.cn/three"</span> <span class="attr">class</span>=<span class="string">"three"</span> <span class="attr">id</span>=<span class="string">"link3"</span>&gt;</span>three<span class="tag">&lt;/<span class="name">a</span>&gt;</span>;</span><br><span class="line">hello,world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-Tag-对象"><a href="#1-Tag-对象" class="headerlink" title="1. Tag 对象"></a>1. Tag 对象</h4><p>Tag 对象可以直接以标签名获取标签内容，Tag 对象还有两个属性 name 和 attr，分别表示获取到标签的名称和标签属性内容（以字典的形式返回）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(soup.a)</span><br><span class="line">print(type(soup.a))</span><br><span class="line">print(soup.a.name)</span><br><span class="line">print(soup.a.attrs)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-18-03.png" alt=""></p><h4 id="2-NavigableString-对象"><a href="#2-NavigableString-对象" class="headerlink" title="2. NavigableString 对象"></a>2. NavigableString 对象</h4><p>NavigableString 对象用来获取标签内部字符串，利用属性 string 来获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.p.string)</span><br><span class="line">print(type(soup.p.string))</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-24-18.png" alt=""></p><h4 id="3-BeautifulSoup-对象"><a href="#3-BeautifulSoup-对象" class="headerlink" title="3. BeautifulSoup 对象"></a>3. BeautifulSoup 对象</h4><p>BeautifulSoup 对象表示一个文档的全部内容，可以理解为特殊的 Tag 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.name)</span><br><span class="line">print(type(soup.name))</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-29-25.png" alt=""></p><h4 id="4-Comment-对象"><a href="#4-Comment-对象" class="headerlink" title="4. Comment 对象"></a>4. Comment 对象</h4><p>Commnet 对象用来获取文档中注释的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.a.string)</span><br><span class="line">print(type(soup.a.string))</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-32-08.png" alt=""></p><h4 id="5-BeautifulSoup-支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。"><a href="#5-BeautifulSoup-支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。" class="headerlink" title="5. BeautifulSoup 支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。"></a>5. BeautifulSoup 支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。</h4><table><thead><tr><th>遍历方面</th><th>属性描述</th></tr></thead><tbody><tr><td>子节点</td><td>.contents, .children, .descendants</td></tr><tr><td>父节点</td><td>.parent, .parents</td></tr><tr><td>兄弟节点</td><td>.previous_sibling(s), .next_sibling(s)</td></tr><tr><td>前后节点</td><td>.previous_element(s), .next_element(s)</td></tr></tbody></table><p>BeautifulSoup 还支持 find*() 方法搜索文档树，以及支持 select() 方法根据　CSS 选择器查找文档中指定的标签。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BeautifulSoup 是一个可以从 HTML 或 XML 文件中提取数据的 python 库，它能通过解析器实现文档的查找提取和修改等功能。&lt;/p&gt;
&lt;h3 id=&quot;1-BeautifulSoup-的安装&quot;&gt;&lt;a href=&quot;#1-BeautifulSoup-的安装&quot;
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="BeautifulSoup" scheme="http://yoursite.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>python实现正则</title>
    <link href="http://yoursite.com/2018/08/08/python%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2018/08/08/python实现正则/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-01-09T12:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>python 通过 re 模块实现对正则表达式的支持，一般先将正则表达式的字符串形式编译为 Pattern 实例，然后使用 Pattern 实例处理文本并获得匹配结果，最后使用 Match 实例获得信息。</p><p>python 中常用的实现正则表达式匹配函数有两种调用方式 re 调用和 pattern 调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re 调用</span></span><br><span class="line">&gt; <span class="number">1.</span> re.compile(string[,flag])</span><br><span class="line">&gt; <span class="number">2.</span> re.match(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">3.</span> re.search(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">4.</span> re.split(pattern, string[,maxsplit[,flags]])</span><br><span class="line">&gt; <span class="number">5.</span> re.findall(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">6.</span> re.finditer(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">7.</span> re.sub(pattern, repl, string[,flags[,count]])</span><br><span class="line">&gt; <span class="number">8.</span> re.subn(pattern, repl, string[,flags[,count]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pattern 调用</span></span><br><span class="line">&gt; <span class="number">1.</span> re.compile(string[,flag])</span><br><span class="line">&gt; <span class="number">2.</span> pattern.match(string[,flags])</span><br><span class="line">&gt; <span class="number">3.</span> pattern.search(string[,flags])</span><br><span class="line">&gt; <span class="number">4.</span> pattern.split(string[,maxsplit[,flags]])</span><br><span class="line">&gt; <span class="number">5.</span> pattern.findall(string[,flags])</span><br><span class="line">&gt; <span class="number">6.</span> pattern.finditer(string[,flags])</span><br><span class="line">&gt; <span class="number">7.</span> pattern.sub(repl, string[,flags[,count]])</span><br><span class="line">&gt; <span class="number">8.</span> pattern.subn(repl, string[,flags[,count]])</span><br></pre></td></tr></table></figure><p>其中，flags 参数表示匹配模式，取值有以下几种情况，并且可以使用 “|” 同时使用多种匹配模式。</p><blockquote><ol><li>re.I: 忽略大小写</li><li>re.M: 多行模式，改变 “^” 和 “$” 的含义</li><li>re.S: 点任意匹配模式，改变 “.” 的含义</li><li>re.L: 使预定义字符类 \w\W\b\B\s\S 取决于当前区域设定</li><li>re.U: 使预定义字符类\w\W\b\B\s\S\d\D 取决于 unicode 定义的字符属性<br>6.re.X: 详细模式，这个模式下正则表达式可以是多行的，忽略空白符，并可以加入注释</li></ol></blockquote><p>以上 7 个函数在 re 模块中进行搜索匹配，如果需要获得匹配的数据，这时可以利用 Match 对象，Match 对象保存了正则表达式匹配的过程。Match 对象的属性有：</p><blockquote><ol><li>string: 匹配时使用的文本。</li><li>re: 匹配时使用的 pattern 对象。</li><li>pos: 文本中正则表达式开始搜索的索引。</li><li>endpos: 文本中正则表达式结束搜索的索引。</li><li>lastindex: 最后一个被捕获的分组在文本中的索引。</li><li>lastgroup: 最后一个被捕获的分组的别名。</li><li>group(group1,…): 获得一个或多个分组截获的字符串。</li><li>groups(): 以元组形式返回全部分组截获的字符串。</li><li>groupdict(): 返回以有别名的组的别名为键，以改组截获的子串为值的字典，没有别名的组不包含在内。</li><li>start(group): 返回指定的组截获的子串在 string 中的起始索引。<br>11.end(group): 返回指定的组截获的子串在 string 中的结束索引。</li><li>span(group): 返回 (start(group), end(group))。</li><li>expand(template): 将匹配到的分组代入 template 中然后返回。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r'(\w+) (\w+) (?P&lt;word&gt;.*)'</span>)</span><br><span class="line"></span><br><span class="line">match = pattern.match(<span class="string">'My website is yhw-miracle.win.'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'match.string:'</span> + match.string)</span><br><span class="line">print(<span class="string">'match.re:'</span>, match.re)</span><br><span class="line">print(<span class="string">'match.pos:'</span>, match.pos)</span><br><span class="line">print(<span class="string">'match.endpos:'</span>, match.endpos)</span><br><span class="line">print(<span class="string">'match.lastindex:'</span>, match.lastindex)</span><br><span class="line">print(<span class="string">'match.lastgroup:'</span>, match.lastgroup)</span><br><span class="line">print(<span class="string">'match.group(1,2):'</span>, match.group(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(<span class="string">'match.groups():'</span>, match.groups())</span><br><span class="line">print(<span class="string">'match.groupdict():'</span>, match.groupdict())</span><br><span class="line">print(<span class="string">'match.start(2):'</span>, match.start(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">'match.end(2):'</span>, match.end(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">'match.span(2):'</span>, match.span(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">"match.expand(r'\2 \1 \3'):"</span>, match.expand(<span class="string">r'\2 \1 \3'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-08%2013-38-48.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python 通过 re 模块实现对正则表达式的支持，一般先将正则表达式的字符串形式编译为 Pattern 实例，然后使用 Pattern 实例处理文本并获得匹配结果，最后使用 Match 实例获得信息。&lt;/p&gt;
&lt;p&gt;python 中常用的实现正则表达式匹配函数有两种调用
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/08/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/07/正则表达式/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2019-01-09T12:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是由普通字符以及特殊字符（称为“元字符”）组成的文字模式，可以作为模板，用来描述在搜索文本时要匹配的一个或多个字符串。</p><h3 id="1-常见元字符"><a href="#1-常见元字符" class="headerlink" title="1. 常见元字符"></a>1. 常见元字符</h3><p>元字符主要作用有：用来匹配字符、用来匹配位置、用来匹配数量和用来匹配模式。常见的元字符如下表所示。</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线和汉子</td></tr><tr><td>\s</td><td>匹配任意空白符，包括空格、制表符、换行符、中午全角空格</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h3 id="2-字符转义"><a href="#2-字符转义" class="headerlink" title="2. 字符转义"></a>2. 字符转义</h3><p>如果需要匹配元字符本身，我们需要用到字符转义来实现，使用 “\” 来取消元字符的特殊含义。</p><blockquote><p>例如，需求是匹配 <a href="https://yhw-miracle.win/" target="_blank" rel="noopener">https://yhw-miracle.win/</a> 这个网址时，正则表达式可以写成 <a href="https://yhw-miracle\.win/。" target="_blank" rel="noopener">https://yhw-miracle\.win/。</a></p></blockquote><h3 id="3-重复"><a href="#3-重复" class="headerlink" title="3. 重复"></a>3. 重复</h3><p>正则表达式中用于匹配重复的字符串，可以使用限定符描述，简化正则表达式的书写。</p><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复 n 次</td></tr><tr><td>{n,}</td><td>重复 n 次或更多次</td></tr><tr><td>{n,m}</td><td>重复 n 到 m 次</td></tr></tbody></table><h3 id="4-字符集合"><a href="#4-字符集合" class="headerlink" title="4. 字符集合"></a>4. 字符集合</h3><p>如果需求是匹配没有预定义元字符的字符集合，例如需求是匹配 a,b,c,d,e 中任意一个字符，可以使用自定义字符集合。正则表达式支持自定义字符集合，用 [] 来实现自定义字符集合，中括号内写要匹配的自定义字符集合。对于上述需求，可以使用 [abcde] 来匹配待定字符串。</p><p>中括号内不仅可以写自定义的字符集合，还可以指定自定义字符范围，例如 [0-9] 与 “\d” 是等价的，[a-z0-9A-Z_] 与 “\w” 是等价的（英文情况下）。</p><h3 id="5-分支条件"><a href="#5-分支条件" class="headerlink" title="5. 分支条件"></a>5. 分支条件</h3><p>正则表达式支持多种匹配规则，满足任意一种规则都是匹配成功，这叫作分支条件，用 “|” 把不同匹配规则分隔开即可。</p><blockquote><p>例如匹配 7－11 位 QQ 号，可以利用分支条件。<br>正则表达式为：[1-9]\d{6} | [1-9]\d{7} | [1-9]\d{9} | [1-9]\d{9} | [1-9]\d{10}</p></blockquote><h3 id="6-分组"><a href="#6-分组" class="headerlink" title="6. 分组"></a>6. 分组</h3><p>对于有规律的字符串，我们可以将其分组，分组每一组，从而写出可以匹配的正则表达式。</p><blockquote><p>需求：匹配 IP 地址。<br>分析：IP 地址可以分为四组，以 . 分隔开，每一组数字不能大于 255。<br>正则表达式：((25[0-5] | 2[0-4]\d | [0-1]\d{2} | [1-9]?\d).){3}(25[0-5] | 2[0-4]\d | [0-1]\d{2} | [1-9]?\d).)</p></blockquote><p>正则表达式中使用小括号指定的表达式为一个分组，默认情况下，每一个分组自动有一个组号，从左到右，以分组的左括号为标志，第一个出现的分组组号为 1，第二个出现是分组组号为 2，以此类推。正则表达式可以利用分组号引用前面组的表达式，这叫做后向引用，简化正则表达式的书写。</p><p>对于分组，我们也可以自定义分组名，利用自定义分组名引用相应的分组。语法为：(?\d+) 或 (?”group”\d+)，这样就把 “\d+” 的组名定义为 “group” 了。如果要引用这个分组的内容，可以使用 \k 来实现。常见的分组形式如下表所示。</p><table><thead><tr><th>分类</th><th>语法</th><th>含义</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配 exp，并捕获文本到自动命名的组里</td></tr><tr><td>捕获</td><td>(?exp) or (?”name”exp)</td><td>匹配 exp，并捕获文本到名称为 name 的组里</td></tr><tr><td>捕获</td><td>(?:exp)</td><td>匹配 exp，不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配 exp 前面的位置</td></tr><tr><td>零宽断言</td><td>(?&lt;=exp)</td><td>匹配 exp 后面的位置</td></tr><tr><td>零宽断言</td><td>(?!exp)</td><td>匹配后面跟的不是 exp　位置</td></tr><tr><td>零宽断言</td><td>(?&lt;!exp)</td><td>匹配前面不是 exp 位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>提供注释</td></tr></tbody></table><h3 id="7-反义"><a href="#7-反义" class="headerlink" title="7. 反义"></a>7. 反义</h3><p>如果需求是匹配除了某一类字符集合之外的字符，这时候可以使用反义来实现。</p><table><thead><tr><th>反义</th><th>含义</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母、数字、下划线、汉子的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符和字符</td></tr><tr><td>\D</td><td>匹配任意不是非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^a]</td><td>匹配除了 a 之外的任意字符</td></tr><tr><td>[^abcde]</td><td>匹配除了 a、b、c、d、e 这几个字母之外的任意字符</td></tr><tr><td>[^(123 ｜ abc)]</td><td>匹配除了 1、2、3 或者 a、b、c 这几个字符之外的任意字符</td></tr></tbody></table><h3 id="8-贪婪与懒惰"><a href="#8-贪婪与懒惰" class="headerlink" title="8. 贪婪与懒惰"></a>8. 贪婪与懒惰</h3><p>正则表达式中包含能接受重复的限定符时，通常情况是匹配尽可能多的字符，这是贪婪模式。有时，需求不希望匹配尽可能多的字符，这时可以使用懒惰模式，就是尽可能少的匹配字符，使用 “?” 启用懒惰模式。</p><table><thead><tr><th>懒惰限定符</th><th>含义</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复 1 次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复 0 次或 1 次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复 n 到 m 次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复 n 次以上，但尽可能少重复</td></tr></tbody></table><h3 id="9-处理选项"><a href="#9-处理选项" class="headerlink" title="9. 处理选项"></a>9. 处理选项</h3><table><thead><tr><th>处理选项</th><th>含义</th></tr></thead><tbody><tr><td>忽略大小写</td><td>匹配时不区分大小写</td></tr><tr><td>多行模式</td><td>更改 “^” 和 “$” 的含义，使得它们在任意一行的行首和行尾进行匹配</td></tr><tr><td>单行模式</td><td>更改 “.” 的含义，使得它与任意字符匹配，包括换行符</td></tr><tr><td>忽略空白</td><td>忽略表达式中非转义空白并启用有 “#” 标记的注释</td></tr><tr><td>显示捕获</td><td>仅捕获已被显示命名的分组</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是由普通字符以及特殊字符（称为“元字符”）组成的文字模式，可以作为模板，用来描述在搜索文本时要匹配的一个或多个字符串。&lt;/p&gt;
&lt;h3 id=&quot;1-常见元字符&quot;&gt;&lt;a href=&quot;#1-常见元字符&quot; class=&quot;headerlink&quot; title=&quot;1. 常见元
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Python实现HTTP请求</title>
    <link href="http://yoursite.com/2018/08/06/Python%E5%AE%9E%E7%8E%B0HTTP%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2018/08/06/Python实现HTTP请求/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2019-01-09T11:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>python　中实现 HTTP 请求有三种方式，分别为 urllib2/urllib、httplib/urllib 和 Requests。</p><h3 id="1-urllib2-urllib"><a href="#1-urllib2-urllib" class="headerlink" title="1. urllib2/urllib"></a>1. urllib2/urllib</h3><h4 id="1-1-基本请求和响应模型"><a href="#1-1-基本请求和响应模型" class="headerlink" title="1.1 基本请求和响应模型"></a>1.1 基本请求和响应模型</h4><p>urllib2 和 urllib 是 Python 中的两个内置模块，实现 HTTP 请求时，以 urllib2 为主，urllib　为辅。urllib2 模块提供了 urliopen() 方法，可以向指定的 URL 发出请求来获取数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求</span></span><br><span class="line">request = urllib2.Request(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> response.read()</span><br></pre></td></tr></table></figure><h4 id="1-2-请求头-headers-处理"><a href="#1-2-请求头-headers-处理" class="headerlink" title="1.2 请求头 headers 处理"></a>1.2 请求头 headers 处理</h4><p>请求头信息可以直接与 URL 一起放到 Requset() 方法里，也可以使用 add_header() 方法添加请求头信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://github.com/login"</span></span><br><span class="line">userAgent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span></span><br><span class="line">referer = <span class="string">'https://github.com'</span></span><br><span class="line">postData = &#123;<span class="string">'username'</span>: <span class="string">'111'</span>, <span class="string">'passowrd'</span>: <span class="string">'222'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 userAgent, referer 写入头信息</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: userAgent, <span class="string">'Referer'</span>: referer&#125;</span><br><span class="line"></span><br><span class="line">data = urllib.urlencode(postData)</span><br><span class="line">request = urllib2.Request(url, data, headers)</span><br><span class="line"><span class="comment"># request.add_header('User-Agent', userAgent)</span></span><br><span class="line"><span class="comment"># request.add_header('Referer', referer)</span></span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line"><span class="keyword">print</span> response.read()</span><br></pre></td></tr></table></figure><h4 id="1-3-Cookie-处理"><a href="#1-3-Cookie-处理" class="headerlink" title="1.3 Cookie 处理"></a>1.3 Cookie 处理</h4><p>urllib2 对 Cookie 的处理是自动的，使用 CookieJar 函数进行 Cookie 的管理。我们也可以通过设置请求头中的 Cookie 域来自定义添加 Cookie 的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line">cookie = cookielib.CookieJar()</span><br><span class="line">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    <span class="keyword">print</span> item.name + <span class="string">':'</span> + item.value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line">cookie = cookielib.CookieJar()</span><br><span class="line">opener = urllib2.build_opener()</span><br><span class="line">opener.addheaders.append((<span class="string">'cookie'</span>, <span class="string">'email='</span>+<span class="string">"xxx@163.com"</span>))</span><br><span class="line">request = urllib2.Request(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">response = opener.open(request)</span><br><span class="line"><span class="keyword">print</span> response.headers</span><br><span class="line"><span class="keyword">print</span> response.read()</span><br></pre></td></tr></table></figure><h4 id="1-4-设置超时处理的三种方法"><a href="#1-4-设置超时处理的三种方法" class="headerlink" title="1.4 设置超时处理的三种方法"></a>1.4 设置超时处理的三种方法</h4><p>在 python2.6 之前的版本，urllib2 的 API 并没有 Timeout 的设置，要设置 Timeout 值，只能通过设置 Socket 的全局 Timeout 值实现。而在 python2.6 及新的版本中，urlopen() 函数提供了对 Timeout 的设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># way 1</span></span><br><span class="line">socket.setdefaulttimeout(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># way 2</span></span><br><span class="line">urllib2.socket.setdefaulttimeout(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># way 3</span></span><br><span class="line">request = urllib2.Request(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">response = urllib2.urlopen(request, timeout=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> response.read()</span><br></pre></td></tr></table></figure><h4 id="1-5-获取-HTTP-响应码"><a href="#1-5-获取-HTTP-响应码" class="headerlink" title="1.5 获取 HTTP 响应码"></a>1.5 获取 HTTP 响应码</h4><p>对于 200 OK 来说，urlopen() 方法返回的 response 对象的 getcode() 方法可以得到该 HTTP 响应码，但是对于其他类型的响应码，urlopen() 方法会抛出异常，这样需要通过异常对象来获取响应码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">print</span> response.getcode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib2.urlopen(<span class="string">'http://www.google.com'</span>, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">print</span> response</span><br><span class="line"><span class="keyword">except</span> urllib2.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Error code:'</span>, e.code</span><br></pre></td></tr></table></figure><h4 id="1-6-重定向"><a href="#1-6-重定向" class="headerlink" title="1.6 重定向"></a>1.6 重定向</h4><p>urllib2 默认情况下会针对 HTTP 3XX 返回码自动进行重定向动作。要检测是否发生了重定向动作，只要检查一些 Response 的 URL 和 Resquest 的 URL 是否一致就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">response = urllib2.urlopen(<span class="string">'http://www.zhihu.com'</span>)</span><br><span class="line">isRedirected = response.geturl() == <span class="string">'http://www.zhihu.com'</span></span><br><span class="line"><span class="keyword">print</span> isRedirected</span><br></pre></td></tr></table></figure><p>如果不想自动重定向，可以自定义 HTTPRedirectHandler 类实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedirectHandler</span><span class="params">(urllib2.HTTPRedirectHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">http_error_301</span><span class="params">(self, req, fp, code, msg, headers)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">http_error_302</span><span class="params">(self, req, fp, code, msg, headers)</span>:</span></span><br><span class="line">        result = urllib2.HTTPRedirectHandler.http_error_301(self, req, fp, code, msg, headers)</span><br><span class="line">        result.status = code</span><br><span class="line">        result.newurl = result.geturl()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opener = urllib2.build_opener(RedirectHandler)</span><br><span class="line">opener.open(<span class="string">'http://www.zhihu.com'</span>)</span><br></pre></td></tr></table></figure><h4 id="1-7-Proxy-代理"><a href="#1-7-Proxy-代理" class="headerlink" title="1.7 Proxy 代理"></a>1.7 Proxy 代理</h4><p>urllib2 默认使用环境变量 http_proxy 来设置 HTTP Proxy；也可以使用 ProxyHandler 在程序中动态设置代理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">proxy = urllib2.ProxyHandler(&#123;<span class="string">'http'</span>: <span class="string">'127.0.0.1:8087'</span>&#125;)</span><br><span class="line">opener = urllib2.build_opener([proxy, ])</span><br><span class="line">urllib2.install_opener(opener)</span><br><span class="line">response = urllib2.urlopen(<span class="string">'http://www.zhihu.com'</span>)</span><br><span class="line"><span class="keyword">print</span> response.read()</span><br></pre></td></tr></table></figure><p>使用 urllib2.install_opener() 方法会全局设置代理，不利于更细粒度的控制，可以使用 opener.open() 代替全局的 urlopen()　方法使用不同的代理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">proxy = urllib2.ProxyHandler(&#123;<span class="string">'http'</span>: <span class="string">'127.0.0.1:8087'</span>&#125;)</span><br><span class="line">opener = urllib2.build_opener(proxy, )</span><br><span class="line">response = opener.open(<span class="string">'http://www.zhihu.com'</span>)</span><br><span class="line"><span class="keyword">print</span> response.read()</span><br></pre></td></tr></table></figure><h3 id="2-httplib-urllib"><a href="#2-httplib-urllib" class="headerlink" title="2. httplib/urllib"></a>2. httplib/urllib</h3><p>httplib 模块是一个底层基础模块，可以了解建立 HTTP 请求的每一步，正常情况下开发用的很少。</p><table><thead><tr><th>功能</th><th>API</th></tr></thead><tbody><tr><td>创建 HTTPConnection 对象</td><td>httplib.HTTPConnection(host[.port,[strict[,timeout[,source_address]]]])</td></tr><tr><td>发送请求</td><td>HTTPConnection.request(method,url[,body[,headers]])</td></tr><tr><td>获得响应</td><td>HTTPConnection.getresponse()</td></tr><tr><td>读取响应信息</td><td>HTTPResponse.read()</td></tr><tr><td>获取指定请求头信息</td><td>HTTPResponse.getheader(name[,default])</td></tr><tr><td>获取响应头，以 (header, value) 元组构成的列表返回</td><td>HTTPResponse.getheaders()</td></tr><tr><td>获取底层 socket 文件描述符</td><td>HTTPResponse.fileno()</td></tr><tr><td>获取头内容</td><td>HTTPResponse.msg</td></tr><tr><td>获取头 http 版本</td><td>HTTPResponse.version</td></tr><tr><td>获取返回状态码</td><td>HTTPResponse.status</td></tr><tr><td>获取返回说明</td><td>HTTPResponse.reason</td></tr></tbody></table><h3 id="3-Requests"><a href="#3-Requests" class="headerlink" title="3. Requests"></a>3. Requests</h3><h4 id="3-1-Requests-安装"><a href="#3-1-Requests-安装" class="headerlink" title="3.1 Requests 安装"></a>3.1 Requests 安装</h4><p>Python 中 Requests 模块实现 HTTP　请求的方式非常简单，操作更加人性化。Requests 库是第三方模块，需要额外安装，其源码开源，位于 <a href="https://github.com/requests/requests" target="_blank" rel="noopener">Github</a> 上。安装 requests 方式有两种：</p><blockquote><ol><li>直接在 Terminal 上输入命令 pip install requests</li><li>下载 <a href="https://github.com/requests/requests/releases" target="_blank" rel="noopener">requests 源码</a>，然后解压，在 Terminal 中进入解压后的目录，运行 setup.py 文件即可。</li></ol></blockquote><h4 id="3-2-基本请求和响应模型"><a href="#3-2-基本请求和响应模型" class="headerlink" title="3.2 基本请求和响应模型"></a>3.2 基本请求和响应模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># get 请求</span></span><br><span class="line">req = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(req.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># post 请求</span></span><br><span class="line">postData = &#123;<span class="string">'key'</span>: <span class="string">'value'</span>&#125;</span><br><span class="line">req = requests.post(<span class="string">'http://www.xxx.com/login'</span>, postData)</span><br><span class="line">print(req.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://zzk.cnblogs.com/s/blogpost?Keywords=blog:qiyeboy&amp;pageindex=1</span></span><br><span class="line"><span class="comment"># 处理 ? 后面的参数</span></span><br><span class="line">payload = &#123;<span class="string">'Keywords'</span>: <span class="string">'blog:qiyeboy'</span>, <span class="string">'pageindex'</span>: <span class="number">1</span>&#125;</span><br><span class="line">req = requests.get(<span class="string">'https://zzk.cnblogs.com/s/blogpost'</span>, params=payload)</span><br><span class="line">print(req.url)</span><br></pre></td></tr></table></figure><h4 id="3-3-响应码-code-和请求头-headers-处理"><a href="#3-3-响应码-code-和请求头-headers-处理" class="headerlink" title="3.3 响应码 code 和请求头 headers 处理"></a>3.3 响应码 code 和请求头 headers 处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">req = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">if</span> req.status_code == requests.codes.ok:</span><br><span class="line">    print(req.status_code)   <span class="comment"># 响应码</span></span><br><span class="line">    print(req.headers)   <span class="comment"># 响应头</span></span><br><span class="line">    print(req.headers.get(<span class="string">'content-type'</span>))</span><br><span class="line">    print(req.headers[<span class="string">'content-type'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    req.raise_for_status()</span><br></pre></td></tr></table></figure><h4 id="3-4-Cookie-处理"><a href="#3-4-Cookie-处理" class="headerlink" title="3.4 Cookie 处理"></a>3.4 Cookie 处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">userAgent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: userAgent&#125;</span><br><span class="line">req = requests.get(<span class="string">'http://www.baidu.com'</span>, headers=headers)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> req.cookies.keys():</span><br><span class="line">    print(cookie + <span class="string">':'</span> + req.cookies.get(cookie))</span><br><span class="line"></span><br><span class="line">userAgent = <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: userAgent&#125;</span><br><span class="line">cookies = dict(name=<span class="string">'qiye'</span>, age=<span class="string">'10'</span>)</span><br><span class="line"><span class="comment"># 发送 cookie</span></span><br><span class="line">req = requests.get(<span class="string">'http://www.baidu.com'</span>, headers=headers, cookies=cookies)</span><br><span class="line"></span><br><span class="line">loginUrl = <span class="string">'http://www.xxx.com/login'</span></span><br><span class="line">s = requests.session()</span><br><span class="line"><span class="comment"># 首先访问登录页面，作为游客，服务器会先分配一个 cookie</span></span><br><span class="line">req = s.get(loginUrl, allow_redirects=<span class="keyword">True</span>)</span><br><span class="line">datas = &#123;<span class="string">'name'</span>: <span class="string">'qiye'</span>, <span class="string">'passwd'</span>: <span class="string">'qiye'</span>&#125;</span><br><span class="line"><span class="comment"># 向登录链接发送 post 请求，验证成功，游客权限转为会员权限</span></span><br><span class="line">req = s.post(loginUrl, data=datas, allow_redirects=<span class="keyword">True</span>)</span><br><span class="line">print(req.text)</span><br></pre></td></tr></table></figure><h4 id="3-5-重定向与历史信息"><a href="#3-5-重定向与历史信息" class="headerlink" title="3.5 重定向与历史信息"></a>3.5 重定向与历史信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># allow_redirects=True 允许重定向，默认允许</span></span><br><span class="line"><span class="comment"># requests.get('', allow_redirects=True)</span></span><br><span class="line">req = requests.get(<span class="string">'http://github.com'</span>)</span><br><span class="line">print(req.url)</span><br><span class="line">print(req.status_code)</span><br><span class="line">print(req.history)</span><br></pre></td></tr></table></figure><h4 id="3-6-超时设置"><a href="#3-6-超时设置" class="headerlink" title="3.6 超时设置"></a>3.6 超时设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">print(requests.get(<span class="string">'http://www.google.com'</span>, timeout=<span class="number">5</span>).content)</span><br></pre></td></tr></table></figure><h4 id="3-7-代理设置"><a href="#3-7-代理设置" class="headerlink" title="3.7 代理设置"></a>3.7 代理设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://0.10.1.10:3128"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">'http://example.org'</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python　中实现 HTTP 请求有三种方式，分别为 urllib2/urllib、httplib/urllib 和 Requests。&lt;/p&gt;
&lt;h3 id=&quot;1-urllib2-urllib&quot;&gt;&lt;a href=&quot;#1-urllib2-urllib&quot; class=&quot;he
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="request" scheme="http://yoursite.com/tags/request/"/>
    
      <category term="response" scheme="http://yoursite.com/tags/response/"/>
    
  </entry>
  
  <entry>
    <title>学一点XPath</title>
    <link href="http://yoursite.com/2018/08/05/%E5%AD%A6%E4%B8%80%E7%82%B9XPath/"/>
    <id>http://yoursite.com/2018/08/05/学一点XPath/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2019-01-09T11:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>XPath 是一门在 XML 文档中查找信息的语言，用于在 XML 文档中通过元素和属性进行导航。XPath 虽然被设计用来搜索 XML 文档，不过它也能很好地在 HTML 文档中工作，大部分浏览器都支持通过 XPath 来查询节点。XPath 叫做 path，说明它是以路径表达式的形式来搜索元素的，这种路径表达式与我们计算机系统上的文件系统路径表达很类似。接下来，我从节点、语法、轴和运算符这四个部分来学习 XPath 在 XML 文档中的使用。</p><h3 id="1-XPath-节点"><a href="#1-XPath-节点" class="headerlink" title="1. XPath 节点"></a>1. XPath 节点</h3><p>在 XPath 中，XML 文档是被看作节点树，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释和文档（根）节点。</p><p>在 XML 文档中，XPath 表示各节点的关系有：父 (Parent)、子 (Children)、同胞 (Sibling)、先辈 (Ancestor)、后代 (Descendant)。</p><h3 id="2-XPath-语法"><a href="#2-XPath-语法" class="headerlink" title="2. XPath 语法"></a>2. XPath 语法</h3><h4 id="2-1-路径表达式"><a href="#2-1-路径表达式" class="headerlink" title="2.1 路径表达式"></a>2.1 路径表达式</h4><p>XPath 使用路径表达式来选取　XML 文档中的节点或节点集，节点是沿着路径 (path) 或者步 (steps) 来选取的。路径表达式语法规则如下表所示。</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>选择任意位置的某个节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><p>路径表达式中绝对路径、相对路径和步的概念如下所示。</p><blockquote><ol><li>绝对路径起始于正斜杠 (/)。</li><li>相对路径可以起始于任何节点。</li><li>步包括轴、节点测试、零个或多个谓语，用来更深入地选取节点集，语法为：轴名称::节点测试[谓语]</li></ol></blockquote><h4 id="2-2-谓语"><a href="#2-2-谓语" class="headerlink" title="2.2 谓语"></a>2.2 谓语</h4><p>路径表达式的实现效果是选取所有符合条件的节点，XPath 还能选取某个特定的节点或者包含一个特定值的节点，这里需要用到谓语，谓语语法是用中括号指定特定的节点。</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[index]</td><td>选取某节点的第 index 元素</td></tr><tr><td>[last()]</td><td>选取某节点的最后一个元素</td></tr><tr><td>[position()&lt;index]</td><td>选择某节点的前 index 个元素</td></tr><tr><td>[@name]</td><td>选取包含 name 属性的元素</td></tr><tr><td>[name&gt;iddex]</td><td>选取属性 name 值大于 index　的元素</td></tr></tbody></table><h4 id="2-3-通配符"><a href="#2-3-通配符" class="headerlink" title="2.3 通配符"></a>2.3 通配符</h4><p>XPath 在进行多节点选取时，可以使用通配符“*”匹配未知元素，使用通配符“|”一次选取多条路径。</p><h4 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4 实例"></a>2.4 实例</h4><p>下面以上述 XML 文档为例，通过 XPath 选取元素，演示 XPath 的语法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">classroom</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>10001<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>22<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>10002<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>21<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">classroom</span>&gt;</span></span><br></pre></td></tr></table></figure><p>| 实现效果 | 路径表达式 |<br>| 选取 classroom 元素所有子节点 | classroom |<br>| 选取根元素 classroom | /classroom |<br>| 选取元素 classroom 的子元素的所有 student 元素 |    classroom/student |<br>| 选取元素 student |    //student |<br>| 选取元素 classroom 的后代 student 元素 |    classroom//studetn |<br>| 选取名为 zh-CN 所有属性 | //@lang |<br>| 选取元素 classroom 的第 1 个 student 子元素 | classroom/student[1] |<br>| 选取元素 name，且有值为　zh-CN 的 lang 属性 | //name[@lang=’zh-CN’] |<br>| 选取元素 classroom 的所有子元素     | classroom/<em> |<br>| 选取文档中所有元素 | //</em> |<br>| 选取所有带有属性的 name 元素 | //name[@*] |<br>| 选取元素 student 的所有 name 元素和 age 元素 | //student/name ｜ //student/age |</p><h3 id="3-XPath-轴"><a href="#3-XPath-轴" class="headerlink" title="3. XPath 轴"></a>3. XPath 轴</h3><p>轴定义了所选节点与当前节点之间的树关系，XPath 中使用到的节点集如下表所示。</p><table><thead><tr><th>轴</th><th>含义</th></tr></thead><tbody><tr><td>child</td><td>选取当前节点的所有子元素</td></tr><tr><td>parent</td><td>选取当前节点的父节点</td></tr><tr><td>ancestor</td><td>选取当前节点的所有先辈节点</td></tr><tr><td>ancestor-or-self</td><td>选取当前节点的所有先辈节点以及当前节点本身</td></tr><tr><td>descendant</td><td>选取当前节点的所有后代元素</td></tr><tr><td>descendant-or-self</td><td>选取当前节点的所有后代元素以及当前节点本身</td></tr><tr><td>preceding</td><td>选取文档中当前节点的开始标记之前的所有节点</td></tr><tr><td>following</td><td>选取文档中当前节点的结束标记之后的所有节点</td></tr><tr><td>preceding-sibling</td><td>选取当前节点之前的所有同级节点</td></tr><tr><td>following-sibling</td><td>选取当前节点之后的所有同级节点</td></tr><tr><td>self</td><td>选取当前节点</td></tr><tr><td>attribute</td><td>选取当前节点的所有属性</td></tr><tr><td>namespace</td><td>选取当前节点的所有命名空间节点</td></tr></tbody></table><h3 id="4-XPath-运算符"><a href="#4-XPath-运算符" class="headerlink" title="4. XPath 运算符"></a>4. XPath 运算符</h3><p>XPath 表达式可以返回节点集、字符串、逻辑值和数字，表达式中可以使用运算符进行连接，运算符如下表所示。</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>｜</td><td>计算两个节点集</td></tr><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>div</td><td>除法</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>or</td><td>或</td></tr><tr><td>and</td><td>与</td></tr><tr><td>mod</td><td>取余</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XPath 是一门在 XML 文档中查找信息的语言，用于在 XML 文档中通过元素和属性进行导航。XPath 虽然被设计用来搜索 XML 文档，不过它也能很好地在 HTML 文档中工作，大部分浏览器都支持通过 XPath 来查询节点。XPath 叫做 path，说明它是以路
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="XPath" scheme="http://yoursite.com/tags/XPath/"/>
    
      <category term="节点" scheme="http://yoursite.com/tags/%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://yoursite.com/2018/08/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/04/网络编程/</id>
    <published>2018-08-03T16:00:00.000Z</published>
    <updated>2019-01-09T11:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>提及网络编程，就不得不提　Socket(套接字) 概念。Socket 是网络编程中的一个抽象概念，通常我们用一个 Socket 表示“打开一个网络链接”，把打开链接的目标计算机的 IP 地址和端口号，以及协议类型等信息存储到 Socket 里。</p><p>python 进行网络编程时，实际上是　python 程序本身的进程连接到服务器进程的通信端口进行通信，可以看作是两个进程间的通信。python 提供了两个基本的　Socket 模块实现网络编程，分别为 Socket 和 SocketServer。</p><blockquote><ol><li>Socket 提供了标准的 BSD Sockets API。</li><li>SocketServer 提供了服务器中心类，可以简化网络服务器的开发。</li></ol></blockquote><h4 id="1-1-Socket-类型"><a href="#1-1-Socket-类型" class="headerlink" title="1.1 Socket 类型"></a>1.1 Socket 类型</h4><p>Socket 格式为：socket(family, type[,protocal])，需要给定地址族、套接字类型、协议编号来创建　Socket。</p><table><thead><tr><th>Socket类型</th><th>描述</th></tr></thead><tbody><tr><td>socket.AF_UNIX</td><td>只能用于单一的 Unix 系统进程间通信</td></tr><tr><td>socket.AF_INET</td><td>服务器之间网络通信</td></tr><tr><td>socket.AF_INET6</td><td>服务器之间 IPv6 网络通信</td></tr><tr><td>socket.SOCK_STREAM</td><td>流式 socket，用于 TCP</td></tr><tr><td>socket.SOCK_DGAM</td><td>数据报式 socket，用于 UDP</td></tr><tr><td>socket.SOCK_RAM</td><td>原始套接字，普通的套接字无法处理 ICMP、IGMP　等网络报文，而 SOCK_RAM 可以；其次，SOCK_RAM 也可以处理特殊的 IPv4 报文；此外，利用原始套接字，可以通过 IP_HDRINCL 套接字选项由用户构造 IP 头</td></tr><tr><td>socket.SOCK_SEQPACKET</td><td>可靠的连续数据报服务</td></tr><tr><td>创建 TCP Socket</td><td>socket(socket.AF_INET, socket.SOCK_STREAM)</td></tr><tr><td>创建 UDP Socket</td><td>socket(socket.AF_INET, socket.SOCK_DGRAM)</td></tr></tbody></table><h4 id="1-2-Socket-函数"><a href="#1-2-Socket-函数" class="headerlink" title="1.2 Socket 函数"></a>1.2 Socket 函数</h4><p>服务器 Socket 函数：</p><table><thead><tr><th>Socket 函数</th><th>描述</th></tr></thead><tbody><tr><td>s.bind(address)</td><td>将套接字绑定到地址，在 AF_INET 下，以元祖 (host, port) 的形式表示地址</td></tr><tr><td>s.listen(backlog)</td><td>开始监听 TCP 传入连接。backlog 指定在拒绝连接之前，操作系统可以挂起的最大的连接数量。该值最小为１，大部分情况设为５就可以了</td></tr><tr><td>s.accept()</td><td>接受 TCP 连接并返回 (conn, address) ，其中 conn 是新的套接字对象，可以用来接收和发送数据；address 是连接客户端的地址</td></tr></tbody></table><p>　<br>客户端 Socket 函数：</p><table><thead><tr><th>Socket 函数</th><th>描述</th></tr></thead><tbody><tr><td>s.connect(address)</td><td>连接到 address 处的套接字。一般 address 的格式为元祖 (host, port) ，如果连接出错，返回 socket.error 错误</td></tr><tr><td>s.connect_ex(address)</td><td>功能与 connect(address) 相同，但是连接成功返回 0，连接失败返回 errno 的值</td></tr></tbody></table><p>公共 Socket 函数：</p><table><thead><tr><th>Socket 函数</th><th>描述</th></tr></thead><tbody><tr><td>s.recv(bufsize[,flag])</td><td>接收 TCP 套接字数据，数据以字符串形式返回</td></tr><tr><td>s.send(string[,flag])</td><td>发送 TCP 套接字数据，返回发送数据的字节数</td></tr><tr><td>s.sendall(string[,flag])</td><td>完整发送 TCP 套接字数据，成功返回 None，失败抛出异常</td></tr><tr><td>s.recvfrom(bufsize[,flag])</td><td>接收 UDP 套接字数据，返回 (data, address)</td></tr><tr><td>s.sendto(string[,flag],address)</td><td>发送 UDP 套接字数据，返回发送数据的字节数</td></tr></tbody></table><p>还有一些公共 Socket 函数，如：s.close()，s.getpeername()，s.getsockname()，s.setsockopt(level, optname, value)，s.getsockopt(level, optname[,buflen])，s.settimeout(timeout)，s.setblocking(flag)　等，这些函数一般可以见名知意，且使用频率较低，如果需要了解，都可以查询 API 获得。</p><h3 id="2-TCP-编程"><a href="#2-TCP-编程" class="headerlink" title="2. TCP 编程"></a>2. TCP 编程</h3><p>TCP 是一种面向连接的通信方式，连接可靠，通信双方以流的形式发送数据。主动发起连接的是客户端，被动响应的是服务端。服务端程序编写步骤如下。</p><blockquote><ol><li>创建　Socket，绑定 Socket 到本地 IP 与端口。</li><li>开始监听连接。</li><li>进入循环，不断连接客户端的连接请求。</li><li>接收传来的数据，并发送给对方数据（一般为确认收到）。</li><li>传输完毕后，关闭 Socket。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket, threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dealClient</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    <span class="comment"># 第四步： 接收传来的数据，并发送给对方数据</span></span><br><span class="line">    print(<span class="string">'Accept new connection from %s:%s'</span> % addr)</span><br><span class="line">    sock.send(<span class="string">b'Hello,I am server!'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">'utf-8'</span>) == <span class="string">'exit'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'--- &gt; %s !'</span> % data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">        sock.send((<span class="string">'Loop_msg: %s!'</span> % data.decode(<span class="string">'utf-8'</span>)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第五步： 关闭 Socket</span></span><br><span class="line">    sock.close()</span><br><span class="line">    print(<span class="string">'Connection from %s:%s'</span> % addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 第一步： 创建一个基于 IPV4 和 TCP 协议的 Socket</span></span><br><span class="line">    <span class="comment"># Socket 绑定的 IP(127.0.0.1 为本机 IP)与端口</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步： 监听链接</span></span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'waiting for connection ...'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 第三步： 接收一个新连接</span></span><br><span class="line">        sock, addr = s.accept()</span><br><span class="line">        t = threading.Thread(target=dealClient, args=(sock, addr))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>接下来，需要编写客户端程序，与服务端程序检修交互。客户端程序编写步骤如下。</p><blockquote><ol><li>创建　Socket，连接服务器地址。</li><li>连接后发送数据和接收数据。</li><li>传输完毕后，关闭 Socket。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 初始化 Socket</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接目标的 IP 和端口</span></span><br><span class="line">    s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收消息</span></span><br><span class="line">    print(<span class="string">'--- &gt; '</span> + s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送消息</span></span><br><span class="line">    s.send(<span class="string">b'Hello,I am client!'</span>)</span><br><span class="line">    print(<span class="string">'--- &gt; '</span> + s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    s.send(<span class="string">b'exit'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭 Socket</span></span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-04%2013-38-59.png" alt=""></p><hr><p><img src="/images/2018/August/Screenshot%20from%202018-08-04%2013-39-31.png" alt=""></p><h3 id="3-UDP-编程"><a href="#3-UDP-编程" class="headerlink" title="3. UDP 编程"></a>3. UDP 编程</h3><p>UDP 是面向无连接的通信协议，使用 UDP 协议时，无需建立连接，只需知道对方的 IP 地址和端口号，就可以直接发送数据包，并不关心数据能否安全到达目的端。虽然 UDP 传输数据不可靠，没有建立连接的过程，但是 UDP 传输比 TCP 传输速度快，对于传输要求不严格的数据，可以采用 UDP 协议传输，从而提高速度。</p><p>UDP 服务端程序编写步骤：</p><blockquote><ol><li>创建 Socket，绑定制定的 IP 地址和端口。</li><li>直接发送数据和接收数据。</li><li>传输完毕后，关闭 Socket。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建 Socket ，绑定指定的 IP 和端口</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    s.bind((<span class="string">'127.0.0.2'</span>, <span class="number">9999</span>))</span><br><span class="line">    print(<span class="string">'Bind UDP on 127.0.0.2:9999 ...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 直接发送数据和接收数据</span></span><br><span class="line">        data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">'Received from %s:%s.'</span> % addr)</span><br><span class="line">        s.sendto(<span class="string">b'Hello, %s!'</span> % data, addr)</span><br></pre></td></tr></table></figure><p>UDP 客户端程序编写步骤：</p><blockquote><ol><li>创建 Socket。</li><li>直接可以与服务端程序进行数据交互。</li><li>传输完毕后，关闭 Socket。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'hello'</span>, <span class="string">b'world'</span>]:</span><br><span class="line">        <span class="comment"># 发送数据</span></span><br><span class="line">        s.sendto(data, (<span class="string">'127.0.0.2'</span>, <span class="number">9999</span>))</span><br><span class="line">        <span class="comment"># 接收数据</span></span><br><span class="line">        print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-04%2013-57-52.png" alt=""></p><hr><p><img src="/images/2018/August/Screenshot%20from%202018-08-04%2013-58-00.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提及网络编程，就不得不提　Socket(套接字) 概念。Socket 是网络编程中的一个抽象概念，通常我们用一个 Socket 表示“打开一个网络链接”，把打开链接的目标计算机的 IP 地址和端口号，以及协议类型等信息存储到 Socket 里。&lt;/p&gt;
&lt;p&gt;python 
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>分布式进程</title>
    <link href="http://yoursite.com/2018/08/03/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/03/分布式进程/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2019-01-09T11:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式进程是指将 Process 进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。python 中实现分布式进程要用到 multiprocessing 模块，该模块不仅支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。</p><p>分布式进程可以用在做爬虫程序中，利用一个服务进程作为调度者，将不同任务分布到其他机器上的进程上，利用网络通信进行管理，提高爬虫程序的效率。下面举例说明分布式进程在爬虫程序中应用。</p><blockquote><p>需求：以爬取某个网站上所以图片为例</p></blockquote><blockquote><p>如果使用多进程，一般是用一个进程负责抓取图片的链接地址，将链接地址放到本地队列中(Queue)，另一个进程负责从队列中读取链接地址并进行下载和存储到本地。</p></blockquote><blockquote><p>如果使用分布式进程来完成这一需求，需要一台机器负责抓取链接，将链接地址放到队列中(Queue)，这时候需要将队列共享到网络中，便于其他机器中的进程可以访问到，其他机器上的进程负责读取链接并下载存储。分布式进程就是将这一过程进行了封装，相当于本地队列的网络化。</p></blockquote><p>要实现上述需求，可以编写服务进程，负责抓取链接地址，共享到网络队列上；编写任务进程，负责读取网络队列上的链接地址，并下载存储。</p><h4 id="1-1-服务进程编写过程："><a href="#1-1-服务进程编写过程：" class="headerlink" title="1.1 服务进程编写过程："></a>1.1 服务进程编写过程：</h4><blockquote><ol><li>建立队列　Queue，用来进行进程间的通信。服务进程创建任务队列　taskQueue，用来作为传递任务给任务进程的通道；服务进程创建结果队列　resultQueue，作为任务进程完成任务后回复服务进程的通道。在分布式多进程中，需要通过　QueueManager 获得的　Queue 接口来添加任务。</li><li>把第一步创建的队列在网络上注册，共享给其他机器上的进程，注册后获得网络队列，相当于本地队列的映像。</li><li>建立一个对象　(QueueManager(BaseManager))　实例 manager，绑定端口和验证口令。然后，启动该实例，监管信息通道。</li><li>通过管理实例的方法获得网络访问的　Queue 对象，即把网络队列实体化可以使用的本地队列。</li><li>创建任务到本地队列中，自动上传任务到网络队列中，分配给任务进程进行处理。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random, time, Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步： 建立 taskQueue 和 resultQueue ，用了存放任务和结果</span></span><br><span class="line">taskQueue = Queue.Queue()</span><br><span class="line">resultQueue = Queue.Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 第二步： 把创建的两个队列注册在网络上，利用 register 方法，callable 参数关联了 Queue 对象</span></span><br><span class="line">    <span class="comment"># 将 Queue 对象在网络上暴露</span></span><br><span class="line">    QueueManager.register(<span class="string">'getTaskQueue'</span>, callable=<span class="keyword">lambda</span>:taskQueue)</span><br><span class="line">    QueueManager.register(<span class="string">'getResultQueue'</span>, callable=<span class="keyword">lambda</span>:resultQueue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步： 绑定端口 8001，设置验证口令'yhw-miracle'（这个相当于对象的初始化）</span></span><br><span class="line">    manager = QueueManager(address=(<span class="string">''</span>, <span class="number">8001</span>), authkey=<span class="string">'yhw-miracle'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动管理，监听信息通道</span></span><br><span class="line">    manager.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四步： 通过管理实例的方法获得通过网络访问的 Queue 对象</span></span><br><span class="line">    task = manager.getTaskQueue()</span><br><span class="line">    result = manager.getResultQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第五步： 添加任务</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> [<span class="string">'ImageUrl_'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]:</span><br><span class="line">        print(<span class="string">'put task %s ...'</span> % url)</span><br><span class="line">        task.put(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取返回的结果</span></span><br><span class="line">    print(<span class="string">'try get result ...'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">'result is %s'</span> % result.get(timeout=<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭管理</span></span><br><span class="line">    manager.shutdown()</span><br></pre></td></tr></table></figure><h4 id="1-2-任务进程编写过程："><a href="#1-2-任务进程编写过程：" class="headerlink" title="1.2 任务进程编写过程："></a>1.2 任务进程编写过程：</h4><blockquote><ol><li>使用　QueueManager 注册用于获取　Queue 的方法名称，任务进程只能通过名称来获取网络上的 Queue。</li><li>连接服务器，保持端口和验证口令与服务进程一致。</li><li>获取网络上的　Queue，进行本地化。</li><li>从 taskQueue 获取任务，并把结果写入 resultQueue。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的 QueueManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 第一步： 使用 QueueManager 注册用于获取 Queue 的方法名称</span></span><br><span class="line">    QueueManager.register(<span class="string">'getTaskQueue'</span>)</span><br><span class="line">    QueueManager.register(<span class="string">'getResultQueue'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步： 连接到服务器</span></span><br><span class="line">    serverAddr = <span class="string">'127.0.0.1'</span></span><br><span class="line">    print(<span class="string">'Connect to server %s ...'</span> % serverAddr)</span><br><span class="line">    <span class="comment"># 端口和验证口令注意保持与服务进程完全一致</span></span><br><span class="line">    m = QueueManager(address=(serverAddr, <span class="number">8001</span>), authkey=<span class="string">'yhw-miracle'</span>)</span><br><span class="line">    m.connect()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步： 获取 Queue 对象</span></span><br><span class="line">    task = m.getTaskQueue()</span><br><span class="line">    result = m.getResultQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四步： 从 task 队列获取任务，并把结果写入到 result 队列</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> task.empty()):</span><br><span class="line">        imageUrl = task.get(<span class="keyword">True</span>, timeout=<span class="number">5</span>)</span><br><span class="line">        print(<span class="string">'run task download %s ...'</span> % imageUrl)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        result.put(<span class="string">'%s ---&gt; success'</span> % imageUrl)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理结束</span></span><br><span class="line">    print(<span class="string">'worker exit.'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-03%2013-31-06.png" alt=""></p><hr><p><img src="/images/2018/August/Screenshot%20from%202018-08-03%2013-31-15.png" alt=""></p><p>小结：其实这是一个简单但真正的分布式进程，把代码稍加改造，启动多个任务进程，就可以把任务分不到多台机器上，实现大规模的分布式爬虫。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式进程是指将 Process 进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。python 中实现分布式进程要用到 multiprocessing 模块，该模块不仅支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。&lt;/p&gt;
&lt;p&gt;分布
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="分布式进程" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://yoursite.com/2018/08/02/%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/02/协程/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2019-01-09T11:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>协程(coroutine)，又称微线程，纤程，是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。</p><p>协程需要用户自己编写调度逻辑，对于 CPU 来说，协程其实是单线程，CPU 不需要考虑怎么去调度、切换上下文，这样就省去了 CPU 的切换开销，因此协程在一定程度上有好于多线程。</p><h3 id="1-python-实现协程"><a href="#1-python-实现协程" class="headerlink" title="1. python 实现协程"></a>1. python 实现协程</h3><p>第三方库　gevent 提供了比较完善的协程支持，gevent 是一个基于协程的 python 网络数据库，使用 greenlet 在　libev 事件循环顶部提供了一个有高级别并发性的　API。主要特性有以下几点。</p><blockquote><ol><li>基于　libev 的快速事件循环，Linux　上是　epoll 机制。</li><li>基于　greenlet 的轻量级执行单元。</li><li>API 复用了 python 标准库里的内容。</li><li>支持 SSL 的协作式　sockets。</li><li>可通过线程池或　c-ares 实现 DNS 查询。</li><li>通过　monkey patching 功能使得第三方模块变成协作式。</li></ol></blockquote><p>gevent 对协程的支持，本质上是　greenlet 在实现切换工作。greenlet 工作流程如下：假如进行访问网络的　IO 操作，出现阻塞，greenlet 就显式切换到另一段没有阻塞的代码段执行，直到原先的阻塞状况消失以后，再自动切换回原来的代码段继续处理。因此，greenlet 是一种合理安排的串行方式。</p><p>由于 IO 操作非常耗时，经常使程序处于等待状态，有了　greenlet 自动切换协程，保证总有　greenlet 在运行，而不是等待　IO，这就是协程一般比多线程效率高的原因。由于切换在　IO 操作时自动完成，所以　gevent 需要修改　python 自带的一些标准库，将一些常见的阻塞，如　socket、select 等地方实现协程跳转，这一过程在启动时通过　monkey patch 完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent, urllib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'visit ---&gt; %s'</span> % url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(url)</span><br><span class="line">        data = response.read()</span><br><span class="line">        print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    urls = [<span class="string">'http://github.com'</span>, <span class="string">'https://www.python.org'</span>, <span class="string">'http://yhw-miracle.win'</span>]</span><br><span class="line">    greenLets = [gevent.spawn(run_task, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    gevent.joinall(greenLets)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-02%2013-12-37.png" alt=""></p><p>以上程序主要使用　gevent 中的　spawn 方法和　joinall 方法。spawn 方法是用来形成协程，joinall 方法是添加这些协程任务，并且启动运行。从结果可以看出，3 个网络操作是并发执行的，运行结束顺序不同，但其实只有一个线程。</p><h3 id="2-协程中池的实现"><a href="#2-协程中池的实现" class="headerlink" title="2. 协程中池的实现"></a>2. 协程中池的实现</h3><p>gevent 中还提供了对池的支持。当拥有动态数量的 gevent 需要进行并发管理时，如限制并发数，可以使用池来实现，这在处理大量的网络和　IO 操作时是非常需要的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'visit ---&gt; %s'</span> % url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'%d bytes received from %s.'</span> % (len(urllib2.urlopen(url).read()), url))</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line">    urls = [<span class="string">'http://github.com'</span>, <span class="string">'https://www.python.org'</span>, <span class="string">'http://yhw-miracle.win'</span>]</span><br><span class="line">    pool.map(run_task, urls)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-02%2013-27-30.png" alt=""></p><p>运行结果可看出，Pool 对象实现了对协程的并发数量管理，代码中规定协程中的池容量为 2，因此程序是先执行前两个任务，当其中一个任务完成是，才会执行第三个任务，达到了限制并发数的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程(coroutine)，又称微线程，纤程，是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="协程" scheme="http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python之多线程</title>
    <link href="http://yoursite.com/2018/08/01/python%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/01/python之多线程/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2019-01-09T10:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>线程是进程中可以同时运行的不同程序，有时被称为轻量进程，是系统独立调度和分派的基本单位。多线程运行有很多优点：</p><blockquote><ol><li>可以把运行时间长的任务放到后台去处理。</li><li>程序的运行速度可能会加快。</li><li>用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li><li>在一些需要等待的任务实现上，比如用户输入、文件读写好人网络收发数据等，线程就可以释放一些珍贵的系统资源，避免内存占用。</li></ol></blockquote><h3 id="1-Python-中线程实现"><a href="#1-Python-中线程实现" class="headerlink" title="1. Python 中线程实现"></a>1. Python 中线程实现</h3><p>python 中提供了两个模块：thread 和 threading 实现多进程，thread 是低级模块，threading 是高级模块，是对 thread 的封装。在绝大数情况下，我们只需要使用 threading 这个高级模块就能实现多线程。</p><p>使用 threading 实现多线程有两种方法，一种是把一个函数传入并创建 Thread 实例，然后调用 start 方法开始执行；另一种是直接继承 threading.Thread 类并创建自定义线程类，然后重写 <strong>init</strong> 方法和 run 方法。下面就分别介绍这两种实现多线程的方法。</p><h4 id="1-1-创建-Thread-实例"><a href="#1-1-创建-Thread-实例" class="headerlink" title="1.1 创建 Thread 实例"></a>1.1 创建 Thread 实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, time, threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_run</span><span class="params">(urls)</span>:</span></span><br><span class="line">    print(<span class="string">'Current (%s) is running...'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        print(<span class="string">'%s ---&gt; %s'</span> % (threading.current_thread().name, url))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line">    print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'%s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=thread_run, name=<span class="string">'Thread1'</span>, args=([<span class="string">'url1'</span>, <span class="string">'url2'</span>, <span class="string">'url3'</span>],))</span><br><span class="line">    t2 = threading.Thread(target=thread_run, name=<span class="string">'Thread2'</span>, args=([<span class="string">'url4'</span>, <span class="string">'url5'</span>, <span class="string">'url6'</span>],))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-01%2012-41-20.png" alt=""></p><h4 id="1-2-创建自定义线程类"><a href="#1-2-创建自定义线程类" class="headerlink" title="1.2 创建自定义线程类"></a>1.2 创建自定义线程类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, urls)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line">        self.urls = urls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Current (%s) is running...'</span> % threading.current_thread().name)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.urls:</span><br><span class="line">            print(<span class="string">'%s ---&gt; %s'</span> % (threading.current_thread().name, url))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'%s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t1 = MyThread(name=<span class="string">'Thread1'</span>, urls=[<span class="string">'url1'</span>, <span class="string">'url2'</span>, <span class="string">'url3'</span>])</span><br><span class="line">    t2 = MyThread(name=<span class="string">'Thread2'</span>, urls=[<span class="string">'url4'</span>, <span class="string">'url5'</span>, <span class="string">'url6'</span>])</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'%s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-01%2012-44-33.png" alt=""></p><h3 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h3><p>如果多个线程共同对某个数据修改，则可能会出现不可预料的结果。为了保证数据的正确性，我们需要对多个进行同步。Python 中使用 Thread 对象的 Lock 和 RLock 对象实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于每次只允许一个线程操作的资源，可以将该资源放到 acquire 和 release 方法之间。</p><blockquote><p>对于 Lock 对象，如果一个线程连续两次进行 acquire 操作，那么由于第一次 acquire 没有 release，第二次 require 将挂起线程，这会导致 Lock 对象永远不会 release，使得线程死锁。</p></blockquote><blockquote><p>RLock 对象允许一个线程多次对其进行 acquire 操作，因为在其内部通过一个变量 counter 维护线程 acquire 的次数，而且每一次的 acquire 操作必须有一个 release 操作与之对应，在所有的 release 操作完成后，别的线程才能申请该 RLock 对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line">myLock = threading.RLock()</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            myLock.acquire()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'%s locked, number: %d'</span> % (threading.current_thread().name, num))</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">4</span>:</span><br><span class="line">                myLock.release()</span><br><span class="line">                print(<span class="string">'%s released, number: %d'</span> % (threading.current_thread().name, num))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'%s released, number: %d'</span> % (threading.current_thread().name, num))</span><br><span class="line"></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            myLock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    thread1 = MyThread(<span class="string">'Thread1'</span>)</span><br><span class="line">    thread2 = MyThread(<span class="string">'Thread2'</span>)</span><br><span class="line"></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-01%2013-03-49.png" alt=""></p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>在 python 的原始解释器中存在着 GIL(Global Interpreter Lock，全局解释器锁)，因此在解释执行 python 代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到 I/O 操作或者操作次数达到一定数目时才会释放 GIL。由于全局解释器锁的存在，在进行多线程操作时，不能调用多个 CPU 内核，只能利用一个内核，所以在进行 CPU 密集型操作的时候，不推荐使用多线程，更倾向于多进程；对于 IO 密集型操作，多线程可以明显提高效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程是进程中可以同时运行的不同程序，有时被称为轻量进程，是系统独立调度和分派的基本单位。多线程运行有很多优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;可以把运行时间长的任务放到后台去处理。&lt;/li&gt;
&lt;li&gt;程序的运行速度可能会加快。&lt;/li&gt;
&lt;li&gt;用户界
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python之进程</title>
    <link href="http://yoursite.com/2018/07/31/python%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/31/python之进程/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2019-01-09T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，另一种是使用 multiprocessing 模块。这两种方法的区别在于前者适用于 Unix/Linux 操作系统，对 Windows 系统不支持，后者则是跨平台的实现方式。</p><h3 id="1-使用-os-模块中的-fork-方法实现多进程"><a href="#1-使用-os-模块中的-fork-方法实现多进程" class="headerlink" title="1. 使用 os 模块中的 fork 方法实现多进程"></a>1. 使用 os 模块中的 fork 方法实现多进程</h3><p>python 的 os 模块封装了常见的系统调用，其中就有 fork 方法。fork 方法来自于 Unix/Linux 操作系统中提供的一个 fork 系统调用，这个方法非常特殊。普通方法都是调用一次，返回一次。而fork 方法是调用一次，返回两次，原因在操作系统将当前系统（父进程）复制出一份进程（子进程），这两个进程几乎完全相同，于是 fork 方法分别在父进程和子进程中返回。子进程中永远返回 0，父进程中返回的是子进程的 ID。具体情况，见如下代码，其中，os 模块中的 getpid 方法用于返回当前进程的 ID，getppid 方法用于获取父进程的 ID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'current Process (%s) start ...'</span> % (os.getpid())</span><br><span class="line">    pid = os.fork()</span><br><span class="line">    <span class="keyword">if</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'error in fork.'</span></span><br><span class="line">    <span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'I (%s) create a child process (%s)'</span> % (os.getpid(), pid)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'I am child process (%s) and my parent process is (%s)'</span> % (os.getpid(), os.getppid())</span><br></pre></td></tr></table></figure><p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-32-10.png" alt=""></p><h3 id="2-使用-multiprocessing-模块创建多进程"><a href="#2-使用-multiprocessing-模块创建多进程" class="headerlink" title="2. 使用 multiprocessing 模块创建多进程"></a>2. 使用 multiprocessing 模块创建多进程</h3><p>multiprocessing 模块提供了一个 Process 类来描述进程对象。创建子进程时，只需要传入一个执行函数和函数参数，即可完成一个 Process 实例的创建，用 start() 方法启动进程，用 join() 实现进程间的同步。下面，用一个例子来演示说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_process</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Child process %s (%s) Running...'</span> % (name, os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Parent process %s.'</span> % os.getpid()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=run_process, args=(str(i),))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Process will start.'</span></span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Process end.'</span></span><br></pre></td></tr></table></figure><p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-38-25.png" alt=""></p><p>进程具有并发性，共享性，独立性和异步性，以上代码中子进程输出语句说明了进程的异步性。</p><h3 id="3-multiprocessing-模块提供了-Pool-类来代表进程池对象"><a href="#3-multiprocessing-模块提供了-Pool-类来代表进程池对象" class="headerlink" title="3. multiprocessing 模块提供了 Pool 类来代表进程池对象"></a>3. multiprocessing 模块提供了 Pool 类来代表进程池对象</h3><p>以上两种创建进程的方法在启动大量子进程时，需要手动限制进程数量，显得太过繁琐，而使用进程池批量创建子进程的方式更加方便。</p><p>multiprocessing 模块提供了 Pool 类来代表进程池对象，Pool 类可以提供制定数量的进程供用户调用，默认大小是 CPU 的核数。当有新的请求提交到 Pool 中时，如果进程池还没有满，那么就会创建一个新的进程用来执行该请求；如果进程池中的进程数已经达到规定的最大值，那么该请求就好等待，直到池中有进程结束，才会创建新的进程来处理它。下面，用代码来演示进程池对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Task %s (pid = %s) is running...'</span> % (name, os.getpid())</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Task %s end.'</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'current process %s.'</span> % os.getpid()</span><br><span class="line">    p = Pool(processes=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(run_task, args=(i,))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Waiting for all subprocess done...'</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'All subprocess done.'</span></span><br></pre></td></tr></table></figure><p><img src="/images/2018/Screenshot%20from%202018-07-31%2012-56-10.png" alt=""></p><h3 id="4-进程间通信"><a href="#4-进程间通信" class="headerlink" title="4. 进程间通信"></a>4. 进程间通信</h3><p>操作系统中存在大量进程，那么进程间的通信是必不可少的。python 提供了 Queue 和 Pipe 两张方式实现进程间的通信，两张区别在于，Pipe 常用来在两个进程间通信，Queue 用来在多个进程间实现通信。</p><h4 id="4-1-Queue-实现进程通信"><a href="#4-1-Queue-实现进程通信" class="headerlink" title="4.1 Queue 实现进程通信"></a>4.1 Queue 实现进程通信</h4><p>Queue 是多进程安全的队列，可以使用 Queue 实现多进程间的数据传递，有两个方法 Put 和 Get 可以进行 Queue 操作。</p><blockquote><p>Put 方法用以插入数据到队列中，它还有两个可选数据：blocked 和 timeout。如果 blocked 为 True （默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间；如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该队列以满，会立即抛出 Queue.Full 异常。</p></blockquote><blockquote><p>Get 方法可以从队列读取并且删除一个元素。Get 方法也有两个可选参数：blocked 和 timeout。如果 blocked 为 True （默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常；如果 blocked 为 False，有两张情况：如果队列有元素可以用，则立即会返回该值；否则，如果队列为空，立即抛出 Queue.Empty 异常。</p></blockquote><p>下面用代码来演示 Queue 实现进程间通信。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_write</span><span class="params">(q, urls)</span>:</span></span><br><span class="line">    print(<span class="string">'Process (%s) is writing...'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        q.put(url)</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % url)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process (%s) is reading...'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        url = q.get(<span class="keyword">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue...'</span> % url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    process_write1 = Process(target=process_write, args=(q, [<span class="string">'url1'</span>, <span class="string">'url2'</span>, <span class="string">'url3'</span>]))</span><br><span class="line">    process_write2 = Process(target=process_write, args=(q, [<span class="string">'url4'</span>, <span class="string">'url5'</span>, <span class="string">'url6'</span>]))</span><br><span class="line">    process_reader = Process(target=process_read, args=(q,))</span><br><span class="line"></span><br><span class="line">    process_write1.start()</span><br><span class="line">    process_write2.start()</span><br><span class="line">    process_reader.start()</span><br><span class="line"></span><br><span class="line">    process_write1.join()</span><br><span class="line">    process_write2.join()</span><br><span class="line"></span><br><span class="line">    process_reader.terminate()</span><br></pre></td></tr></table></figure><p><img src="/images/2018/Screenshot%20from%202018-07-31%2013-20-31.png" alt=""></p><h4 id="4-2-Pipe-实现进程通信"><a href="#4-2-Pipe-实现进程通信" class="headerlink" title="4.2 Pipe 实现进程通信"></a>4.2 Pipe 实现进程通信</h4><p>Pipe 通常用来在两个进程间进行通信，两个进程分别位于管道的两端。Pipe 方法返回 (conn1, conn2) 代表管道的两端，该方法还有 duplex 参数，如果 duplex 参数为 True （默认值），那么这个管道是全双工模式，也就是管道两端均可以同时接收和返送数据；如果 duplex 参数为 False，conn1 只负责接收消息，conn2 只负责发送消息。</p><p>send 和 recv 方法分别是发送和接收消息的方法，如果没有消息可接收，recv 方法会一直阻塞，如果管道关闭，那么 recv 方法会抛出 EOFError。下面通过代码来演示 Pipe 实现进程通信。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing, random, os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_send</span><span class="params">(pipe, urls)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        print(<span class="string">'Process (%s) send: %s'</span> % (os.getpid(), url))</span><br><span class="line">        pipe.send(url)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_recv</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'Process (%s) recv: %s'</span> % (os.getpid(), pipe.recv()))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pipe = multiprocessing.Pipe()</span><br><span class="line">    p1 = multiprocessing.Process(target=process_send, args=(pipe[<span class="number">0</span>], [<span class="string">'url'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]))</span><br><span class="line">    p2 = multiprocessing.Process(target=process_recv, args=(pipe[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.terminate()</span><br></pre></td></tr></table></figure><p><img src="/images/2018/Screenshot%20from%202018-07-31%2013-34-23.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。为了提高程序运行的效率，python 中提供了多进程机制。 python 实现多进程的方式主要有两种，一种是使用 os 模块中的 fork 方法，
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
