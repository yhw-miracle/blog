<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>痛点就是起点</title>
  
  <subtitle>Speaking is as important as doing!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-07T04:52:16.052Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yhw-miracle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOs安装python3及配置Python虚拟环境</title>
    <link href="http://yoursite.com/2019/07/07/CentOS%E5%AE%89%E8%A3%85python3%E5%8F%8A%E9%85%8D%E7%BD%AEPython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/07/07/CentOS安装python3及配置Python虚拟环境/</id>
    <published>2019-07-07T02:48:16.000Z</published>
    <updated>2019-07-07T04:52:16.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>yhw-miracle</code>原创文章，可以随意转载，但需注明出处。</p></blockquote><p>本篇文章介绍<code>CentOS7</code>系统源码编译安装<code>Python3.6.9</code>，并配置虚拟环境，其他系统和<code>Python</code>版本可以类似参考。</p><ul><li>源码安装<code>python3.6.9</code></li></ul><ol><li>下载<code>Python 3.6.9</code>源码包；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.9/Python-3.6.9.tgz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压<code>Python-3.6.9.tgz</code>；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf Python-3.6.9.tgz</span><br></pre></td></tr></table></figure><ol start="3"><li>准备编译环境；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall <span class="string">'Development Tools'</span></span><br><span class="line">yum install zlib-devel bzip2-devel  openssl-devel ncurses-devel</span><br></pre></td></tr></table></figure><ol start="4"><li>解压完，进入文件夹，编译安装，该过程耗时较长，大约耗时<code>20</code>到<code>30</code>分钟，可以泡杯茶等待；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Python-3.6.9/</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3 --<span class="built_in">enable</span>-optimizations <span class="comment"># 据说 --enable-optimizations 配置项用于提高 Python 安装后的性能，但是会导致安装慢</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><center><img src="/images\2019\Jul/39.png" alt="success"></center><ol start="5"><li>创建<code>python3</code>和<code>pip3</code>命令；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3.6 /usr/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><ol start="6"><li>更新<code>pip3</code>；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><ul><li>配置虚拟环境</li></ul><p><strong>Q</strong>: 为啥要配置虚拟环境，直接用<code>Python</code>解析器也可以开发呀？<br><strong>A</strong>: 虚拟环境的作用可以配置多个开发环境，并且彼此不受影响，避免依赖包之间的冲突；另外，虚拟环境也便于管理开发环境，可以随意创建开发环境，方便开发。</p><ol><li>安装<code>virtualenv</code>和<code>virtualenvwrapper</code>包；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br><span class="line">pip3 install virtualenvwrapper</span><br></pre></td></tr></table></figure><ol start="2"><li>配置<code>virtualenv</code>环境变量；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /root/.basrc</span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=~/.virtualenvs <span class="comment">#指定virtualenvwrapper环境的目录</span></span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 <span class="comment">#指定virtualenvwrapper通过哪个python版本来创建虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><ol start="3"><li>创建<code>virtualenv</code>命令；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/virtualenv /usr/bin/virtualenv</span><br></pre></td></tr></table></figure><ol start="4"><li>创建虚拟环境；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv demo -p python3</span><br></pre></td></tr></table></figure><ol start="5"><li>查看虚拟环境；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon</span><br></pre></td></tr></table></figure><ol start="6"><li>进入虚拟环境；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon demo</span><br></pre></td></tr></table></figure><ol start="7"><li>退出虚拟环境；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><hr><ul><li><p>文内资源</p><ul><li><a href="https://www.python.org/ftp/python/3.6.9/Python-3.6.9.tgz" target="_blank" rel="noopener"><code>python3.6.9</code>源码包</a></li></ul></li><li><p>参考资源</p><ul><li><a href="https://mp.weixin.qq.com/s/h5eb1nVZCdY6BrsD0hnQnA" target="_blank" rel="noopener"><code>CentOS</code>系统安装<code>Python3</code></a></li><li><a href="https://www.jianshu.com/p/562ce3c2f3b8" target="_blank" rel="noopener"><code>Centos7</code>安装配置<code>python3</code>虚拟环境<code>virtualenvwrapper</code></a></li><li><a href="https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html" target="_blank" rel="noopener"><code>Pipenv</code> &amp; 虚拟环境</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为&lt;code&gt;yhw-miracle&lt;/code&gt;原创文章，可以随意转载，但需注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章介绍&lt;code&gt;CentOS7&lt;/code&gt;系统源码编译安装&lt;code&gt;Python3.6.9&lt;/cod
      
    
    </summary>
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="CentOS" scheme="http://yoursite.com/tags/CentOS/"/>
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="virtualenv" scheme="http://yoursite.com/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>搭建一台可以永久使用的编程机器</title>
    <link href="http://yoursite.com/2019/07/03/%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0%E5%8F%AF%E4%BB%A5%E6%B0%B8%E4%B9%85%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%9C%BA%E5%99%A8/"/>
    <id>http://yoursite.com/2019/07/03/搭建一台可以永久使用的编程机器/</id>
    <published>2019-07-03T04:28:02.000Z</published>
    <updated>2019-07-07T03:21:48.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>yhw-miracle</code>原创文章，可以随意转载，但需注明出处。</p></blockquote><p>在学习编程时，我们总会出现很多<code>BUG</code>，严重的话可能会导致系统崩塌，无法运行。这时候，心态好的人会选择重新安装系统，卷土重来，<strong>因为这时修复问题的成本已远远高于重装系统的成本</strong>；可是，对于恋旧且不懂安装系统的同学来说，重装系统太复杂，重来任务太巨大，修复<code>BUG</code>又无从下手。因此，学习编程的痛点就出现：我们可不可以使用一台这样的机器，遇到严重<code>BUG</code>可以随时回退；数据文件不易丢失；系统稳定，最好一次安装，永久不用重装？</p><p>在我本科学习编程时，我就常常被这个痛点所困扰，那时候，我常常因为重装系统而耗费大量时间在数据备份和项目重来的过程中。有痛点，就会催促我以此为起点寻找解决方法，庆幸的是，我找到了一种很好解决这种痛点的解决方案。</p><p>我推荐，不管是初学编程还是编程高手，不管你使用的是什么系统，<code>windows</code>、<code>linux</code>，还是<code>MAC OS</code>，你最好至少有一台安装有服务器系统，存储数据文件和编程环境的虚拟机。虚拟机的好处有：第一，可以拍摄快照，随时记录你当前的虚拟机状态，遇到严重<code>BUG</code>可以回退到问题之前的地方；第二，虚拟机软件可以跨平台运行，你只需要<strong>完整保存好安装好系统的虚拟机文件</strong>，虚拟机里存储数据文件就不会丢失，不受宿主机的影响；第三，虚拟机也是一种很好的试错方式，随时尝试，遇错回退。</p><p>虚拟机软件目前市面上有两种，<code>VIrtualBox</code>和<code>VMware</code>，这两种软件的下载链接见文末的<code>文内资源</code>。两种软件的区别是，<code>VirtualBox</code>是免费的，<code>VMware</code>是收费的，两种软件都能很好的运行虚拟机。如果非要鸡蛋里挑骨头，<code>VirtualBox</code>可能在使用体验上稍逊于<code>VMware</code>，毕竟是收费软件。</p><p>操作系统目前市面上有<code>windows</code>、<code>linux</code>和<code>MAC OS</code>，虽然目前<code>windows</code>所占市场很大，我的看法是<code>windows</code>可以用来编程，因为现在的<code>windows 10</code>已经很好了，但是我不建议用它来存储编程所产生的文件信息。<code>windows</code>是桌面系统，操作员往往很容易将注意力放在操作上，这点点，那点点，一不注意点到什么不该点的地方，可能就是系统崩溃；而服务器系统只有黑窗口，操作员只能通过命令进行交互，这就在一定程度上增加你操作的成本，保护了数据安全。虽然操作服务器系统可能会增加学习成本，但是，我相信你既然学习了编程，就肯定会很快上手的。免费的服务器系统主要是<code>linux</code>的发行版，有<code>centos</code>和<code>ubuntu</code>，使用体验都不错。</p><p>下面，将以<code>VirtualBox</code>创建虚拟机，安装<code>ubuntu-16.04.4-server-amd64</code>服务器系统为例，介绍安装全过程。</p><ul><li><p>安装<code>VirtualBox</code>，下载安装包，双击安装即可。</p></li><li><p>安装<code>ubuntu16.04</code>虚拟机，安装步骤如下。</p></li></ul><ol><li>新建虚拟机；</li></ol><p><img src="/images/2019/Jul/01.png" alt=""></p><ol start="2"><li>设置虚拟机名称，系统类型和虚拟机存储位置；</li></ol><p><img src="/images/2019/Jul/02.png" alt=""></p><ol start="3"><li>设置内存大小；</li></ol><p><img src="/images/2019/Jul/03.png" alt=""></p><ol start="4"><li>创建新的虚拟硬盘；</li></ol><p><img src="/images/2019/Jul/04.png" alt=""></p><ol start="5"><li>选择虚拟硬盘文件类型，这里选默认的<code>VDI</code>类型；</li></ol><p><img src="/images/2019/Jul/05.png" alt=""></p><ol start="6"><li>设置虚拟硬盘分配方式；</li></ol><p><img src="/images/2019/Jul/06.png" alt=""></p><ol start="7"><li>选择虚拟硬盘位置及大小，默认为第<code>2</code>步的位置；</li></ol><p><img src="/images/2019/Jul/07.png" alt=""></p><ol start="8"><li>创建完虚拟机，会显示虚拟机基本配置信息，初次点击<code>启动</code>开始安装；</li></ol><p><img src="/images/2019/Jul/08.png" alt=""></p><ol start="9"><li>选择镜像文件，启动安装；</li></ol><p><img src="/images/2019/Jul/09.png" alt=""></p><ol start="10"><li>选择语言；</li></ol><p><img src="/images/2019/Jul/10.png" alt=""></p><p>若不小心点击<code>Esc</code>，可以选择<code>Install Ubuntu Server</code>进入安装界面；</p><p><img src="/images/2019/Jul/11.png" alt=""></p><ol start="11"><li>选择安装过程中语言提示；</li></ol><p><img src="/images/2019/Jul/12.png" alt=""></p><ol start="12"><li>选择所处位置；</li></ol><p><img src="/images/2019/Jul/13.png" alt=""></p><ol start="13"><li>自动检测键盘布局信息，可以不检测，直接设置；</li></ol><p><img src="/images/2019/Jul/14.png" alt=""></p><ol start="14"><li>选择键盘信息；</li></ol><p><img src="/images/2019/Jul/15.png" alt=""></p><ol start="15"><li>选择键盘布局信息；</li></ol><p><img src="/images/2019/Jul/16.png" alt=""></p><ol start="16"><li>设置主机名；</li></ol><p><img src="/images/2019/Jul/17.png" alt=""></p><ol start="17"><li>设置登录用户全名；</li></ol><p><img src="/images/2019/Jul/18.png" alt=""></p><ol start="18"><li>设置登录用户名；</li></ol><p><img src="/images/2019/Jul/19.png" alt=""></p><ol start="19"><li>设置用户登录密码，并确认密码；</li></ol><p><img src="/images/2019/Jul/20.png" alt=""></p><p><img src="/images/2019/Jul/21.png" alt=""></p><ol start="20"><li>选择是否加密用户<code>home</code>目录；</li></ol><p><img src="/images/2019/Jul/22.png" alt=""></p><ol start="21"><li>设置时区信息；</li></ol><p><img src="/images/2019/Jul/23.png" alt=""></p><ol start="22"><li>进行磁盘分区设置，可以选择默认分区方案，一个主分区和一个交换分区。亦可以进行自定义分区；</li></ol><p><img src="/images/2019/Jul/24.png" alt=""></p><ol start="23"><li>选择可供分区的空闲硬盘；</li></ol><p><img src="/images/2019/Jul/25.png" alt=""></p><ol start="24"><li>格式化空闲磁盘，准备写入分区到空闲磁盘；</li></ol><p><img src="/images/2019/Jul/26.png" alt=""></p><ol start="25"><li>设置主分区大小；</li></ol><p><img src="/images/2019/Jul/27.png" alt=""></p><ol start="26"><li>写入分区到空闲磁盘；</li></ol><p><img src="/images/2019/Jul/28.png" alt=""></p><ol start="27"><li>开始安装系统；</li></ol><p><img src="/images/2019/Jul/29.png" alt=""></p><ol start="28"><li>设置代理，可以跳过；</li></ol><p><img src="/images/2019/Jul/30.png" alt=""></p><ol start="29"><li>配置<code>apt</code>，检索文件，这个过程可能会较长，建议喝杯茶等；</li></ol><p><img src="/images/2019/Jul/31.png" alt=""></p><ol start="30"><li>设置更新方式，笔者建议不自动更新；</li></ol><p><img src="/images/2019/Jul/32.png" alt=""></p><ol start="31"><li>选择需要安装应用软件，根据个人情况，笔者建议选择默认；</li></ol><p><img src="/images/2019/Jul/33.png" alt=""></p><ol start="32"><li>安装应用软件，这个过程需要联网，视网速快慢决定安装速度；</li></ol><p><img src="/images/2019/Jul/34.png" alt=""></p><ol start="33"><li>安装<code>grub</code>启动器；</li></ol><p><img src="/images/2019/Jul/35.png" alt=""></p><p>安装<code>grub</code>启动器到硬盘上；</p><p><img src="/images/2019/Jul/36.png" alt=""></p><ol start="34"><li>进行安装收尾工作；</li></ol><p><img src="/images/2019/Jul/37.png" alt=""></p><p><img src="/images/2019/Jul/38.png" alt=""></p><ol start="35"><li>至此，虚拟机安装完成。</li></ol><hr><ul><li><p>文内资源：</p><ul><li><a href="https://www.virtualbox.org" target="_blank" rel="noopener">VIrtualBox</a></li><li><a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">VMware</a></li><li><a href="https://download.virtualbox.org/virtualbox/6.0.8/VirtualBox-6.0.8-130520-Win.exe" target="_blank" rel="noopener">VirtualBox-6.0.8-130520-Win.exe</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为&lt;code&gt;yhw-miracle&lt;/code&gt;原创文章，可以随意转载，但需注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习编程时，我们总会出现很多&lt;code&gt;BUG&lt;/code&gt;，严重的话可能会导致系统崩塌，无法运行。这时候，心
      
    
    </summary>
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
      <category term="install" scheme="http://yoursite.com/tags/install/"/>
    
      <category term="coding" scheme="http://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2019/04/18/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/18/python基础/</id>
    <published>2019-04-18T03:10:44.000Z</published>
    <updated>2019-04-18T03:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python介绍"><a href="#python介绍" class="headerlink" title="python介绍"></a><code>python</code>介绍</h3><ol><li>解释型编程语言</li><li><code>python</code>单行注释<code>#</code></li><li><code>python</code>多行注释<code>&quot;&quot;&quot;</code>与<code>&quot;&quot;&quot;</code></li><li><code># TODO</code>说明文字</li></ol><h3 id="变量、关键字"><a href="#变量、关键字" class="headerlink" title="变量、关键字"></a>变量、关键字</h3><ol><li>变量用于描述计算机中的数据存储空间，作用是在计算机内存中保存数据。</li><li>变量名的命名规则是由数字、字母和下划线组成，不能以数字开头，不能是关键字，区分大小写。</li><li>下划线连接，驼峰命名法</li><li>关键字<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/2019/Apr/01.png" alt=""></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ol><li>数值型：<code>int</code>、<code>float</code>、<code>bool</code></li><li>非数值型：<code>str</code></li><li><code>type()</code>：获取数据类型</li></ol><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>int</td><td>整型</td></tr><tr><td>float</td><td>浮点型</td></tr><tr><td>bool</td><td>布尔型</td></tr><tr><td>str</td><td>字符串</td></tr></tbody></table><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ol><li>列表（<code>list</code>）（<code>[]</code>）是一种存储大量数据的存储模型，可以对数据进行增、删、改、查操作。</li><li><p>增加数据<br>| function | meanings |<br>| —— | —— |<br>| append(self, object) | Append object to the end of the list. |<br>| insert(self, index, object) | Insert object before index. |<br>| extend(self, iterable) | Extend list by appending elements from the iterable. |</p><ul><li>翻译：<br>(1). append(self, object): 在列表的末尾添加元素。<br>(2). insert(self, index, object): 在指定位置之前插入元素。<br>(3). extend(self, iterable): 从可迭代数据存储器中扩充到列表末尾。</li></ul></li><li><p>删除数据<br>| function | meanings |<br>| —— | —— |<br>| remove(self, object) | Remove first occurrence of value.Raises ValueError if the value is not present. |<br>| pop(self, index) | Remove and return item at index (default last).Raises IndexError if list is empty or index is out of range. |<br>| clear(self) | Remove all items from list. |</p><ul><li>翻译：<br>(1). remove(self, object): 移除列表中第一个指定数据，若指定数据不存在，抛出<code>ValueError</code>。<br>(2). pop(self, index): 移除并返回列表中指定位置的数据（默认为最后一个），若列表为空或者指定位置超过范围，抛出<code>IndexError</code>。<br>(3). clear(self): 移除列表中所有元素。</li></ul></li><li><p>修改数据和查询数据</p><ul><li>根据索引</li></ul></li><li><p>其他函数<br>| function | meanings |<br>| —— | —— |<br>| count(self, object) | Return number of occurrences of value. |<br>| index(self, object, start, stop) | Return first index of value.Raises ValueError if the value is not present. |<br>| copy(self) | Return a shallow copy of the list. |<br>| reverse(self) | Reverse <em>IN PLACE</em>. |<br>| sort(self, key, reverse) | Stable sort <em>IN PLACE</em>. |</p><ul><li>翻译<br>(1). count(self, object): 返回指定数据在列表中的个数。<br>(2). index(self, object, start, stop): 返回指定数据在列表中第一个位置，若指定数据不存在，抛出<code>ValueError</code>。<br>(3). copy(self): 返回一个列表的拷贝。<br>(4). reverse(self): 在列表上反转。<br>(4). sort(self, key, reverse): 在列表上执行稳定排序。</li></ul></li></ol><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ol><li>元组（<code>tuple</code>）（<code>()</code>）是一种存储固定数据的存储模型，元组中的数据通过<code>索引</code>修改。</li><li>元组中的数据若是<code>非引用类型数据</code>，不允许修改；若是<code>引用类型数据</code>，不允许修改对象，可以修对象的值。</li><li>元组函数<br>| function | meanings |<br>| —— | —— |<br>| count(self, x) | Return number of occurrences of value. |<br>| index(self, x, start, end) | Return first index of value.Raises ValueError if the value is not present. |<ul><li>翻译<br>(1). count(self, x): 返回元组中指定数据出现的次数。<br>(2). index(self, x, start, end): 返回指定数据在元组中出现的第一个位置，若指定数据不存在，抛出<code>ValueError</code>。</li></ul></li></ol><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ol><li>集合（<code>set</code>）（<code>{,,...}</code>）是一种存储无序不重复数据的存储模型，没有<code>索引</code>概念。</li><li><p>集合中的函数<br>(1). add(self, element): Add an element to a set.This has no effect if the element is already present.<br>(2). clear(self): Remove all elements from this set.<br>(3). copy(self): Return a shallow copy of a set.<br>(4). difference(self, s): Return the difference of two or more sets as a new set.(i.e. all elements that are in this set but not the others.)<br>(5). difference_update(self,  s): Remove all elements of another set from this set.<br>(6). discard(self, element): Remove an element from a set if it is a member.If the element is not a member, do nothing.<br>(7). intersection(self, s): Return the intersection of two sets as a new set.(i.e. all elements that are in both sets.)<br>(8). intersection_update(self,  s): Update a set with the intersection of itself and another.<br>(9). isdisjoint(self, s): Return True if two sets have a null intersection.<br>(10). issubset(self ,s): Report whether another set contains this set.<br>(11). issuperset(self, s): Report whether this set contains another set.<br>(12). pop(self): Remove and return an arbitrary set element.Raises KeyError if the set is empty.<br>(13). remove(self ,element): Remove an element from a set; it must be a member.If the element is not a member, raise a KeyError.<br>(14). symmetric_difference(self,  s): Return the symmetric difference of two sets as a new set.(i.e. all elements that are in exactly one of the sets.)<br>(15). symmetric_difference_update(self,  s): Update a set with the symmetric difference of itself and another.<br>(16). union(self, s): Return the union of sets as a new set.(i.e. all elements that are in either set.)<br>(17). update(self,  s): Update a set with the union of itself and others.</p><ul><li>翻译<br>(1). add(self, element): 添加一个元素到集合中，若改元素已经存在，集合将无任何影响。<br>(2). clear(self): 移除集合中所有元素。<br>(3). copy(self): 返回集合的拷贝体。<br>(4). difference(self, s): 记录该集合与其他集合之间的不同元素，组成新的集合并返回（简单来说，返回集合中的所有元素在该集合中，不在其他集合中）。<br>(5). difference_update(self,  s): 移除另一个集合中与该集合相同的元素。<br>(6). discard(self, element): 移除集合中的指定元素，若该元素不存，则不任何事。<br>(7).intersection(self, s): 记录两个集合的交集，组成新的集合并返回（简单来说，新的集合中元素是两个集合中都有的元素）。<br>(8). intersection_update(self,  s): 将该集合和另一个集合的交集更新到该集合中。<br>(9). isdisjoint(self, s): 若两个集合没有交集，返回<code>True</code>。<br>(10). issubset(self ,s): 报告另一个集合是否包含该集合，若包含，返回<code>True</code>；若不包含，返回<code>False</code>。<br>(11). issuperset(self, s): 报告这个集合是否包含另一个集合，若包含，返回<code>True</code>；若不包含，返回<code>False</code>。<br>(12). pop(self): 移除并返回这个该集合中随意一个元素，若集合为空，抛出<code>KeyError</code>。<br>(13). remove(self ,element): 移除集合中指定的元素，若指定元素不存在，抛出<code>KeyError</code>。<br>(14). symmetric_difference(self,  s): 记录两个集合的均匀区别，组成新的集合并返回（简单来说，新的集合中元素只存在于其中一个集合中）。<br>(15). symmetric_difference_update(self,  s): 将两个集合的均匀区别更新到该集合中。<br>(16). union(self, s): 记录两个集合之间的并集，组成新的集合并返回（简单来说，两个集合中所有元素）。<br>(17). update(self,  s): 将两个集合之间的并集更新到该集合中。</li></ul></li></ol><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ol><li>字典（dict）（{xx: xx,…}）是一种使用“键值对结构”存储数据的存储模型，没有<code>索引</code>概念，利用<code>键</code>（键是<strong>唯一</strong>的）来索引，可以根据<code>键</code>对字典数据进行增、删、改、查操作。</li><li><p>字典中的函数<br>(1). clear(self):  D.clear() -&gt; None.  Remove all items from D.<br>(2). copy(self): D.copy() -&gt; a shallow copy of D.<br>(3). fromkeys(seq): Create a new dictionary with keys from iterable and values set to value.<br>(4). get(self, k): Return the value for key if key is in the dictionary, else default.<br>(5). items(self): D.items() -&gt; a set-like object providing a view on D’s items.<br>(6). keys(self): D.keys() -&gt; a set-like object providing a view on D’s keys.<br>(7). values(self): D.values() -&gt; an object providing a view on D’s values.<br>(8). pop(self,  k): D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.If key is not found, d is returned if given, otherwise KeyError is raised.<br>(9). popitem(self): D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.<br>(10). setdefault(self, k,  default): Insert key with a value of default if key is not in the dictionary.Return the value for key if key is in the dictionary, else default.<br>(11). update(self, E=None, **F): D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F. If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]. If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v. In either case, this is followed by: for k in F:  D[k] = F[k].</p><ul><li>翻译<br>(1). clear(self): 清空字典中的所有项。<br>(2). copy(self): 返回字典的一个拷贝。<br>(3). fromkeys(seq): 用来自迭代器作为键，值集合作为值，创建新的字典。<br>(4). get(self, k): 返回指定的键对应的值。<br>(5). items(self): 获取字典中所有键值对，以列表形式返回。<br>(6). keys(self): 获取字典中所有键，以列表的形式返回。<br>(7). values(self): 获取字典中所有值，以列表的形式返回。<br>(8). pop(self,  k[, d]): 移除字典中指定的键，并返回对应的值。如果指定的键不存在，若给出<code>d</code>，则返回<code>d</code>；否则将抛出<code>KeyError</code>。<br>(9). popitem(self): 移除字典中最后一对键值对，并以二元元组的形式返回。若字典为空，抛出<code>KeyError</code>。<br>(10).setdefault(self, k,  default): 如果指定的键不在字典中，将指定的键和值（没有，默认为<code>None</code>）插入到字典中，并返回值。<br>(11). update(self, E=None, **F): 使用新字典中的数据对原始字典数据进行更新。如果字典<code>E</code>存在，有<code>keys()</code>方法，则执行代码<code>for k in E: D[k] = E[K]</code>；如果迭代器<code>E</code>存在，缺失<code>keys()</code>方法，则执行代码<code>for k, v in E: D[k] = v</code>；如果字典或迭代器<code>E</code>不存在，则执行代码<code>for k in F: D[k] = F[k]</code>。</li></ul></li><li><p>当需要存储大量数据，并且期望在编程期以最快速度获取单个数据，或者使用非对象格式保存单个对象的属性值，推荐选择字典来存储。</p></li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int()</span><br><span class="line">float()</span><br><span class="line">bool()</span><br><span class="line">str()</span><br><span class="line">tuple()</span><br><span class="line">list()</span><br><span class="line">set()</span><br><span class="line">dict()</span><br></pre></td></tr></table></figure><ol><li>int()，字符串转换为整型数据。</li><li>float()，字符串，整型数据转换为浮点型数据。 </li><li>bool()，<code>bool</code>(0)为False，<code>bool(1)</code>为True。</li><li>list(tuple | set)</li><li>tuple(list |set)</li><li>set(list | tuple)</li></ol><h4 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h4><ol><li>元组、列表、集合、字典拥有的公共方法：<code>len()</code>、<code>max()</code>、<code>min()</code>。</li><li>元组、列表和字符串可以进行<code>切片</code>获取局部数据，格式如下：<code>contain[start:end:step]</code>。</li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol><li>字符串是一个包含若干个字符并按照一定顺序排列成整体的容器，支持<code>索引</code>操作，字符串定义可以是<code>&quot;xxxx&quot;</code>,<code>&#39;xxx&#39;</code>,<code>&quot;&quot;&quot;xxx&quot;&quot;&quot;</code>,<code>&#39;&#39;&#39;xxx&#39;&#39;&#39;</code>。</li><li>字符串的一些函数<br>isalnum(self, <em>args, \</em>*kwargs): Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string.</li></ol><p>isalpha(self, <em>args, \</em>*kwargs): Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string.</p><p>isascii(self, <em>args, \</em>*kwargs): Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.</p><p>isdecimal(self, <em>args, \</em>*kwargs): Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string.</p><p>isdigit(self, <em>args, \</em>*kwargs): Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string.</p><p>isidentifier(self, <em>args, \</em>*kwargs): Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as “def” and “class”.</p><p>islower(self, <em>args, \</em>*kwargs): Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.</p><p>isnumeric(self, <em>args, \</em>*kwargs): Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string.</p><p>isprintable(self, <em>args, \</em>*kwargs): Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty.</p><p>isspace(self, <em>args, \</em>*kwargs): Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string.</p><p>istitle(self, <em>args, \</em>*kwargs): Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones.</p><p>isupper(self, <em>args, \</em>*kwargs): Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.</p><p>strip(self, <em>args, \</em>*kwargs): Return a copy of the string with leading and trailing whitespace remove. If chars is given and not None, remove characters in chars instead.</p><p>lstrip(self, <em>args, \</em>*kwargs): Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead.</p><p>rstrip(self, <em>args, \</em>*kwargs): Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead.</p><p>ljust(self, <em>args, \</em>*kwargs): Return a left-justified string of length width. Padding is done using the specified fill character (default is a space).</p><p>rjust(self, <em>args, \</em>*kwargs): Return a right-justified string of length width. Padding is done using the specified fill character (default is a space).</p><p>find(self, sub, start=None, end=None): S.find(sub[, start[, end]]) -&gt; int   Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.</p><p>rfind(self, sub, start=None, end=None): S.rfind(sub[, start[, end]]) -&gt; int   Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.</p><p>index(self, sub, start=None, end=None): S.index(sub[, start[, end]]) -&gt; int   Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.</p><p>rindex(self, sub, start=None, end=None): S.rindex(sub[, start[, end]]) -&gt; int   Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.</p><p>replace(self, <em>args, \</em>*kwargs): Return a copy with all occurrences of substring old replaced by new. count: Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced.</p><p>partition(self, <em>args, \</em>*kwargs): Partition the string into three parts using the given separator. This will search for the separator in the string.  If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings.</p><p>rpartition(self, <em>args, \</em>*kwargs): Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string.</p><p>split(self, <em>args, \</em>*kwargs): Return a list of the words in the string, using sep as the delimiter string. sep: The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit: Maximum number of splits to do. -1 (the default value) means no limit.</p><p>rsplit(self, <em>args, \</em>*kwargs): Return a list of the words in the string, using sep as the delimiter string. sep: The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit: Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front.</p><p>splitlines(self, <em>args, \</em>*kwargs): Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true.</p><p>startswith(self, prefix, start=None, end=None): S.startswith(prefix[, start[, end]]) -&gt; bool   Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try.</p><p>endswith(self, suffix, start=None, end=None): S.endswith(suffix[, start[, end]]) -&gt; bool   Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try.</p><p>format(self, <em>args, \</em>*kwargs): S.format(<em>args, \</em>*kwargs) -&gt; str   Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces (‘{‘ and ‘}’).</p><p>format_map(self, mapping): S.format_map(mapping) -&gt; str   Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces (‘{‘ and ‘}’).</p><p>lower(self, <em>args, \</em>*kwargs): Return a copy of the string converted to lowercase.</p><p>upper(self, <em>args, \</em>*kwargs): Return a copy of the string converted to uppercase.</p><p>swapcase(self, <em>args, \</em>*kwargs): Convert uppercase characters to lowercase and lowercase characters to uppercase. </p><p>title(self, <em>args, \</em>*kwargs): Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case.</p><p>capitalize(self, <em>args, 、\</em>*kwargs): Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case.</p><p>casefold(self, <em>args, \</em>*kwargs): Return a version of the string suitable for caseless comparisons.</p><p>center(self, <em>args, \</em>*kwargs): Return a centered string of length width. Padding is done using the specified fill character (default is a space).</p><p>expandtabs(self, <em>args, \</em>*kwargs): Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed.</p><p>zfill(self, <em>args, \</em>*kwargs): Pad a numeric string with zeros on the left, to fill a field of the given width.The string is never truncated.</p><p>count(self, sub, start=None, end=None): S.count(sub[, start[, end]]) -&gt; int   Return the number of non-overlapping occurrences of substring sub in string S[start:end].  Optional arguments start and end are interpreted as in slice notation.</p><p>encode(self, <em>args, \</em>*kwargs): Encode the string using the codec registered for encoding.   encoding: The encoding in which to encode the string.   errors: The error handling scheme to use for encoding errors. The default is ‘strict’ meaning that encoding errors raise a UnicodeEncodeError.  Other possible values are ‘ignore’, ‘replace’ and ‘xmlcharrefreplace’ as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.</p><p>join(self, ab=None, pq=None, rs=None): Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. <code>Example: &#39;.&#39;.join([&#39;ab&#39;, &#39;pq&#39;, &#39;rs&#39;]) -&gt; &#39;ab.pq.rs&#39;</code></p><p>maketrans(self, <em>args, \</em>*kwargs): Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.</p><p>translate(self, <em>args, \</em>*kwargs): Replace each character in the string using the given translation table.table: Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via __getitem__, for instance a dictionary or list.  If this operation raises LookupError, the character is left untouched.  Characters mapped to None are deleted.</p><ul><li>翻译</li><li><p>判断函数<br>isalnum(self, <em>args, \</em>*kwargs): 判断字符串是否字母数字。<br>isalpha(self, <em>args, \</em>*kwargs): 判断字符串是否全是字母。<br>isascii(self, <em>args, \</em>*kwargs): 判断字符串是否全是<code>ASCII</code>字符。<br>isdecimal(self, <em>args, \</em>*kwargs): 判断字符串是否全是数字。<br>isdigit(self, <em>args, \</em>*kwargs): 判断字符串是否全是数字。<br>isidentifier(self, <em>args, \</em>*kwargs): 判断字符串是否是有效的<code>python</code>标识符。<br>islower(self, <em>args, \</em>*kwargs): 判断字符串是否全是小写。<br>isnumeric(self, <em>args, \</em>*kwargs): 判断字符串是否全是数字。<br>isprintable(self, <em>args, \</em>*kwargs): 判断字符串是否是可打印的。<br>isspace(self, <em>args, \</em>*kwargs): 判断字符串是否是空白字符。<br>istitle(self, <em>args, \</em>*kwargs): 判断字符串是否是首字母大写，其他小写。<br>isupper(self, <em>args, \</em>*kwargs): 判断字符串是否全是大写。</p></li><li><p>格式转换函数<br>strip(self, <em>args, \</em>*kwargs): 返回去掉字符串左右两侧空白字符或指定字符的拷贝。<br>lstrip(self, <em>args, \</em>*kwargs): 返回去掉字符串左侧空白字符或指定字符的拷贝。<br>rstrip(self, <em>args, \</em>*kwargs): 返回去掉字符串右侧空白字符或指定字符的拷贝。</p></li></ul><p>ljust(self, <em>args, \</em>*kwargs): 返回右侧用空格或指定字符补齐指定宽度的字符串。<br>rjust(self, <em>args, \</em>*kwargs): 返回左侧用空格或指定字符补齐指定宽度的字符串。</p><p>center(self, <em>args, \</em>*kwargs): 填充字符串左右两侧几乎相等的指定字符或空格，是字符串居于中间位置，返回这样的字符串。</p><p>zfill(self, <em>args, \</em>*kwargs): 用<code>0</code>在数字字符串的左边补齐给定的宽度，字符串不会<code>truncated</code>。</p><ul><li><p>查询函数<br>find(self, sub, start=None, end=None): 返回指定字符串在原字符串中出现的最小下标。若给定<code>start</code>和<code>end</code>，则在指定范围里搜索；若指定字符串未发现，则返回<code>-1</code>。<br>rfind(self, sub, start=None, end=None): 返回指定字符串在原字符串中出现的最大下标。若给定<code>start</code>和<code>end</code>，则在指定范围里搜索；若指定字符串未发现，则返回<code>-1</code>。<br>index(self, sub, start=None, end=None): 返回指定字符串在原字符串中出现的最小下标。若给定<code>start</code>和<code>end</code>，则在指定范围里搜索；若指定字符串未发现，则抛出<code>ValueError</code>。<br>rindex(self, sub, start=None, end=None): 返回指定字符串在原字符串中出现的最大下标。若给定<code>start</code>和<code>end</code>，则在指定范围里搜索；若指定字符串未发现，则抛出<code>ValueError</code>。</p></li><li><p>划分函数<br>partition(self, <em>args, \</em>*kwargs): 从字符串左侧开始，根据指定参数将字符串划分为三部分，参数左侧、参数和参数右侧，组成三元元组并返回。如果指定参数不存在，三元元组由两个空项和自身组成。<br>rpartition(self, <em>args, \</em>*kwargs): 从字符串右侧开始，根据指定参数将字符串划分为三部分，参数左侧、参数和参数右侧，组成三元元组并返回。如果指定参数不存在，三元元组由两个空项和自身组成。</p></li></ul><p>split(self, <em>args, \</em>*kwargs): 用指定参数作为分隔符将原字符串划分为若干字符串，组成列表返回。<br>rsplit(self, <em>args, \</em>*kwargs): 用指定参数作为分隔符将原字符串从右侧开始划分为若干字符串，组成列表返回。<br>splitlines(self, <em>args, \</em>*kwargs): 用分行符作为分隔符将原字符串划分若干个字符串，组成列表返回，其中分行符不会包括在结果字符串中。</p><ul><li>替换函数<br>replace(self, <em>args, \</em>*kwargs): 使用新字符串替换原字符串中指定的字符串。</li></ul><p>expandtabs(self, <em>args, \</em>*kwargs): 返回用空格替换字符串中的制表位的拷贝。</p><ul><li>字符转换函数<br>lower(self, <em>args, \</em>*kwargs): 返回字符串中各字符转换为小写字符的拷贝。<br>upper(self, <em>args, \</em>*kwargs): 返回字符串中各个字符转换为大写的拷贝。<br>swapcase(self, <em>args, \</em>*kwargs): 将字符串的大写字符转换为小写字符，小写字符转换为大写字符。<br>title(self, <em>args, \</em>*kwargs): 返回首字母大写，其他小写的字符串。<br>capitalize(self, <em>args, 、\</em>*kwargs): 返回字符串首字母大写，其他小写。<br>casefold(self, <em>args, \</em>*kwargs): 返回字符串中所有字母转换为小写字母。</li></ul><p>startswith(self, prefix, start=None, end=None): 如果字符串以给定字符参数<code>prefix</code>开头，返回<code>True</code>；否则，返回<code>False</code>。如果给定<code>start</code>和<code>end</code>参数，则从<code>start</code>和<code>end</code>的位置进行检测。<br>endswith(self, suffix, start=None, end=None): 如果字符串以给定字符参数<code>suffix</code>结尾，返回<code>True</code>；否则，返回<code>False</code>。如果给定<code>start</code>和<code>end</code>参数，则从<code>start</code>和<code>end</code>的位置进行检测。</p><ul><li>其他函数<br>format(self, <em>args, \</em>*kwargs): 使用元组数据格式化字符串。<br>format_map(self, mapping): 使用字典类型数据格式化字符串。</li></ul><p>count(self, sub, start=None, end=None): 返回指定的字符串在原字符串中出现的次数。如果给定<code>start</code>和<code>end</code>参数，则从<code>start</code>和<code>end</code>的位置进行检测。</p><p>encode(self, <em>args, \</em>*kwargs): 使用指定的编码方式给字符串编码。</p><p>join(self, ab=None, pq=None, rs=None): 连接字符串，返回新的字符串。</p><p>maketrans(self, <em>args, \</em>*kwargs): 返回函数<code>tranlate()</code>需要的翻译表。一般是<code>maketrans(str1, str2)</code>。<br>translate(self, <em>args, \</em>*kwargs): 用给定的翻译表替换字符串中的每一个字符。一般是<code>translate(dict)</code>。</p><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ol><li>input()<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4></li><li>print()</li><li>%s，字符串占位符</li><li>%d，整数占位符</li><li>%f，浮点数占位符</li><li>%%，输入<code>%</code></li></ol><h3 id="python运算"><a href="#python运算" class="headerlink" title="python运算"></a>python运算</h3><h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><ol><li><code>+</code>：拼接</li><li><code>*</code>：连续拼接</li></ol><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><ol><li><code>+</code>，加</li><li><code>-</code>，减</li><li><code>*</code>，乘</li><li><code>/</code>，除</li><li><code>//</code>，整除</li><li><code>%</code>，取余</li><li><code>**</code>，乘方</li><li>优先级，乘方 &gt; [乘，除，整除，取余] &gt; [加，减]</li></ol><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ol><li>=，赋值</li><li>+=，加后赋值</li><li>-=，减后赋值</li><li>*=，乘后赋值</li><li>/=，除后赋值</li><li>//=，整除后赋值</li><li>%=，取余后赋值</li><li>**=，次方后赋值</li></ol><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ol><li>>，大于</li><li>>=，大于等于</li><li>&lt;，小于</li><li>&lt;=，小于等于</li><li>!=，不低于</li><li>==，等于</li><li>查看字母和数字的<code>ASCII</code>值<br>查看<code>ASCII</code>值：ord()<br>已知<code>ASCII</code>值查看对应的字符：chr()</li></ol><h4 id="关系运算符（逻辑运算符）"><a href="#关系运算符（逻辑运算符）" class="headerlink" title="关系运算符（逻辑运算符）"></a>关系运算符（逻辑运算符）</h4><ol><li>and<br>短路与，左操作数为<code>False</code>，表达式结果为<code>False</code>，与<code>左</code>操作数<code>bool</code>值相同。 </li><li>or<br>短路或，左操作数为<code>True</code>，表达式结果为<code>True</code>，与<code>左</code>操作数<code>bool</code>值相同。</li><li>not</li><li>一些例子<br>| 表达式 | 结果 |<br>| —— | —— |<br>| 1 and True | True |<br>| 0 and True | 0 |<br>| 1 or True | 1 |<br>| 0 or True | True |<br>| 1 and False | False |<br>| 0 and False | 0 |<br>| 1 or False | 1 |<br>| 0 or False  | False |</li></ol><hr><table><thead><tr><th style="text-align:left">表达式</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:left">True and 1</td><td>1</td></tr><tr><td style="text-align:left">True and 0</td><td>0</td></tr><tr><td style="text-align:left">True or 1</td><td>True</td></tr><tr><td style="text-align:left">True or 0</td><td>True</td></tr><tr><td style="text-align:left">False and 1</td><td>False</td></tr><tr><td style="text-align:left">False and 0</td><td>False</td></tr><tr><td style="text-align:left">False or 1</td><td>1</td></tr><tr><td style="text-align:left">False or 0</td><td>0</td></tr></tbody></table><h3 id="三大语句"><a href="#三大语句" class="headerlink" title="三大语句"></a>三大语句</h3><h4 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h4><p>自上而下执行语句</p><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><ol><li>if…</li><li>if…else…</li><li>if…elif…else…</li><li>分支嵌套</li></ol><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ol><li>while</li><li>for…in…</li><li>for…in…else…，循环正常结束后执行<code>else</code>部分。</li><li>while…else…</li><li>break，终止循环的执行</li><li>continue，终止本轮循环的执行</li><li>range(m, n, s): 生成 m（默认为0） 到 n-1 的整数，整数间隔为 s（默认为1）。</li><li>推导式的使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [data <span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">list1 = [data**<span class="number">2</span> <span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">list1 = [data <span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> data &gt; <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li>函数是将具有独立给你的代码块组织成为一个整体，使其具有特殊给你的代码集。函数的作用主要是加强代码的<code>复用性</code>，提高程序编写的效率。</li><li>无参函数、有参函数、带返回值的函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">([参数])</span>:</span></span><br><span class="line">函数体</span><br><span class="line">[<span class="keyword">return</span> ...]</span><br></pre></td></tr></table></figure></li></ol><p>调用格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[变量=]函数名([参数])</span><br></pre></td></tr></table></figure></p><ol start="3"><li>若函数没有返回值，使用变量接收时结果为<code>None</code></li><li>函数定义时规定的参数为<code>形参</code>，函数调用时使用的参数为<code>实参</code>，<code>形参</code>的<code>作用域</code>为函数定义开始到定义结束。</li><li>变量的<code>作用域</code>可划分为<code>局部变量</code>（整个函数内部）和<code>全局变量</code>（整个文件）。</li><li><code>局部变量</code>可添加关键字<code>global</code>提升作用域。</li><li>定义函数时，在函数名下用一对<code>&quot;&quot;&quot;</code>进行文档注释。</li><li><code>默认参数</code>是函数或方法定义时指定形参的值，位置在<code>位置形参</code>的后面，调用该函数或方法时可以不指定默认参数的值，也可以指定默认参数的值，指定多个默认参数的值需要从左到右依次赋值。</li><li><code>关键字参数</code>是在调用函数或方法时为指定名称的形参赋值所对应的实参.<code>关键字参数</code>需要在<code>位置参数</code>后面；不能对同一形参多次赋值；既可以为位置参数赋值，也可以为默认参数赋值。通常使用关键字参数是解决<code>默认参数</code>选择性赋值的问题。</li><li><code>可变参数</code>是函数或方法定义时用于接收多个实参的形参，接收的多个实参组装成元组对象，定义可变参数的格式是<code>*args</code>。可变参数只能定义一个，定义在<code>位置参数</code>的后面。<code>可变参数</code>定义在<code>位置参数</code>后面。</li><li><code>字典参数</code>是在函数或方法定义时，用于接收若干组未定义直接使用的关键字参数（调用后，会组装成字典对象），对应的形参。其定义格式是<code>**kwargs</code>。<code>字典参数</code>只能定义一个。</li><li>形参定义的顺序：先<code>位置参数</code>，再<code>可变参数</code>，后<code>默认参数</code>，再后<code>字典参数</code>。 </li><li><code>匿名函数</code>，也称<code>lambda</code>表达式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">函数名 = <span class="keyword">lambda</span> [形参] : 返回值</span><br><span class="line">结果 = 函数名([实参])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">结果 = (<span class="keyword">lambda</span> [形参] : 返回值)([实参])</span><br></pre></td></tr></table></figure></li></ol><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><ol><li><code>类</code>是一系列事物的统称，包括<code>成员变量</code>和<code>成员方法</code>，统称<code>类成员</code>。</li><li><code>类</code>的关键字是<code>class</code>，命名满足大驼峰命名法。</li><li><code>对象</code>是<code>类</code>的实例，<code>self</code>仅出现在成员方法中，指代执行该方法的对象。</li><li>类在<code>__init__(self)</code>方法中创建对象时初始化公有成员变量；<code>对象</code>可以声明<code>独有变量</code>；类可以定义属于类的<code>类变量</code>，<code>类变量</code>可以私有化。</li><li>类的方法有<code>成员方法</code>、<code>类方法</code>、<code>私有方法</code>和<code>静态方法</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bbb</span><span class="params">(self[,args])</span>:</span></span><br><span class="line"><span class="string">'''成员方法'''</span></span><br><span class="line"><span class="string">'''实例变量，实例方法，类变量，类方法均可使用'''</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ol><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>:</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bbb</span><span class="params">(cls[,args])</span>:</span></span><br><span class="line"><span class="string">'''类方法'''</span></span><br><span class="line"><span class="string">'''不能使用实例变量和实例方法'''</span></span><br><span class="line"><span class="string">'''可以使用类变量和类变量'''</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bb</span><span class="params">(self[,args])</span>:</span></span><br><span class="line"><span class="string">'''私有方法'''</span></span><br><span class="line"><span class="string">'''只能在类的内部使用'''</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>:</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bbb</span><span class="params">([args])</span>:</span></span><br><span class="line"><span class="string">'''静态方法'''</span></span><br><span class="line"><span class="string">'''一般不访问成员变量和类变量'''</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>成员方法</th><th>适用范围</th></tr></thead><tbody><tr><td><code>成员方法</code></td><td>只访问<code>成员变量</code></td></tr><tr><td><code>类方法</code></td><td>只访问<code>类变量</code></td></tr><tr><td><code>成员方法</code></td><td>既访问<code>成员变量</code>，又访问<code>类变量</code></td></tr><tr><td><code>静态方法</code></td><td>既不访问<code>成员变量</code>，又不访问<code>类变量</code></td></tr></tbody></table><ol start="6"><li><p>魔术方法</p><ul><li><code>__init__(self)</code>，创建对象时初始化公有成员变量。</li><li><code>__str__(self)</code>，打印对象时自动调用的方法。</li><li><code>__new__(cls, *args, **kwargs)</code>，创建对象时自动执行（创建对象由<code>object</code>类的<code>__new__</code>方法执行）。</li><li><code>__del__(self)</code>，<code>销毁对象</code>时自动执行。</li></ul></li><li><p><code>==</code>与<code>is</code>的区别：<code>==</code>判断的是内容，<code>is</code>判断的是地址。</p></li><li>单例设计模式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>:</span></span><br><span class="line">    <span class="comment"># 单例设计模式</span></span><br><span class="line">    __instance = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            cls.__instance = object.__new__(AAA)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br></pre></td></tr></table></figure></li></ol><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ol><li>封装是对类成员进行访问控制，保护数据不被非法访问。</li><li>一般对成员变量进行封装，需要给出访问接口。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>:</span></span><br><span class="line">self.__bbb = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bbb</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__bbb</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_bbb</span><span class="params">(self)</span>:</span></span><br><span class="line">self.__bbb = <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol><li>子类可以使用父类的成员变量、类变量、成员方法、类方法、静态方法。子类不能使用父类的私有方法。</li><li>获取继承关系的属性<code>__mro__</code>。</li><li>重写：子类重新定义与父类相同的成员方法。</li><li><p>子类中访问父类被重写的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 父类名.方法名(对象)</span><br><span class="line"><span class="number">2.</span> super(本类名, 对象).方法名()</span><br><span class="line"><span class="number">3.</span> super().方法名()</span><br></pre></td></tr></table></figure></li><li><p><code>python</code>支持<code>多继承</code>，访问父类成员时遇到<code>冲突</code>，访问继承的第一个父类的成员。</p></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol><li>父类的引用指向子类对象。不同子类调用相同的父类方法，执行结果不同。</li><li>鸭子类型，类与类之间不用共同继承一个父类，只需要将它们做得像一种事物即可。</li><li>Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849- 1916）的诗句：”When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.” </li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol><li>引用是一种变量指向数据存储空间的现象，内存地址是数据在物理内存中的存储位置，引用地址是对象在内存中的描述性地址。</li><li>相同数据在内存空间中仅占用一个存储空间。</li><li>获取内存存储地址<code>id()</code>。</li><li>使用<code>固定内存地址</code>存储数据如下：-5到256的整数、True和False、由字母、数字、下滑线组成的字符串；使用<code>临时内存地址</code>存储数据如下：小于-5后大于256的整数、所有小数、包含字母、数字、下滑线之外的字符组成的字符串。</li><li>无变量引用时，列表、集合、字典、对象保存在临时引用地址中，该引用地址可以反复使用；有变量引用时，列表、集合、字典、对象保存在独立引用地址中，该引用地址专用。</li><li>列表变量、集合变量、字典变量指向引用地址，该引用地址保存存储信息的内存地址。当存储空间不足时，会申请新的内存地址，并更新引用地址所指向的内存地址，重新申请的内存地址将复制原始内存地址中的数据。</li><li>空元组（无数据）：空元组指向统一的独立引用地址，所有空元组共用同一个引用地址。非空元组（有数据）：非空元组保存在独立引用地址中，每个元组对象具有独立引用地址，该引用地址保存存储信息的内存地址，元组创建的同时存储的数据已经固定，内存结构也固定。</li><li>元组中的数据如果是引用类型的，对应的数据可以在自身的内存地址中进行数据变更，对元组不影响。</li><li>对象中的变量是通过引用地址的形式查找真实数据。对象中的变量存储形式是一个字典的形式，对变量的操作参照字典的操作方式，变量名为字典的key，变量值为字典的value。</li><li>可变类型数据：列表、集合、字典和对象；不可变类型数据：数值、字符串、布尔和元组。</li><li>变量的引用和定义的区别。</li></ol><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">file = open(file, mode=<span class="string">'r'</span>, buffering=<span class="keyword">None</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>)</span><br><span class="line">file.close()   <span class="comment"># 文件不用后需关闭，否则会造成内存泄漏问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="keyword">with</span> open(...) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="文件读写模式"><a href="#文件读写模式" class="headerlink" title="文件读写模式"></a>文件读写模式</h4><ol><li><p>官方文档：<br>| Character | Meaning |<br>| —— | —— |<br>| ‘r’ | open for reading (default) |<br>| ‘w’  | open for writing, truncating the file first |<br>| ‘x’ | create a new file and open it for writing |<br>| ‘a’ | open for writing, appending to the end of the file if it exists |<br>| ‘b’ | binary mode |<br>| ‘t’ | text mode (default) |<br>| ‘+’ | open a disk file for updating (reading and writing) |<br>| ‘U’ | universal newline mode (deprecated) |</p></li><li><p>翻译：<br>(1). <code>rb</code>，读字节，文件不存在报错。<br>(2). <code>wb</code>，写字节，每次调用会覆盖原文件，文件不存在会新建。<br>(3). <code>ab</code>，追加写字节，写入信息会追加到文件末尾，文件不存在会新建。<br>(4). <code>rb+</code>，读、写字节，文件不存在会报错。<br>(5). <code>wb+</code>，读、写字节，每次调用会覆盖原文件，文件不存在会新建。<br>(6). <code>ab+</code>，读、追加写字节，写入信息会追加到文件末尾，文件不存在会新建。<br>(7). <code>r</code>，读字符，文件不存会报错。<br>(8). <code>w</code>，写字符，每次调用会覆盖原文件，文件不存在会新建。<br>(9). <code>a</code>，追加写字符，写入信息会追加到文件末尾，文件不存在会新建。<br>(10). <code>r+</code>，读、 写字符，文件不存在会报错。<br>(11). <code>w+</code>，读、写字符，每次调用会覆盖原文件，文件不存在会新建。<br>(12). <code>a+</code>，读、追加写字符，写入信息会追加到文件末尾，文件不存在会新建。</p></li></ol><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read(self, n: int = -1) -&gt; AnyStr</span><br><span class="line"></span><br><span class="line">readable(self) -&gt; bool:</span><br><span class="line"></span><br><span class="line">readline(self, limit: int = -1) -&gt; AnyStr:</span><br><span class="line"></span><br><span class="line">readlines(self, hint: int = -1) -&gt; List[AnyStr]</span><br></pre></td></tr></table></figure><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writable(self) -&gt; bool</span><br><span class="line"></span><br><span class="line">write(self, s: AnyStr) -&gt; int</span><br><span class="line"></span><br><span class="line">writelines(self, lines: List[AnyStr]) -&gt; None</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li><p>异常处理格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 可能引发异常现象的代码</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="comment"># 出现异常时执行的代码</span></span><br><span class="line"><span class="comment"># 可有多个 except 代码块，但只执行一条 except 代码块</span></span><br><span class="line"><span class="comment"># 一般格式：except 异常类名[ as 变量名]</span></span><br><span class="line"><span class="comment"># 一般捕获异常类型从小到大</span></span><br><span class="line"><span class="comment"># Exception 类是所有异常类的父类</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 未出现异常时执行的代码</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># try 代码块结束时执行的代码</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>异常抛出格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> 异常类对象</span><br></pre></td></tr></table></figure></li><li><p>自定义异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="string">""" AAA 为自定义异常类名"""</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h3><ol><li><p>导入模块的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;模块名&#125;   <span class="comment"># 全部导入</span></span><br><span class="line"><span class="keyword">from</span> &#123;模块名&#125; <span class="keyword">import</span> &#123;资源名称&#125;   <span class="comment"># 局部导入</span></span><br><span class="line"><span class="comment"># 资源名称包括：类名、函数和全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>局部导入资源访问控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &#123;模块名称&#125; <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__al__ = [<span class="string">"&#123;资源名称&#125;"</span>, <span class="string">"&#123;资源名称&#125;"</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li><p>屏蔽文件的执行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ = <span class="string">"__main__"</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>模块资源运行工作原理：第一次导入资源文件生成<code>.pyc</code>缓存文件。 </p></li><li><code>包</code>是项目结构中的目录，用于文件分层管理。</li></ol><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li><p>超长行处理</p><ul><li>换行处使用<code>\</code></li><li>对整体添加<code>()</code>，<code>()</code>中随意换行</li></ul></li><li><p><code>import this</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python介绍&quot;&gt;&lt;a href=&quot;#python介绍&quot; class=&quot;headerlink&quot; title=&quot;python介绍&quot;&gt;&lt;/a&gt;&lt;code&gt;python&lt;/code&gt;介绍&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;解释型编程语言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pyth
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>learning_python_04</title>
    <link href="http://yoursite.com/2019/04/04/learning-python-04/"/>
    <id>http://yoursite.com/2019/04/04/learning-python-04/</id>
    <published>2019-04-04T12:59:41.000Z</published>
    <updated>2019-06-29T13:10:04.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>yhw-miracle</code>原创文章，可以随意转载，但需注明出处。</p></blockquote><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li><p>字典（dict）（{xx: xx,…}）是一种使用“键值对结构”存储数据的存储模型，没有<code>索引</code>概念，利用<code>键</code>（键是<strong>唯一</strong>的）来索引，可以根据<code>键</code>对字典数据进行增、删、改、查操作。</p></li><li><p>字典中的函数</p><blockquote><ul><li><code>clear(self)</code>:  D.clear() :  None.  Remove all items from D.</li><li><code>copy(self)</code>: D.copy() :  a shallow copy of D.</li><li><code>fromkeys(seq)</code>: Create a new dictionary with keys from iterable and values set to value.</li><li><code>get(self, k)</code>: Return the value for key if key is in the dictionary, else default.</li><li><code>items(self)</code>: D.items() :  a set-like object providing a view on D’s items.</li><li><code>keys(self)</code>: D.keys() :  a set-like object providing a view on D’s keys.</li><li><code>values(self)</code>: D.values() :  an object providing a view on D’s values.</li><li><code>pop(self,  k)</code>: D.pop(k[,d]) :  v, remove specified key and return the corresponding value.If key is not found, d is returned if given, otherwise KeyError is raised.</li><li><code>popitem(self)</code>: D.popitem() :  (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.</li><li><code>setdefault(self, k,  default)</code>: Insert key with a value of default if key is not in the dictionary.Return the value for key if key is in the dictionary, else default.</li><li><code>update(self, E=None, \*\*F)</code>: D.update([E, ]**F) :  None.  Update D from dict/iterable E and F. If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]. If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v. In either case, this is followed by: for k in F:  D[k] = F[k].</li></ul></blockquote></li></ul><blockquote><ul><li>翻译</li><li><code>clear(self)</code>: 清空字典中的所有项。</li><li><code>copy(self)</code>: 返回字典的一个拷贝。</li><li><code>fromkeys(seq)</code>: 用来自迭代器作为键，值集合作为值，创建新的字典。</li><li><code>get(self, k)</code>: 返回指定的键对应的值。</li><li><code>items(self)</code>: 获取字典中所有键值对，以列表形式返回。</li><li><code>keys(self)</code>: 获取字典中所有键，以列表的形式返回。</li><li><code>values(self)</code>: 获取字典中所有值，以列表的形式返回。</li><li><code>pop(self,  k[, d])</code>: 移除字典中指定的键，并返回对应的值。如果指定的键不存在，若给出<code>d</code>，则返回<code>d</code>；否则将抛出<code>KeyError</code>。</li><li><code>popitem(self)</code>: 移除字典中最后一对键值对，并以二元元组的形式返回。若字典为空，抛出<code>KeyError</code>。</li><li><code>setdefault(self, k,  default)</code>: 如果指定的键不在字典中，将指定的键和值（没有，默认为<code>None</code>）插入到字典中，并返回值。</li><li><code>update(self, E=None, \*\*F)</code>: 使用新字典中的数据对原始字典数据进行更新。如果字典<code>E</code>存在，有<code>keys()</code>方法，则执行代码<code>for k in E: D[k] = E[K]</code>；如果迭代器<code>E</code>存在，缺失<code>keys()</code>方法，则执行代码<code>for k, v in E: D[k] = v</code>；如果字典或迭代器<code>E</code>不存在，则执行代码<code>for k in F: D[k] = F[k]</code>。</li></ul></blockquote><ul><li>当需要存储大量数据，并且期望在编程期以最快速度获取单个数据，或者使用非对象格式保存单个对象的属性值，推荐选择字典来存储。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为&lt;code&gt;yhw-miracle&lt;/code&gt;原创文章，可以随意转载，但需注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>learning_python_03</title>
    <link href="http://yoursite.com/2019/04/03/learning-python-03/"/>
    <id>http://yoursite.com/2019/04/03/learning-python-03/</id>
    <published>2019-04-03T12:50:32.000Z</published>
    <updated>2019-06-29T13:18:44.156Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>yhw-miracle</code>原创文章，可以随意转载，但需注明出处。</p></blockquote><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li><p>元组（<code>tuple</code>）（<code>()</code>）是一种存储固定数据的存储模型，元组中的数据通过<code>索引</code>修改。</p></li><li><p>元组中的数据若是<code>非引用类型数据</code>，不允许修改；若是<code>引用类型数据</code>，不允许修改对象，可以修对象的值。</p></li><li><p>元组函数</p><blockquote><ul><li><code>count(self, x)</code>: Return number of occurrences of value.</li><li><code>index(self, x, start, end)</code>: Return first index of value.Raises ValueError if the value is not present</li></ul><hr><ul><li>翻译</li><li><code>count(self, x)</code>: 返回元组中指定数据出现的次数。</li><li><code>index(self, x, start, end)</code>: 返回指定数据在元组中出现的第一个位置，若指定数据不存在，抛出<code>ValueError</code>。</li></ul></blockquote></li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li><p>集合（<code>set</code>）（<code>{,,...}</code>）是一种存储无序不重复数据的存储模型，没有<code>索引</code>概念。</p></li><li><p>集合中的函数</p><blockquote><ul><li><code>add(self, element)</code>: Add an element to a set.This has no effect if the element is already present.</li><li><code>clear(self)</code>: Remove all elements from this set.</li><li><code>copy(self)</code>: Return a shallow copy of a set.</li><li><code>difference(self, s)</code>: Return the difference of two or more sets as a new set.(i.e. all elements that are in this set but not the others.)</li><li><code>difference_update(self,  s)</code>: Remove all elements of another set from this set.</li><li><code>discard(self, element)</code>: Remove an element from a set if it is a member.If the element is not a member, do nothing.</li><li><code>intersection(self, s)</code>: Return the intersection of two sets as a new set.(i.e. all elements that are in both sets.)</li><li><code>intersection_update(self,  s)</code>: Update a set with the intersection of itself and another.</li><li><code>isdisjoint(self, s)</code>: Return True if two sets have a null intersection.</li><li><code>issubset(self ,s)</code>: Report whether another set contains this set.</li><li><code>issuperset(self, s)</code>: Report whether this set contains another set.</li><li><code>pop(self)</code>: Remove and return an arbitrary set element.Raises KeyError if the set is empty.</li><li><code>remove(self ,element)</code>: Remove an element from a set; it must be a member.If the element is not a member, raise a KeyError.</li><li><code>symmetric_difference(self,  s)</code>: Return the symmetric difference of two sets as a new set.(i.e. all elements that are in exactly one of the sets.)</li><li><code>symmetric_difference_update(self,  s)</code>: Update a set with the symmetric difference of itself and another.</li><li><code>union(self, s)</code>: Return the union of sets as a new set.(i.e. all elements that are in either set.)</li><li><code>update(self,  s)</code>: Update a set with the union of itself and others.</li></ul></blockquote></li></ul><blockquote><ul><li>翻译</li><li><code>add(self, element)</code>: 添加一个元素到集合中，若改元素已经存在，集合将无任何影</li><li><code>clear(self)</code>: 移除集合中所有元素。</li><li><code>copy(self)</code>: 返回集合的拷贝体。</li><li><code>difference(self, s)</code>: 记录该集合与其他集合之间的不同元素，组成新的集合并返回（简单来说，返回集合中的所有元素在该集合中，不在其他集合中）。</li><li><code>difference_update(self,  s)</code>: 移除另一个集合中与该集合相同的元素。</li><li><code>discard(self, element)</code>: 移除集合中的指定元素，若该元素不存，则不任何事</li><li><code>intersection(self, s)</code>: 记录两个集合的交集，组成新的集合并返回（简单来说，新的集合中元素是两个集合中都有的元素）。</li><li><code>intersection_update(self,  s)</code>: 将该集合和另一个集合的交集更新到该集合中。</li><li><code>isdisjoint(self, s)</code>: 若两个集合没有交集，返回<code>True</code>。</li><li><code>issubset(self ,s)</code>: 报告另一个集合是否包含该集合，若包含，返回<code>True</code>；若不包含，返回<code>False</code>。</li><li><code>issuperset(self, s)</code>: 报告这个集合是否包含另一个集合，若包含，返回<code>True</code>；若不包含，返回<code>False</code>。</li><li><code>pop(self)</code>: 移除并返回这个该集合中随意一个元素，若集合为空，抛出<code>KeyError</code></li><li><code>remove(self ,element)</code>: 移除集合中指定的元素，若指定元素不存在，抛出<code>KeyError</code></li><li><code>symmetric_difference(self,  s)</code>: 记录两个集合的均匀区别，组成新的集合并返回（简单来说，新的集合中元素只存在于其中一个集合中）。</li><li><code>symmetric_difference_update(self,  s)</code>: 将两个集合的均匀区别更新到该集合中。</li><li><code>union(self, s)</code>: 记录两个集合之间的并集，组成新的集合并返回（简单来说，两个集合中所有元素）。</li><li><code>update(self,  s)</code>: 将两个集合之间的并集更新到该集合中。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为&lt;code&gt;yhw-miracle&lt;/code&gt;原创文章，可以随意转载，但需注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;元组&quot;&gt;&lt;a href=&quot;#元组&quot; class=&quot;headerlink&quot; title=&quot;元组&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>learning_python_02</title>
    <link href="http://yoursite.com/2019/04/02/learning_python_02/"/>
    <id>http://yoursite.com/2019/04/02/learning_python_02/</id>
    <published>2019-04-02T12:26:20.000Z</published>
    <updated>2019-06-29T13:13:51.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>yhw-miracle</code>原创文章，可以随意转载，但需注明出处。</p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p><code>python</code>中的数据结构</p><blockquote><ul><li><code>int</code>：整型</li><li><code>float</code>：浮点型</li><li><code>bool</code>：布尔型</li><li><code>str</code>：字符串</li><li><code>tuple</code>：元组</li><li><code>list</code>：列表</li><li><code>set</code>：集合</li><li><code>dict</code>：字典</li></ul></blockquote></li><li><p>获取数据类型：<code>type()</code></p></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>列表（<code>list</code>）（<code>[]</code>）是一种存储大量数据的存储模型，可以对数据进行增、删、改、查操作。</li><li><p>增加数据</p><blockquote><ul><li><code>append(self, object)</code>: Append object to the end of the list.</li><li><code>insert(self, index, object)</code>: Insert object before index.</li><li><code>extend(self, iterable)</code>: Extend list by appending elements from the iterable.</li></ul><hr><ul><li>翻译：</li><li><code>append(self, object)</code>: 在列表的末尾添加元素。</li><li><code>insert(self, index, object)</code>: 在指定位置之前插入元素。</li><li><code>extend(self, iterable)</code>: 从可迭代数据存储器中扩充到列表末尾。</li></ul></blockquote></li><li><p>删除数据</p><blockquote><ul><li><code>remove(self, object)</code>: Remove first occurrence of value.Raises ValueError if the value is not present.</li><li><code>pop(self, index)</code>: Remove and return item at index (default last).Raises IndexError if list is empty or index is out of range.</li><li><code>clear(self)</code>: Remove all items from list.</li></ul><hr><ul><li>翻译：</li><li><code>remove(self, object)</code>: 移除列表中第一个指定数据，若指定数据不存在，抛出<code>ValueError</code>。</li><li><code>pop(self, index)</code>: 移除并返回列表中指定位置的数据（默认为最后一个），若列表为空或者指定位置超过范围，抛出<code>IndexError</code>。</li><li><code>clear(self)</code>: 移除列表中所有元素。</li></ul></blockquote></li><li><p>修改数据和查询数据：<code>根据索引</code></p></li><li><p>其他函数</p><blockquote><ul><li><code>count(self, object)</code>: Return number of occurrences of value.</li><li><code>index(self, object, start, stop)</code>: Return first index of value.Raises ValueError if the value is not present.</li><li><code>copy(self)</code>: Return a shallow copy of the list.</li><li><code>reverse(self)</code>: Reverse <em>IN PLACE</em>.</li><li><code>sort(self, key, reverse)</code>: Stable sort <em>IN PLACE</em>.</li></ul><hr><ul><li>翻译</li><li><code>count(self, object)</code>: 返回指定数据在列表中的个数。</li><li><code>index(self, object, start, stop)</code>: 返回指定数据在列表中第一个位置，若指定数据不存在，抛出<code>ValueError</code>。</li><li><code>copy(self)</code>: 返回一个列表的拷贝。</li><li><code>reverse(self)</code>: 在列表上反转。</li><li><code>sort(self, key, reverse)</code>: 在列表上执行稳定排序。</li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为&lt;code&gt;yhw-miracle&lt;/code&gt;原创文章，可以随意转载，但需注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>learning_python_01</title>
    <link href="http://yoursite.com/2019/04/01/learning_python_01/"/>
    <id>http://yoursite.com/2019/04/01/learning_python_01/</id>
    <published>2019-04-01T11:28:14.000Z</published>
    <updated>2019-06-29T12:29:05.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>yhw-miracle</code>原创文章，可以随意转载，但需注明出处。</p></blockquote><h3 id="python介绍"><a href="#python介绍" class="headerlink" title="python介绍"></a><code>python</code>介绍</h3><ul><li>解释型编程语言</li><li><code>python</code>单行注释<code>#</code></li><li><code>python</code>多行注释<code>&quot;&quot;&quot;</code>与<code>&quot;&quot;&quot;</code></li><li><code># TODO</code>说明文字</li></ul><h3 id="变量、关键字"><a href="#变量、关键字" class="headerlink" title="变量、关键字"></a>变量、关键字</h3><ul><li>变量用于描述计算机中的数据存储空间，作用是在计算机内存中保存数据。</li><li>变量名的命名规则是由数字、字母和下划线组成，不能以数字开头，不能是关键字，区分大小写。</li><li>下划线连接，驼峰命名法</li><li>关键字</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure><p><img src="/images/2019/Apr/01.png" alt=""></p><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><ul><li><p>输入：input()</p></li><li><p>输出</p><blockquote><ul><li>print()</li><li>%s，字符串占位符</li><li>%d，整数占位符</li><li>%f，浮点数占位符</li><li>%%，输入`%`</li></ul></blockquote></li></ul><h3 id="python运算"><a href="#python运算" class="headerlink" title="python运算"></a>python运算</h3><ul><li><p>字符串运算</p><blockquote><ul><li><code>+</code>：拼接</li><li><code>*</code>：连续拼接</li></ul></blockquote></li><li><p>算术运算符</p><blockquote><ul><li><code>+</code>，加</li><li><code>-</code>，减</li><li><code>*</code>，乘</li><li><code>/</code>，除</li><li><code>//</code>，整除</li><li><code>%</code>，取余</li><li><code>**</code>，乘方</li><li>优先级，乘方 &gt; [乘，除，整除，取余] &gt; [加，减]</li></ul></blockquote></li><li><p>赋值运算符</p><blockquote><ul><li>=，赋值</li><li>+=，加后赋值</li><li>-=，减后赋值</li><li>*=，乘后赋值</li><li>/=，除后赋值</li><li>//=，整除后赋值</li><li>%=，取余后赋值</li><li>**=，次方后赋值</li></ul></blockquote></li><li><p>比较运算符</p><blockquote><ul><li>>，大于</li><li>>=，大于等于</li><li>&lt;，小于</li><li>&lt;=，小于等于</li><li>!=，不低于</li><li>==，等于</li><li>查看字母和数字的<code>ASCII</code>值</li><li>查看<code>ASCII</code>值：ord()</li><li>已知<code>ASCII</code>值查看对应的字符：chr()</li></ul></blockquote></li><li><p>关系运算符（逻辑运算符）</p><blockquote><ul><li>and：短路与，左操作数为<code>False</code>，表达式结果为<code>False</code>，与<code>左</code>操作数<code>bool</code>值相同。 </li><li>or：短路或，左操作数为<code>True</code>，表达式结果为<code>True</code>，与<code>左</code>操作数<code>bool</code>值相同。</li><li>not</li></ul></blockquote><ul><li>一些例子<blockquote><ul><li>1 and True =&gt; True</li><li>0 and True =&gt; 0</li><li>1 or True =&gt; 1</li><li>0 or True =&gt; True</li><li>1 and False =&gt; False</li><li>0 and False =&gt; 0</li><li>1 or False =&gt; 1</li><li>0 or False =&gt; False</li></ul><hr><ul><li>True and 1 =&gt; 1</li><li>True and 0 =&gt; 0</li><li>True or 1 =&gt; True</li><li>True or 0 =&gt; True</li><li>False and 1 =&gt; False</li><li>False and 0 =&gt; False</li><li>False or 1 =&gt; 1</li><li>False or 0 =&gt; 0</li></ul></blockquote></li></ul></li></ul><h3 id="三大语句"><a href="#三大语句" class="headerlink" title="三大语句"></a>三大语句</h3><ul><li><p>顺序语句：自上而下执行语句</p></li><li><p>分支语句</p><blockquote><ul><li>if…</li><li>if…else…</li><li>if…elif…else…</li><li>分支嵌套</li></ul></blockquote></li><li><p>循环结构</p><blockquote><ul><li>while</li><li>for…in…</li><li>for…in…else…，循环正常结束后执行<code>else</code>部分。</li><li>while…else…</li><li>break，终止循环的执行</li><li>continue，终止本轮循环的执行</li><li>range(m, n, s): 生成 m（默认为0） 到 n-1 的整数，整数间隔为 s（默认为1）。</li><li>推导式的使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; list1 = [data <span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">&gt; list1 = [data**<span class="number">2</span> <span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">&gt; list1 = [data <span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> data &gt; <span class="number">2</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为&lt;code&gt;yhw-miracle&lt;/code&gt;原创文章，可以随意转载，但需注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;python介绍&quot;&gt;&lt;a href=&quot;#python介绍&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>详解基础爬虫架构</title>
    <link href="http://yoursite.com/2019/01/15/%E8%AF%A6%E8%A7%A3%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/01/15/详解基础爬虫架构/</id>
    <published>2019-01-14T16:00:01.000Z</published>
    <updated>2019-01-15T11:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础爬虫框架主要包括五大模块，分别为<code>URL</code>管理器、<code>HTML</code>下载器、<code>HTML</code>解析器、数据存储器和爬虫调度器。它们之间关系如下图所示。</p><p><img src="/images/2019/Jan/2.png" alt=""></p><p><code>URL</code>管理器负责管理<code>URL</code>链接，维护已爬取的<code>URL</code>集合和为未爬取的<code>URL</code>集合，并提供外部访问接口。</p><p><code>HTML</code>下载器负责从<code>URL</code>管理器中获取未爬取的<code>URL</code>链接，并下载相应的<code>HTML</code>网页。</p><p><code>HTML</code>解析器负责解析<code>HTML</code>下载器下载的网页信息，解析出的信息交给数据存储器，解析出的新的<code>URL</code>链接交给<code>URL</code>管理器。</p><p>数据存储器负责将<code>HTML</code>解析器解析出来的数据通过文件或数据库的形式存储起来。</p><p>爬虫调度器负责统筹以上四个模块之间协调工作。</p><p>以爬取百度百科<code>100</code>条词条的词条标题、摘要和链接为例。</p><h3 id="URL管理器"><a href="#URL管理器" class="headerlink" title="URL管理器"></a><code>URL</code>管理器</h3><p><code>URL</code>管理器维护了两个变量，已爬取<code>URL</code>集合和未爬取<code>URL</code>集合；对外提供了四类访问这两个变量的方法，包括是否有待爬取的<code>URL</code>、获取未爬取的<code>URL</code>、添加新的<code>URL</code>到未爬取集合中、已爬取<code>URL</code>集合和未爬取<code>URL</code>集合的大小。</p><p><code>URL</code>管理器需要对爬取的<code>URL</code>进行去重处理，常见的去重方案有三种，分别是内存去重、关系数据库去重和缓存数据库去重。</p><p>两个变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.new_urls = set()</span><br><span class="line">self.old_urls = set()</span><br></pre></td></tr></table></figure></p><p>六个方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">have_new_url(self)</span><br><span class="line">get_new_url(self)</span><br><span class="line">add_new_url(self, url)</span><br><span class="line">add_new_urls(self, urls)</span><br><span class="line">new_url_size(self)</span><br><span class="line">old_url_size(self)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.new_urls = set()</span><br><span class="line">        self.old_urls = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">have_new_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断是否有待爬取的 url</span></span><br><span class="line"><span class="string">        :return: 待爬取的 url 集合的大小</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.new_url_size() != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取待爬取的 url</span></span><br><span class="line"><span class="string">        :return: 一个待爬取的 url</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_url = self.new_urls.pop()</span><br><span class="line">        <span class="keyword">if</span> new_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.old_urls.add(new_url)</span><br><span class="line">            <span class="keyword">return</span> new_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_url</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        添加一个待爬取的 url</span></span><br><span class="line"><span class="string">        :param url:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.new_urls <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.old_urls:</span><br><span class="line">            self.new_urls.add(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_urls</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        添加待爬取的 url 集合</span></span><br><span class="line"><span class="string">        :param urls:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> urls <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(urls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.add_new_url(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_url_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        待爬取的 url 集合的大小</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.new_urls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">old_url_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        已爬取的 url 集合的大小</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.old_urls)</span><br></pre></td></tr></table></figure><h3 id="HTML下载器"><a href="#HTML下载器" class="headerlink" title="HTML下载器"></a><code>HTML</code>下载器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        user_agent = <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span> \</span><br><span class="line">                     <span class="string">"Chrome/71.0.3578.98 Safari/537.36"</span></span><br><span class="line">        headers = &#123;<span class="string">"User-Agent"</span>: user_agent&#125;</span><br><span class="line">        req = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> req.status_code == <span class="number">200</span>:</span><br><span class="line">            req.encoding = <span class="string">"utf-8"</span></span><br><span class="line">            <span class="keyword">return</span> req.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="HTML解析器"><a href="#HTML解析器" class="headerlink" title="HTML解析器"></a><code>HTML</code>解析器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re, urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parser</span><span class="params">(self, page_url, html_content)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param page_url:</span></span><br><span class="line"><span class="string">        :param html_content:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> page_url <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> html_content <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        soup = BeautifulSoup(html_content, <span class="string">"lxml"</span>)</span><br><span class="line">        new_urls = self.get_new_urls(page_url, soup)</span><br><span class="line">        new_data = self.get_new_data(page_url, soup)</span><br><span class="line">        <span class="keyword">return</span> new_urls, new_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_urls</span><span class="params">(self, page_url, soup)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param page_url:</span></span><br><span class="line"><span class="string">        :param soup:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_urls = set()</span><br><span class="line">        links = soup.find_all(<span class="string">"a"</span>, href=re.compile(<span class="string">r'/item/(%\w+)+/\d+'</span>))</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            new_url = link[<span class="string">"href"</span>]</span><br><span class="line">            new_full_url = urlparse.urljoin(page_url, new_url)</span><br><span class="line">            new_urls.add(new_full_url)</span><br><span class="line">        <span class="keyword">return</span> new_urls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_data</span><span class="params">(self, page_url, soup)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param page_url:</span></span><br><span class="line"><span class="string">        :param soup:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        data[<span class="string">"url"</span>] = page_url.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">        title = soup.find(<span class="string">"dd"</span>, class_=<span class="string">"lemmaWgt-lemmaTitle-title"</span>).find(<span class="string">"h1"</span>)</span><br><span class="line">        data[<span class="string">"title"</span>] = title.string.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">        summary = soup.find(<span class="string">"div"</span>, class_=<span class="string">"lemma-summary"</span>)</span><br><span class="line">        data[<span class="string">"summary"</span>] = summary.get_text().encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h3 id="数据存储器"><a href="#数据存储器" class="headerlink" title="数据存储器"></a>数据存储器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataOutput</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.datas = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.datas.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_html</span><span class="params">(self)</span>:</span></span><br><span class="line">        headers = [<span class="string">"url"</span>, <span class="string">"title"</span>, <span class="string">"summary"</span>]</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"baike.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp_csv = csv.DictWriter(fp, headers)</span><br><span class="line">            fp_csv.writeheader()</span><br><span class="line">            fp_csv.writerows(self.datas)</span><br></pre></td></tr></table></figure><h3 id="爬虫调度器"><a href="#爬虫调度器" class="headerlink" title="爬虫调度器"></a>爬虫调度器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> URLManager <span class="keyword">import</span> URLManager</span><br><span class="line"><span class="keyword">from</span> HtmlDownloader <span class="keyword">import</span> HtmlDownloader</span><br><span class="line"><span class="keyword">from</span> HtmlParser <span class="keyword">import</span> HtmlParser</span><br><span class="line"><span class="keyword">from</span> DataOutput <span class="keyword">import</span> DataOutput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.manager = URLManager()</span><br><span class="line">        self.downloader = HtmlDownloader()</span><br><span class="line">        self.parser = HtmlParser()</span><br><span class="line">        self.output = DataOutput()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self, root_url)</span>:</span></span><br><span class="line">        self.manager.add_new_url(root_url)</span><br><span class="line">        <span class="keyword">while</span>(self.manager.have_new_url() <span class="keyword">and</span> self.manager.old_url_size() &lt; <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                new_url = self.manager.get_new_url()</span><br><span class="line">                html = self.downloader.download(new_url)</span><br><span class="line">                new_urls, data = self.parser.parser(new_url, html)</span><br><span class="line">                self.manager.add_new_urls(new_urls)</span><br><span class="line">                self.output.store_data(data)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"已经爬取 %s 个链接"</span> % self.manager.old_url_size()</span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"crawl failed."</span></span><br><span class="line">                <span class="keyword">print</span> e</span><br><span class="line">        self.output.output_html()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    spider = Spider()</span><br><span class="line">    spider.crawl(<span class="string">"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基础爬虫框架主要包括五大模块，分别为&lt;code&gt;URL&lt;/code&gt;管理器、&lt;code&gt;HTML&lt;/code&gt;下载器、&lt;code&gt;HTML&lt;/code&gt;解析器、数据存储器和爬虫调度器。它们之间关系如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019/Ja
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫框架" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>python实现邮件发送</title>
    <link href="http://yoursite.com/2019/01/15/python%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>http://yoursite.com/2019/01/15/python实现邮件发送/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-15T12:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在爬虫开发中，爬虫运行过程中遇到异常或服务器遇到问题时，我们可以采用发送邮件，及时报告爬虫程序当前故障问题。</p><p>邮件发送协议是<code>SMTP</code>，<code>python</code>内置对<code>SMTP</code> 的支持，可以发送纯文本邮件、<code>HTML</code> 邮件以及带附件的邮件。<code>python</code>中对<code>SMTP</code>支持有 <code>smtpplib</code>和<code>email</code>模块，<code>email</code> 负责构造邮件，<code>smtplib</code>负责发送邮件。</p><p>1.以网易的邮件发送服务器为例<code>smtp.163.com</code>，需要开启网易邮箱的<code>smtp</code>功能。</p><p>2.构造纯文本邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">"你好，世界！"</span>, <span class="string">"plain"</span>, <span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure></p><p>构造<code>html</code>邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">"&lt;a href='https://yhw-miracle.win/'&gt;my blog&lt;/a&gt;"</span>, <span class="string">"html"</span>, <span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure></p><p>3.设置发件人信息、收件人信息和邮件主题信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from_addr = <span class="string">"yhw_software@163.com"</span></span><br><span class="line">password = <span class="string">"********"</span></span><br><span class="line"></span><br><span class="line">to_addr = <span class="string">"yhw_software@qq.com"</span></span><br><span class="line"></span><br><span class="line">smtp_server = <span class="string">"smtp.163.com"</span></span><br><span class="line"></span><br><span class="line">msg[<span class="string">'From'</span>] = format_addr(<span class="string">"我是 &lt;%s&gt;"</span> % from_addr)</span><br><span class="line">msg[<span class="string">"To"</span>] = format_addr(<span class="string">"你是 &lt;%s&gt;"</span> % to_addr)</span><br><span class="line">msg[<span class="string">"Subject"</span>] = Header(<span class="string">"晚安"</span>, <span class="string">"utf-8"</span>).encode()</span><br></pre></td></tr></table></figure></p><p>4.发送邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>完整代码如下所示。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">"utf-8"</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from_addr = <span class="string">"yhw_software@163.com"</span></span><br><span class="line">password = <span class="string">"*********"</span></span><br><span class="line"></span><br><span class="line">to_addr = <span class="string">"yhw_software@qq.com"</span></span><br><span class="line"></span><br><span class="line">smtp_server = <span class="string">"smtp.163.com"</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">"晚上好！"</span>, <span class="string">"plain"</span>, <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">msg[<span class="string">'From'</span>] = format_addr(<span class="string">"我是 &lt;%s&gt;"</span> % from_addr)</span><br><span class="line">msg[<span class="string">"To"</span>] = format_addr(<span class="string">"你是 &lt;%s&gt;"</span> % to_addr)</span><br><span class="line">msg[<span class="string">"Subject"</span>] = Header(<span class="string">"晚安"</span>, <span class="string">"utf-8"</span>).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在爬虫开发中，爬虫运行过程中遇到异常或服务器遇到问题时，我们可以采用发送邮件，及时报告爬虫程序当前故障问题。&lt;/p&gt;
&lt;p&gt;邮件发送协议是&lt;code&gt;SMTP&lt;/code&gt;，&lt;code&gt;python&lt;/code&gt;内置对&lt;code&gt;SMTP&lt;/code&gt; 的支持，可以发送纯文
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="邮件发送" scheme="http://yoursite.com/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>提取多媒体文件</title>
    <link href="http://yoursite.com/2019/01/14/%E6%8F%90%E5%8F%96%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/01/14/提取多媒体文件/</id>
    <published>2019-01-13T16:00:01.000Z</published>
    <updated>2019-01-15T11:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用 python 爬取多媒体文件，存储它们有两种方式，一是只存储 url 链接，二是将文件下载下来。存储文件链接可以将文件的链接信息存储到 json 文件或 csv 文件；下载文件需要用到 urllib 模块提供的 urlretrieve() 函数，urlretrieve() 函数可以将远程数据下载到本地。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlretrieve(url,filename=<span class="keyword">None</span>,reporthook=<span class="keyword">None</span>,data=<span class="keyword">None</span>,context=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>参数 filename 是指存储的本地路径；reporthook 是一个回调函数，当连接到服务器以及传输完毕相应的数据块，会调用该回调函数，一般用于显示下载进度。</p><p>以爬取天堂网图片为例 <a href="http://www.ivsky.com/tupian/ziranfengguang/" target="_blank" rel="noopener">http://www.ivsky.com/tupian/ziranfengguang/</a>，下载图片的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span><span class="params">(blocknum, blocksize, totalsize)</span>:</span></span><br><span class="line">    per = <span class="number">100.0</span> * blocknum * blocksize / totalsize</span><br><span class="line">    <span class="keyword">if</span> per &gt; <span class="number">100</span>:</span><br><span class="line">        per = <span class="number">100</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"当前下载进度： %d"</span> % per</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_agent = <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span> \</span><br><span class="line">             <span class="string">"Chrome/71.0.3578.98 Safari/537.36"</span></span><br><span class="line">headers = &#123;<span class="string">"User-Agent"</span>: user_agent&#125;</span><br><span class="line">req = requests.get(<span class="string">"http://www.ivsky.com/tupian/ziranfengguang/"</span>, headers=headers)</span><br><span class="line"></span><br><span class="line">html = etree.HTML(req.text)</span><br><span class="line">img_urls = html.xpath(<span class="string">".//img/@src"</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> img_url <span class="keyword">in</span> img_urls:</span><br><span class="line">    urllib.urlretrieve(img_url, <span class="string">"./images/img"</span>+str(i)+<span class="string">".jpg"</span>, schedule)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/images/2019/Jan/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用 python 爬取多媒体文件，存储它们有两种方式，一是只存储 url 链接，二是将文件下载下来。存储文件链接可以将文件的链接信息存储到 json 文件或 csv 文件；下载文件需要用到 urllib 模块提供的 urlretrieve() 函数，urlretrieve
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多媒体文件" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6/"/>
    
      <category term="下载" scheme="http://yoursite.com/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据存储为json和csv</title>
    <link href="http://yoursite.com/2019/01/14/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%BAjson%E5%92%8Ccsv/"/>
    <id>http://yoursite.com/2019/01/14/数据存储为json和csv/</id>
    <published>2019-01-13T16:00:00.000Z</published>
    <updated>2019-01-14T08:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>进行 python 爬虫时，我们需要将数据存储起来。对于小数据量，我们可以存储到 json 文件或 csv 文件。</p><h3 id="json存储"><a href="#json存储" class="headerlink" title="json存储"></a>json存储</h3><p>Python 对 json 文件的操作是通过 JSON 模块实现的，分为编码和解码两个过程。</p><p>编码是指将 python 对象转换为 json 对象，常用的函数是 dump() 和 dumps()，区别是 dump() 将 python 对象转换为 json 对象，并将 json 对象通过文件流写入文件，dumps() 函数是返回字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dumps(obj,skipkeys=<span class="keyword">False</span>,ensure_ascii=<span class="keyword">True</span>,check_circular=<span class="keyword">True</span>,allow_nan=<span class="keyword">True</span>,cls=<span class="keyword">None</span>,indent=<span class="keyword">None</span>,separators=<span class="keyword">None</span>,encoding=<span class="string">'utf-8'</span>,default=<span class="keyword">None</span>,sort_keys=<span class="keyword">False</span>,**kw)</span><br><span class="line">dumps(obj,skipkeys=<span class="keyword">False</span>,ensure_ascii=<span class="keyword">True</span>,check_circular=<span class="keyword">True</span>,allow_nan=<span class="keyword">True</span>,cls=<span class="keyword">None</span>,indent=<span class="keyword">None</span>,separators=<span class="keyword">None</span>,encoding=<span class="string">'utf-8'</span>,default=<span class="keyword">None</span>,sort_keys=<span class="keyword">False</span>,**kw)</span><br></pre></td></tr></table></figure><p>解码是指将 json 对象转换为 python 对象，常用的函数为 load() 和loads()，区别是 load() 是将 json 对象转换为 python 对象，并将 python 对象写入到文件，而 loads() 是返回字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load(fp,encoding=<span class="keyword">None</span>,cls=<span class="keyword">None</span>,object_hook=<span class="keyword">None</span>,parse_float=<span class="keyword">None</span>,parse_int=<span class="keyword">None</span>,parse_constant=<span class="keyword">None</span>,object_pairs_hook=<span class="keyword">None</span>,**kw)</span><br><span class="line">loads(s,encoding=<span class="keyword">None</span>,cls=<span class="keyword">None</span>,object_hook=<span class="keyword">None</span>,parse_float=<span class="keyword">None</span>,parse_int=<span class="keyword">None</span>,parse_constant=<span class="keyword">None</span>,object_pairs_hook=<span class="keyword">None</span>,**kw)</span><br></pre></td></tr></table></figure><h3 id="csv存储"><a href="#csv存储" class="headerlink" title="csv存储"></a>csv存储</h3><p>CSV(Comma-Separated Values，逗号分隔值，有时也称为字符分隔值)，其文件是以纯文本形式存储表格数据。CSV 文件由任意数目的记录组成，记录间以换行符分隔，每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号和制表符。CSV 文件示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID,Username,Password,Age,Country</span><br><span class="line"></span><br><span class="line">1001,yhw,123456,24,China</span><br><span class="line"></span><br><span class="line">1002,Mary,654321,25,USA</span><br><span class="line"></span><br><span class="line">1003,Jack,123567,22,English</span><br></pre></td></tr></table></figure><p>Python 通过 csv 库来读写 csv 文件。Python 写 csv 文件，需要用到 write 对象，然后按行写每一个记录；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">header = (<span class="string">"ID"</span>, <span class="string">"Username"</span>, <span class="string">"Password"</span>, <span class="string">"Age"</span>, <span class="string">"Country"</span>)</span><br><span class="line">rows = [(<span class="number">1001</span>, <span class="string">"yhw"</span>, <span class="string">"123456"</span>, <span class="number">24</span>, <span class="string">"China"</span>),</span><br><span class="line">        (<span class="number">1002</span>, <span class="string">"Mary"</span>, <span class="string">"654321"</span>, <span class="number">25</span>, <span class="string">"USA"</span>),</span><br><span class="line">        (<span class="number">1003</span>, <span class="string">"Jack"</span>, <span class="string">"123567"</span>, <span class="number">22</span>, <span class="string">"English"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test3.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp_csv = csv.writer(fp)</span><br><span class="line">    fp_csv.writerow(header)</span><br><span class="line">    fp_csv.writerows(rows)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">rows = [&#123;<span class="string">"ID"</span>: <span class="number">1001</span>, <span class="string">"Username"</span>: <span class="string">"yhw"</span>, <span class="string">"Password"</span>: <span class="string">"123456"</span>, <span class="string">"Age"</span>: <span class="number">24</span>, <span class="string">"Country"</span>: <span class="string">"China"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"ID"</span>: <span class="number">1002</span>, <span class="string">"Username"</span>: <span class="string">"Mary"</span>, <span class="string">"Password"</span>: <span class="string">"654321"</span>, <span class="string">"Age"</span>: <span class="number">25</span>, <span class="string">"Country"</span>: <span class="string">"USA"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"ID"</span>: <span class="number">1003</span>, <span class="string">"Username"</span>: <span class="string">"Jack"</span>, <span class="string">"Password"</span>: <span class="string">"123567"</span>, <span class="string">"Age"</span>: <span class="number">22</span>, <span class="string">"Country"</span>: <span class="string">"English"</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test3.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">fp_csv = csv.DictWriter(fp, header)</span><br><span class="line">    fp_csv.writeheader()</span><br><span class="line">    fp_csv.writerows(rows)</span><br></pre></td></tr></table></figure><p>Python 读取 csv 文件需要用到 reader 对象，然后同样是按行读取每一条记录。要读取特定字段信息，python 可以利用索引、命名元祖、字典这三种方式访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test3.csv"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># 遍历记录</span></span><br><span class="line">    fp_csv = csv.reader(fp)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> fp_csv:</span><br><span class="line">        <span class="keyword">print</span> row</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 索引</span></span><br><span class="line">    fp_csv = csv.reader(fp)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> fp_csv:</span><br><span class="line">        <span class="keyword">print</span> row[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 命名元组</span></span><br><span class="line">    fp_csv = csv.reader(fp)</span><br><span class="line">    header = next(fp_csv)</span><br><span class="line">    Row = namedtuple(<span class="string">"Row"</span>, header)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> fp_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        <span class="keyword">print</span> row.Username, row.Password</span><br><span class="line">        <span class="keyword">print</span> row</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字典</span></span><br><span class="line">    fp_csv = csv.DictReader(fp)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> fp_csv:</span><br><span class="line">        <span class="keyword">print</span> row.get(<span class="string">"Username"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行 python 爬虫时，我们需要将数据存储起来。对于小数据量，我们可以存储到 json 文件或 csv 文件。&lt;/p&gt;
&lt;h3 id=&quot;json存储&quot;&gt;&lt;a href=&quot;#json存储&quot; class=&quot;headerlink&quot; title=&quot;json存储&quot;&gt;&lt;/a&gt;jso
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
      <category term="csv" scheme="http://yoursite.com/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>总结BeautifulSoup</title>
    <link href="http://yoursite.com/2019/01/13/%E6%80%BB%E7%BB%93BeautifulSoup/"/>
    <id>http://yoursite.com/2019/01/13/总结BeautifulSoup/</id>
    <published>2019-01-12T16:00:00.000Z</published>
    <updated>2019-01-13T09:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.BeautifulSoup4 支持 python 标准库(html.parser)、lxml、html5lib 这些解析器解析文档。</p><p>2.格式化输出文档内容 print soup.prettify()，会自动补全文档。</p><p>3.BeautifulSoup4 将复杂的 html 文档转换成一个复杂的树形结构，每一个节点是 python 对象，所有的对象有四种：Tag、NavigableString、BeautifulSoup、Comment。</p><p>4.Tag 查找的是文档中第一个符合内容的标记，有两个属性：name 和 attrs，分别为获取标记的名称和属性，.attrs 返回的是字典类型，也可以用 [] 和 get() 来获取特定的属性内容。</p><p>5.NavigableString 表示的是标记内部的字符串，可以用 .string 来获取。</p><p>6.BeautifulSoup 表示的是文档的全部内容，.name 返回的是 [document]，.attrs 返回的是 {}。</p><p>7.Comment 表示的是文档的注释内容，用 .string 可以获取去掉注释符号的注释内容，可以用 type() == bs4.element.Comment 来判断该字符串是否为注释。</p><p>8.BeautifulSoup 将 html 文档转换为文档树，支持子节点、父节点、兄弟节点和前后节点进行遍历文档树。</p><p>9.获取子节点的属性有 contents、children、descendants。contents 以列表的形式返回直接子节点信息；children 返回的是直接子节点迭代器，可以用 for in 循环遍历；descentants 返回的子孙节点迭代器，可以用 for in 循环遍历。</p><p>10.获取子节点内容的属性有 string、strings、stripped_strings。string 返回的是标记最内部的内容；strings 返回的是标记内部字符串的迭代器，可以用 for in 循环遍历，包括空格和换行；stripped_string 是去掉 strings 中的空格和换行。</p><p>11.获取节点的父节点的属性是 parent，获取节点的父辈节点的属性是 parents，返回父辈节点的迭代器，可以使用 for in 循环遍历。 </p><p>12.获取节点的兄弟节点的属性有 next_sibling，next_siblings 和 previous_sibling，previous_siblings。节点的兄弟节点包括字符串节点（字符串、空格、换行）。</p><p>13.获取节点的前后节点的属性有 next_element，next_elements 和 previous_element，previous_elements。同样前后节点也包括字符串节点。</p><p>14.搜索文档树的方法主要是一系列 find 方法，以列表的形式返回。以 find_all(name, attrs, recursive, text, limit, **kwargs) 为例，其中 name 参数以节点的名称来搜索文档树；attrs 参数以节点的属性信息来搜索文档树，以字典形式给出；text 参数以节点的内容来搜索文档树；kwargs 参数可以以不是 python 内置的关键字参数来搜索文档树，包括标记的 class 属性，id 属性等。name、attrs、text、kwargs 参数支持字符串、正则表达式、列表、TRUE（匹配任何值）。recursive 参数为 False 时，BeautifulSoup 会搜索直接子节点，limit 会限制 BeautifulSoup 搜索节点的个数。</p><p>15.BeautifulSoup 还支持 CSS 语法来搜索文档树，使用的方法是 select()，返回的类型是列表类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.BeautifulSoup4 支持 python 标准库(html.parser)、lxml、html5lib 这些解析器解析文档。&lt;/p&gt;
&lt;p&gt;2.格式化输出文档内容 print soup.prettify()，会自动补全文档。&lt;/p&gt;
&lt;p&gt;3.Beautiful
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="BeautifulSoup" scheme="http://yoursite.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>备份是一个好工具</title>
    <link href="http://yoursite.com/2019/01/11/%E5%A4%87%E4%BB%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/01/11/备份是一个好工具/</id>
    <published>2019-01-11T07:00:00.000Z</published>
    <updated>2019-01-11T07:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="故事发生"><a href="#故事发生" class="headerlink" title="故事发生"></a>故事发生</h3><p>我是 1 月 5 号晚上使用 ubuntu 系统时，由于编程需要，决定重装 python 3。可是，我在终端中输入卸载原来 python 3 命令“sudo apt-get remove python3”，回车后，先是一系列检测 python 3 所有的程序包，终端中输出有九百多兆大小，我想都没想，直接按了个 y，卸载任务就这样开始执行了。大概持续了5分钟左右，随着卸载任务进行，我发现桌面上的火狐浏览器、chrome 浏览器都都不见了，才意识到我刚刚此举的严重性。等我第二天再打开 ubutnu 系统时，此时的系统已经没有任务栏了，可惜的是，我当时沉浸在深深的自责中，没有截图来记录这一“伟大”的实验。这个现象应该是那个命令卸载了一些系统程序，导致部分系统组件不能正常显示。没办法，此时最好的办法就是重装系统了。</p><h3 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h3><p>在我开始安装 ubuntu16.04 系统时，快要安装成功时，系统却提示引导安装失败（我电脑是window 10 + ubuntu 16.04 双系统，引导失败，意味着双系统安装失败，只能使用 ubuntu 16.04 系统）。虽然，有方法可以修复引导，可是完美主义兼懒癌晚期的我岂能容下这个小瑕疵，尝试三次，依然是引导安装失败，我才悻悻地决定重新安装 windows 10系统 + ubuntu 18.04 系统。</p><p>有时候不是我们愿意犯错，而是每一次犯错之前，我们都希望这一次会成功，所以，判断出确定的错误是多么实用的能力。</p><h3 id="前路曲折，每步需谨慎"><a href="#前路曲折，每步需谨慎" class="headerlink" title="前路曲折，每步需谨慎"></a>前路曲折，每步需谨慎</h3><p>走到这一步，我想既然都重装双系统了，那还不如来个“从头再来”，前进路上坑多了，自然会想到回来，去另外一条路。于是，我开始备份数据，从 ubuntu 16.04 系统到 windows 10 系统，而且采用的是最原始的备份方式，拷贝到 U 盘中去。不得不说，300 多 G 数据的备份耗费了五六小时，此时我只有感叹备份效率太低，渴求备份技术能够突破。</p><p>这里，我要强烈地吐槽一下 ubuntu 系统，人机交互做得太差了！我在复制 ubuntu 16.04 系统中的数据，进度条跑完，我就弹出 U 盘，按理说，这应该是很正确的做法。可是，当我再进入 windows 10 系统，准备复制 windows 10 中的数据时，我在 windows 10 中打开 ubuntu 中复制的数据，发现大多数文件都已乱码，只有小部分数据完好的，很显然，数据拷贝没有完成，可是 ubuntu 中复制进度条已经跑完呀。这里，windows 10 系统做得挺好的，因为从一个磁盘复制到另一个磁盘，不可能一个单位一个单位地复制，需要借助中间缓冲区域，即缓冲区。Windows 10 系统复制文件的进度条百分比展示的是文件到缓冲区的数量，而进度条结束表明文件复制结束。进度条百分比虽然到 100%，但是进度条不一定结束。此时，我只有感叹眼见不一定为实。</p><h3 id="备份时遗留的坑是恢复时付出的汗水"><a href="#备份时遗留的坑是恢复时付出的汗水" class="headerlink" title="备份时遗留的坑是恢复时付出的汗水"></a>备份时遗留的坑是恢复时付出的汗水</h3><p>双系统安装完后，接下来的任务就是恢复数据，让电脑恢复如初。因为我之前博客是利用 hexo 搭建的，备份数据时导致以前很多博客文章文件拷贝失败，而且我之前弄的博客没有任何备份机制，我只有无奈地采取从网页文件中复制出来，人工地进行恢复博客文件，好在，一切都顺利进行，电脑恢复如初了。</p><p>写到这里，我深有体会，任何一项工程，凡是加上时间这一因素，数据增长的速度会很惊人的。如果当初在设计该工程时，要么就祈求这个工程永不宕机；要么就考虑备份机制，就设计出好用且方便的备份工具来。很显然，永不宕机的可能性很低，应该这样说，是高效且好用的备份机制保证了长时间不宕机的可能。时间在不停地推着我们前进，但是我们也应该时不时去回顾过去，分析过去，展望未来，让我们更平稳地前进。因此，备份是一个好工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;故事发生&quot;&gt;&lt;a href=&quot;#故事发生&quot; class=&quot;headerlink&quot; title=&quot;故事发生&quot;&gt;&lt;/a&gt;故事发生&lt;/h3&gt;&lt;p&gt;我是 1 月 5 号晚上使用 ubuntu 系统时，由于编程需要，决定重装 python 3。可是，我在终端中输入卸载原来 
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="时间" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="备份" scheme="http://yoursite.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>2018总结</title>
    <link href="http://yoursite.com/2019/01/01/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/01/2018总结/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-01-09T12:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>得到 APP 创始人罗振宇曾说过，一个好的自我介绍就是四条，任何场合自我介绍，你总有几秒到几十秒甚至几分钟的考虑时间，你可以在这时间里心里考虑这四件事。</p><p>第一件事，在有限的时间里，我必须给大家介绍那些硬的信息事什么，比如我叫什么名字，我是哪的人，哪个学校毕业的，这都叫硬信息。但请注意，只是第一层，这就是简历那个部分。</p><p>第二件事，你现在想，我为什么来到这个场合？我跟这个场合的关系的是什么？</p><p>第三件事，我能够提供给大家的价值的是什么？</p><p>第四件事，我在这儿需要获得大家的帮助是什么？</p><p>在做 2018 年总结前，我先正式的写一段自我介绍。</p><p>我叫痛点就是起点，今天我来复盘自己的 2018 年，这里是我的 2018 年总结。这份总结是自我剖析的产物，是引领我 2019 年成长的旗帜，希望各位不吝赐教，共同成长。</p><p>时光荏苒，2018 年过去了，回顾这一年，我草草地毕业，被动地接受社会的洗礼，甚至在“修身”和“齐家”这两个目标没有明确的执行计划。总之，从 2 月份确认考研失败以来，我的2018 年是纠结的，是迷茫的，是灰色的。</p><p>2018 年，有几个词句真的是触动到了我。</p><p><strong>自杀式单身</strong>，指的是一直 单身又不主动扩展社交范围去认识新朋友，却每天幻想着能拥有爱情的行为。2018 年的我，不，应该是我人生的前四分之一（以百岁人生为目标）都在诠释这个词，内心渴望充满友谊的聚会，希望有那个她能够与我协同进化，执行 Yes 和 and 的心法，可是一次又一次我却认为孤独很好，一个人世界充满着的奇幻和乐趣。</p><p><strong>投资自己是最大的投资。</strong>2018 年，由年初美国的贸易保护，一直持续到年尾，到很多公司被爆出大量裁员，很多投资者纷纷发表言论，2018 的冬天格外冷，认为这个冬天投资自己是最大的投资。其实，这句话无论什么时候都是正确的，无论外部环境好与坏，投资自己，提高自己的认知能力，熟练自己的用脑程度，这些都是必要的。这个世界，走的快的人会把走得慢的落下，认知能力高的终究把能力低的人甩下，向上层阶级涌动的道路一直都很拥挤，阶级下滑的路去畅通无阻。</p><p><strong>小趋势是影响趋势的趋势，带来改变的改变。</strong>这句话，出自罗振宇的《时间的朋友·第4场》跨年演讲。关于小趋势，我想回顾一下我过去二十几年。我是一位 95 后，自我出生时，国家执行计划生育政策，“只生一个好”，“生男生女一个样”，等等，而我就是这样的高压政策下来到了这个世界，可能是让我明白我的出生来之不易，希望我明白韶光易逝，劝君善待时间；2007年，我正碰上了小学五年制改六年制，可能是让我明白学生年代的宝贵性，希望我好好珍惜这短暂的学生年代；2011 年夏，我参加完中考，只因为中考分数差点，而不得不选择人们眼中稍差的学校，可是三年的高中生涯让我明白优秀是相对的，成绩是过去的，而成长却是一直陪伴我们始终的；2014 年我步入了大学的门槛，而这一切可能是上天故意安排的，偏偏我们这一届一个班，偏偏我们这一届教学计划是老计划，偏偏在大学快结束时，我才明白过来，所谓的教育，只不过是便于管理。2018 年，我毕业了，在缺乏社会经验，应该说是很缺乏社会经验，面对未来的生活和失败的考研的经历，我又一次跳进去，由社会的浪潮推着前进，全然不知这一切的小趋势。也许，这就是生活吧，它糟糕得要命，容不得你有半点重来的机会，但你会爱上它的。</p><p>2019 年已经到来，我只希望这一年我能一直成长，时刻感受、抓住并记录身边的小趋势。2019 年，我想发下一个大愿，未来十二年，公众号日更，继续英语学习，并定期推送计算机专业知识以及其他知识的学习，每天成长一点。<strong>简单来说，未来十二年，公众号日更，每天推送自己的学习和思考内容。</strong>2019 年加油，忘了说了，2019 年是我的本命年，本命年，加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;得到 APP 创始人罗振宇曾说过，一个好的自我介绍就是四条，任何场合自我介绍，你总有几秒到几十秒甚至几分钟的考虑时间，你可以在这时间里心里考虑这四件事。&lt;/p&gt;
&lt;p&gt;第一件事，在有限的时间里，我必须给大家介绍那些硬的信息事什么，比如我叫什么名字，我是哪的人，哪个学校毕业的
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>考研政治选择题命题人思路</title>
    <link href="http://yoursite.com/2018/11/09/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98%E5%91%BD%E9%A2%98%E4%BA%BA%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/11/09/考研政治选择题命题人思路/</id>
    <published>2018-11-08T16:00:00.000Z</published>
    <updated>2019-01-09T12:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="马原"><a href="#马原" class="headerlink" title="马原"></a>马原</h3><h4 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h4><ol><li>人类社会发展的根本动力：社会基本矛盾。易将重要动力与根本动力混为一谈，如，阶级斗争是重要动力。</li><li>马克思主义之所以具有如此强大的生命力：实践性，科学性，革命性。</li><li>马克思主义鲜明特征：实践性，科学性，革命性，人民性，发展性。</li><li>马克思主义包含马哲、政经和科社，其中马哲是基础，方法；政经是主体内容；科社是归宿。</li><li>矛盾是普遍存在，和谐社会也存在矛盾（非对抗性）。</li><li>共产主义社会：物质财富极大丰富、人民精神境界极大提高、每个人自由而全面发展。</li><li>自由是尊重规律和不牺牲别人的自由。</li><li>科学性表现在按照世界的本来面目去认识世界。<h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4></li><li>不彻底的唯物主义：自然观上是唯物主义，历史观上是唯心主义。</li><li>不彻底的唯心主义：否认物质与意识的同一性。</li><li>马克思在哲学史上两大贡献：辩证唯物主义和历史唯物主义；理论上是两大贡献：唯物史观和剩余价值。</li><li>唯物主义与唯心主义：物质与意识何者为第一性；可知论与不可知论：思维和存在是否具有同一性；辩证法和1形而上学：世界是怎样发展的；唯物史观和唯心史观：社会意识和社会存在何者为第一性。</li><li>夸大规律，导致宿命论；夸大主观能动性，导致唯意志论。</li><li>意识的能动作用具有两面性。错误论述：意识的能动作用使事物向正确方向发展。错误论述：只有正确的意识才能反作用于客观事物。</li><li>正确论述：意识能够改造（创造）客观事物。</li><li>物质是运动的基础和承担者；运动的原因和根据是矛盾；运动的根本属性和存在方式是时空；静止是过去运动的结果和未来运动的出发点。</li><li>错误论述：唯心主义哲学同人类认识伴随始终。</li><li>错误论述：物质的各种实物的总和。“实物”，“总和”。物质是…的抽象。</li><li>意识和物质是对立统一；在一定范围，只对立（只统一）。</li><li>错误论述：鬼神观念是人脑对鬼神的虚幻反映。意识是对物质的反映。</li><li>正确论述：意识只是对客观存在近似的反映。错误论述：意识不能准确、完整地反映客观存在。</li><li>意识和物质的统一性：意识对物质具有相对独立性。</li><li>错误论述：电脑和机器人也能进行某些实践活动。</li><li>错误论述：人类能够发现、改造、创造客观规律。正确论述：人类可以发现规律，改变规律起作用的条件和方式。正确论述：人类能够发现、认识、利用客观规律。<h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4></li><li>事物内部的肯定反面和否定反面的对立统一运动，表现形式是螺旋式上升的过程；实质是事物自我完善和发展的过程。</li><li>感性认识与理性认识是深浅区别，不是对错区别。</li><li>假象是错误的现象；错觉是错误的感觉。</li><li>主观辩证法与客观辩证法是反映与被反映的关系。</li><li>自然规律与社会规律的联系是客观性。它们的区别是：自然规律是盲目的，自发的，没有主观参与，精确重复；社会规律是有意识的，自觉的，主客观相互制约，是一种趋势。</li><li>矛盾的解决：矛盾一方克服另外一方；矛盾双方达到谐同运动的状态；矛盾双方毁灭，转化为新矛盾。</li><li>矛盾的斗争性寓于同一性之中。</li><li>普遍和特殊，一般和个别，共性和个性。</li><li>矛盾的普遍性寓于（存在于）特殊性之中。必然性寓于偶然性之中。</li><li>外因只能通过内因才能起作用。</li><li>社会规律实现的特点是既有不以人的意志为转移的规律，又有人的主观能动性。</li><li>错误论述：新事物在任何时候都能战胜旧事物。正确论述：新事物一定会战胜旧事物。</li><li>正确论述：凡是在历史上产生的都会在历史上灭亡。<h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4></li><li>正确论述：认识是实践的先导。错误论述：认识先于实践。</li><li>正确论述：实践作为检验真理的标准即是确定的，又是不确定的。</li><li>旧唯物主义认识论：直观反映论；辩证唯物主义认识论：能动反映论。</li><li>唯物主义认识论：反映论；唯心主义认识论：先验论。</li><li>正确论述：感性认识是理性认识的基础。</li><li>唯心主义观点：理性认识能够建构认识对象。</li><li>正确论述：认识的根本目的是实践。错误论述：认识的根本目的是通过现象认识本质。这类错误论述一般将认识的根本目的论述为其他。</li><li>哲学概念之间有级别高低，没有重要高低。</li><li>错误论述：真理和谬误没有原则界限。</li><li>错误论述：科学实验是社会存在的基础。实践包括物质生产，政治实践和科学实验，其中物质生产是社会存在的基础。</li><li>错误论述：理性认识能指导人们推动事物的发展。正确论述：；理性认识能够指导人们推动或阻碍事物的发展。</li><li>感性认识和理性认识是深浅区别，不是对错区别。</li><li>正确论述：真理只能是主观对客观事物近似正确即相对正确的反映。</li><li>真理与价值，规律与能动。真理，规律（该这么做），价值，能动（想怎么做）。</li><li>正确论述：认识的基础是实践。错误论述：感性认识是认识的基础。只能说感性认识的认识的第一个阶段。</li><li>正确论述：实践决定认识的产生和发展。</li><li>正确论述：实践是认识的唯一来源。</li><li>正确论述：实践是实现思想目的的感性物质活动。实践过程体现主体的目的，受主体的意识指导，体现主体的能动性。</li><li>错误论述；认识只是客体在主体的头脑中的直接再现。这是一种直观（机械）反映论。</li><li>错误论述：对同一件事件的不同看法可以都是正确的。违背了真理的一元性。</li><li>有用未必是真理，真理一定是有用的。</li><li>人类的认识能力是无限和有限的统一，至上性和非至上性的统一。</li><li>自由的条件性：认识上，认知越多，越自由；实践上，尊重客观规律，尊重别人的自由。</li><li>事物发展和人类的认识能力有待发展决定了真理的相对性。<h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4></li><li>社会存在决定社会意识。</li><li>错误论述：社会心理可以左右社会发展方向。</li><li>生产方式是生产力和生产关系的统一；社会形态是经济基础和上层建筑的统一；人的本质是一切社会关系的总和；生产力是劳动资料、劳动对象和劳动力的统一；生产资料是劳动资料和劳动对象的统一。</li><li>错误论述：人类的活动目的本身就是历史规律。</li><li>错误论述：人民群众的意志就是历史的发展方向。</li><li>错误论述：人们在实践活动中所形成的各种社会关系属于社会存在范畴。生产关系是属于社会存在范畴。</li><li>生产关系是生产的形式，是人们在生产过程中结成的人与人的物质利益关系。</li><li>错误论述：社会基本矛盾都可以通过自我完善和自我发展的方式加以解决。社会基本矛盾在剥削社会是对抗性的，在非剥削社会是对抗性的。</li><li>人类社会的发展是由物质力量决定的，并受精神力量影响的。</li><li>错误论述：社会发展是由多种力量最终决定的。</li><li>人性包括自然属性和社会属性，社会属性是本质属性。<h4 id="政治经济学"><a href="#政治经济学" class="headerlink" title="政治经济学"></a>政治经济学</h4></li><li>商品的交换是解决商品内在的使用价值和价值的矛盾。</li><li>错误论述：使用价值越高，所含价值就越高。</li><li>正确论述：使用价值是价值的物质承担者。</li><li>资本的本质是在物的外壳掩盖下的一种社会关系。价值、资本、货币的本质是人与人的关系。</li><li>工资是劳动者必要劳动时间创造的价值（剩余劳动被资本家无偿占有），是劳动力的价值（本质），是劳动力的价格（本质），表现为了劳动的价格（掩盖资本主义剥削的实质）。</li><li>行业，部门（生产资料部门和生活资料部门），全社会。</li><li>利润被看作全部预付资本的产物，而剩余价值不是（c+v—&gt;r,v—&gt;m）。</li><li>利润和剩余价值的相同点：剩余价值和利润在量上是相等的；剩余价值和利润归根到底都是由工人的劳动创造出来的。</li><li>错误论述：资本输出是区分自由竞争和垄断两个发展阶段的根本标志。</li><li>商品本质上体现的是人与人之间的关系，是把人与人之间的关系物化了。</li><li>错误论述：商品之所以成为商品是因为它是劳动产品。进行交换的劳动产品的商品。</li><li>价值规律是内容是商品的价值是由生产商品的社会必要劳动时间决定的；商品交换以价值量为基础，按照等价原则进行。</li><li>价值规律的表现形式的价格围绕价值、生产价格、垄断价格上下波动，在不同阶段表现形式会不同。</li><li>价值规律的作用是价值规律可能造成商品生产者的两极分化。</li><li>劳动是劳动力的使用，它不是商品，没有价值或价格。</li><li>错误论述：如果竞争不复存在，垄断企业就没有动力和压力壮大自己的实力。垄断企业壮大的内因是获得更多的利润，外因是竞争。</li><li>错误论述：对于资本输出国来说，垄断资本的扩张只有积极作用，没有不利影响。</li><li>正确论述：从整个社会来看，商品的价格总额仍然等于商品的价值总量。</li><li>私人资本所有制、股份、国家、法人资本所有制。<h4 id="科学社会主义"><a href="#科学社会主义" class="headerlink" title="科学社会主义"></a>科学社会主义</h4></li><li>社会关系的高度和谐体现在国家消亡，阶级消亡，工业与农业、城市与乡村、脑力劳动与体力劳动—“三大差别”消失，人、自然及社会都达成和谐。</li><li>错误论述：苏联模式是一条完全适合俄国国情的社会主义道路。<h3 id="思修法基"><a href="#思修法基" class="headerlink" title="思修法基"></a>思修法基</h3><h4 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h4></li><li>是否爱自己的骨肉同胞是检验一个人爱国的试金石。爱灿烂文化是爱国的摇篮、精神基因。</li><li>民族精神：伟大的梦想精神，伟大的团结精神，伟大的奋斗精神，伟大的创造精神。</li><li>在社会主义社会，实现人生价值的标准是个体对社会和他人做贡献。</li><li>个人与社会、个人与他人关系的核心为利益关系。</li><li>社会主义核心价值观需要践行，贯穿实践当中，不是理想。</li><li>错误论述：爱国主义是永恒的。<h4 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h4></li><li>道德的功能：认识功能（行为前）、规范功能（行为中）、调节功能（行为后）。</li><li>维护公共生活秩序的基本手段是道德和法律。</li><li>基本国策：对外开放、一国两制、保护环境、节约资源、男女平等。</li><li>男女平等是道德要求，也是法律要求，还是基本国策，不是政治要求。</li><li>爱国主义是道德要求，也是法律要求，还是政治要求。</li><li>社会主义核心价值观的道义 力量：先进性、人民性、真实性。</li><li>错误论述：有序的公共生活是提高社会成员物质生活质量的基本保证。错误在于物质。</li><li>错误论述：个人品德是维护社会成员之间最基本的社会关系秩序的最起码的道德要求。</li><li>个人品德是经济社会发展进程中重要的主体精神力量。<h4 id="法律修养"><a href="#法律修养" class="headerlink" title="法律修养"></a>法律修养</h4></li><li>既是权利又是义务：劳动、教育。</li><li>未来中国法治国家发展和宪政之路的基本价值取向是保障公民的自由平等。</li><li>中国特色社会主义法律体系中，法律是主干，宪法是统帅。</li><li>《中华人民共和国香港特别行政区基本法》属于宪法相关法。</li><li>法律运行的环节来看，法律公正包括立法公正和执法公正；法律公正的内涵来看，法律公正包括实体公正和程序公正。</li><li>法律强制的主体是国家（主动主体）、社会成员（被动主体）与社会组织（被动主体）。</li><li>错误论述：公民在法律判决面前一律平等。</li><li>正确论述：公民在适用法律上一律平等。</li><li>法律适用的主体是国家司法机关（法院、检察院）及其公职人员。</li><li>宪法的修改需由1/5以上的全国人大代表提议，2/3以上全国人大代表通过。</li><li>我国社会主义法律的本质特征是阶级性与人民性的统一，科学性和先进性的统一。</li><li>国家机关包括行政机关、司法机关、军事机关、权力机关。</li><li>思想道德和法律在调解领域、调解方式、调解目标等方面存在很大不同。</li><li>公正司法是维护社会公平正义的最后一道防线。</li><li>法律权利和义务之间的关系包括：结构上的相关关系、总量上的等值关系和功能上的互补关系。</li><li>行政复议：执法部门和群众之间。</li><li>契约自由是商法中的基本原则。<h3 id="史纲"><a href="#史纲" class="headerlink" title="史纲"></a>史纲</h3><h4 id="旧民主主义革命时期"><a href="#旧民主主义革命时期" class="headerlink" title="旧民主主义革命时期"></a>旧民主主义革命时期</h4></li><li>争取名族独立和人民解放是解放民族复兴的前提。</li><li>洋务运动时期的民用工业的性质是资本主义性质，官督商办。</li><li>中国近代思想的共同主题是救亡图存。</li><li>导致中国近代历次反侵略战争失败的原因包括：社会制度腐败，经济技术落后。</li><li>维新派自身的局限性：不敢否定封建主义、对帝国主义抱有幻想、惧怕人民群众；客观原因：民族资产阶级力量弱小。</li><li>封建主义，政治上：封建君主专制制度；经济上：封建土地剥削制度。</li><li>辛亥革命的任务：反帝反封；纲领：不反帝且反封不彻底；结果：打击了帝国主义和封建主义。<h4 id="新民主主义革命时期"><a href="#新民主主义革命时期" class="headerlink" title="新民主主义革命时期"></a>新民主主义革命时期</h4></li><li>新民主主义革命与旧民主主义革命的区别：革命指导思想、革命前途和革命领导权。其中革命领导权是区分的根本标志。</li><li>中国的民族民主革命是无产阶级领导的资产阶级民主革命，但客观上属于世界无产阶级社会主义革命的一部分是在十月革命后。</li><li>主观主义的实质就是理论脱离实际；表现形式：教条主义、经验主义。</li><li>阶级局限性（主观原因），敌人太强大（客观原因），自身力量弱小（客观原因）。</li><li>大革命失败到土地革命兴起的转折点是八七会议。</li><li>无产阶级反帝反封的态度最坚决。</li><li>洛川会议开启了全面的全民族抗战新阶段。</li><li>正确论述：农民是中国革命的主力军，无产阶级是中国革命最基本的动力。错误论述：农民是中国革命最基本的动力。</li><li>错误论述：民族资产阶级没有提出明确的革命纲领。正确论述：民族资产阶级没有提出科学的革命纲领。</li><li>构成人民民主专政主要联盟的阶级是工人阶级、农民阶级和城市小资产阶级。各革命阶级联合专政中的阶级是工、农、小、民。<h4 id="新中国时期"><a href="#新中国时期" class="headerlink" title="新中国时期"></a>新中国时期</h4></li><li>20世纪的中国经历了三次历史性巨变：辛亥革命、中华人民共和国的成立和社会主义制度的确立、改革开放。</li><li>新民主主义社会的五种经济成分：社会主义国营经济、合作化经济、个体经济、国家资本主义、私人资本主义。</li><li>社会主义革命是反资反私。</li><li>首次科学阐述思想路线是《矛盾论》、《实践论》；思想路线在全党范围内确立是在延安整风运动；重新确立实事求是的思想路线是在十一届三中全会。<h3 id="毛中特"><a href="#毛中特" class="headerlink" title="毛中特"></a>毛中特</h3><h4 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h4></li><li>毛泽东思想开始形成：大革命到土地革命；走向成熟：遵义会议到抗日战争；写入党章：中共七大；继续发展：建国后。</li><li>毛泽东思想的活的灵魂：实事求是（精髓）、群众路线和独立自主；邓小平理论的活的灵魂（精髓）：解放思想，实事求是。</li><li>十一届六中全会，发表的《关于建国以来党的若干历史问题的决议》：评价毛泽东和毛泽东思想；对社会主义初级阶段的主要矛盾作了表述；首次使用社会主义初级阶段的概念（系统论述并作为国情加以把握在十三大）。</li><li>中国革命的基本问题：农民问题；首要问题：分清敌友问题；中心问题：无产阶级的领导权问题。</li><li>新民主主义革命时期最重要的关系：与农民；最根本的经验：与资产阶级的关系。</li><li>错误论述：“剥削阶级的脏东西”主要是指小资产阶级思想。</li><li>新中国成立是中国人民成为国家和社会的主人；社会主义改造完成是广大劳动人民成为国家和社会的主人。<h4 id="中国特色社会主义理论体系之邓、三、科"><a href="#中国特色社会主义理论体系之邓、三、科" class="headerlink" title="中国特色社会主义理论体系之邓、三、科"></a>中国特色社会主义理论体系之邓、三、科</h4></li><li>社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</li><li>社会主义的根本原则是共同富裕和公有制。</li><li>依据—&gt;国情；前提—&gt;稳定；根本保证—&gt;党的领导（制度）；重要保障—&gt;法律；战略支撑—&gt;国防军队；出发点，落脚点，归宿—&gt;人；立足点—&gt;独立自主，自力更生。</li><li>非公有制经济是中国特色社会主义经济的重要组成部分，是社会主义市场经济的重要组成部分，为社会主义服务。</li><li>按劳分配以外的多种分配方式的实质是按对生产要素的占有情况进行分配。</li><li>社会主义初级阶段的长期性从根本上取决于中国进入社会主义的历史条件，建设社会主义所需要的物质基础；决定了党的基本路线和基本纲领和社会主义初级阶段的主要矛盾。<h4 id="习近平新时代中国特色社会主义思想"><a href="#习近平新时代中国特色社会主义思想" class="headerlink" title="习近平新时代中国特色社会主义思想"></a>习近平新时代中国特色社会主义思想</h4></li><li>全面深化改革、全面依法治国和全面从严治党是战略举措，全面建成小康社会是战略目标。</li><li>市场作用保证更少的资源生产尽可能多的产品，配置资源有效率。</li><li>习近平新时代中国特色社会主义思想的核心要义是坚持和发展中国特色社会主义。</li><li>根本任务：解放和发展生产力；总任务：实现社会主义现代化和中华民族伟大复兴；中国共产党和中国政府的三大历史任务：实现祖国统一，社会主义现代化，维护世界和平；中国共产党的历史使命：统揽伟大斗争、伟大工程、伟大事业、伟大梦想，在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴。</li><li>四个全面：“鸟之两翼，车之双轮”—&gt;全面深化改革和全面依法治国；引领性环节—&gt;全面建成小康；突破性环节、先导性环节—&gt;全面深化改革；重要组成部分—&gt;全面依法治国和全面从严治党。</li><li>四个意识：政治意识、核心意识、看齐意识和大局意识。</li><li>错误论述：非公有制经济在促进共同富裕进程中具有重要作用。共同富裕需要公有制经济，政府的宏观调控来实现。</li><li>再分配调节机制的主要手段有：税收、社会保障、转移支付。增加财产性收入是初次分配的手段。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;马原&quot;&gt;&lt;a href=&quot;#马原&quot; class=&quot;headerlink&quot; title=&quot;马原&quot;&gt;&lt;/a&gt;马原&lt;/h3&gt;&lt;h4 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h4&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="考研政治" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>内务整理有感</title>
    <link href="http://yoursite.com/2018/09/30/%E5%86%85%E5%8A%A1%E6%95%B4%E7%90%86%E6%9C%89%E6%84%9F/"/>
    <id>http://yoursite.com/2018/09/30/内务整理有感/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2019-01-09T12:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在整理内务时，我无意中在高数书上发现我曾经摘抄的一段话，这段话是“<strong>生活最重要，我很优秀，但并不一定一直要去最好的地方。优秀是为了让自己有更多的选择，当我可以选择时，我甚至可以去放羊。</strong>”</p><p>努力让自己成为一个优秀的人，在哪不重要！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在整理内务时，我无意中在高数书上发现我曾经摘抄的一段话，这段话是“&lt;strong&gt;生活最重要，我很优秀，但并不一定一直要去最好的地方。优秀是为了让自己有更多的选择，当我可以选择时，我甚至可以去放羊。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;努力让自己成为一个优秀的人，在哪不重
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="论优秀" scheme="http://yoursite.com/tags/%E8%AE%BA%E4%BC%98%E7%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>中秋快乐</title>
    <link href="http://yoursite.com/2018/09/24/%E4%B8%AD%E7%A7%8B%E5%BF%AB%E4%B9%90/"/>
    <id>http://yoursite.com/2018/09/24/中秋快乐/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2019-01-09T12:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018/September/mid-autumn.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2018/September/mid-autumn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活感悟" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>初识BeautifulSoup</title>
    <link href="http://yoursite.com/2018/08/09/%E5%88%9D%E8%AF%86BeautifulSoup/"/>
    <id>http://yoursite.com/2018/08/09/初识BeautifulSoup/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2019-01-13T09:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>BeautifulSoup 是一个可以从 HTML 或 XML 文件中提取数据的 python 库，它能通过解析器实现文档的查找提取和修改等功能。</p><h3 id="1-BeautifulSoup-的安装"><a href="#1-BeautifulSoup-的安装" class="headerlink" title="1. BeautifulSoup 的安装"></a>1. BeautifulSoup 的安装</h3><p>对于 BeautifulSoup，目前推荐使用的是 BeautifulSoup 4，BeautifulSoup 3　已经停止开发了。安装 BeautifulSoup 4 有四种方式。</p><blockquote><ol><li>最新版的 Debain 或 Ubuntu 系统可以通过系统的软件包管理来安装，sudo apt-get install Python-bs4。</li><li>BeautifulSoup 4 通过 PyPi 发布，可以通过 easy_install 或 pip 来安装，easy_install beautifulsoup4　或 pip install beautifulsoup4。</li><li>通过源码安装，BeautifulSoup 4 的源码地址为<a href="https://pypi.python.org/pypi/beautifulsoup4/" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4/</a>，下载源码，解压后，运行命令 python setup.py install 即可完成安装。</li><li>通过 PyCharm　里 Project Interpreter 安装 BeautifulSoup 4。</li></ol></blockquote><p><img src="/images/2018/August/Screenshot%20from%202018-08-09%2012-55-42.png" alt=""></p><p>BeautifulSoup 支持 Python 标准库中的 HTML 解析器，还支持一些第三方解析器，如，lxml，html5lib 等，安装这些解析器方法与安装 BeautifulSoup 4 类似。</p><table><thead><tr><th>解析器</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python 标准库</td><td>Python 的内置标准库，执行速度适中，文档容错能力强</td><td>Python 早期版本文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>速度快，文档容错能力强</td><td>需要安装 C 语言库</td></tr><tr><td>lxml xml 解析器</td><td>速度快，唯一支持 xml 的解析器</td><td>需要安装 c　语言库</td></tr><tr><td>html5lib</td><td>最好的容错性，以浏览器方式解析文档，生成 HTML5 格式的文档</td><td>速度慢，不依赖外部扩展</td></tr></tbody></table><h3 id="2-BeautifulSoup-的使用"><a href="#2-BeautifulSoup-的使用" class="headerlink" title="2. BeautifulSoup 的使用"></a>2. BeautifulSoup 的使用</h3><p>BeautifulSoup 将复杂的 HTML 文档转换成一个复杂的树形结构，每个节点是 python 对象，这些对象可以归纳为 Tag、NavigableString、BeautifulSoup、Comment。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 测试文档　--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>my blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>One<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>Two</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.cn/one"</span> <span class="attr">class</span>=<span class="string">"one"</span> <span class="attr">id</span>=<span class="string">"link1"</span>&gt;</span><span class="comment">&lt;!-- one --&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.cn/two"</span> <span class="attr">class</span>=<span class="string">"two"</span> <span class="attr">id</span>=<span class="string">"link2"</span>&gt;</span><span class="comment">&lt;!-- two --&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> and</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.cn/three"</span> <span class="attr">class</span>=<span class="string">"three"</span> <span class="attr">id</span>=<span class="string">"link3"</span>&gt;</span>three<span class="tag">&lt;/<span class="name">a</span>&gt;</span>;</span><br><span class="line">hello,world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-Tag-对象"><a href="#1-Tag-对象" class="headerlink" title="1. Tag 对象"></a>1. Tag 对象</h4><p>Tag 对象可以直接以标签名获取标签内容，Tag 对象还有两个属性 name 和 attr，分别表示获取到标签的名称和标签属性内容（以字典的形式返回）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(soup.a)</span><br><span class="line">print(type(soup.a))</span><br><span class="line">print(soup.a.name)</span><br><span class="line">print(soup.a.attrs)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-18-03.png" alt=""></p><h4 id="2-NavigableString-对象"><a href="#2-NavigableString-对象" class="headerlink" title="2. NavigableString 对象"></a>2. NavigableString 对象</h4><p>NavigableString 对象用来获取标签内部字符串，利用属性 string 来获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.p.string)</span><br><span class="line">print(type(soup.p.string))</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-24-18.png" alt=""></p><h4 id="3-BeautifulSoup-对象"><a href="#3-BeautifulSoup-对象" class="headerlink" title="3. BeautifulSoup 对象"></a>3. BeautifulSoup 对象</h4><p>BeautifulSoup 对象表示一个文档的全部内容，可以理解为特殊的 Tag 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.name)</span><br><span class="line">print(type(soup.name))</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-29-25.png" alt=""></p><h4 id="4-Comment-对象"><a href="#4-Comment-对象" class="headerlink" title="4. Comment 对象"></a>4. Comment 对象</h4><p>Commnet 对象用来获取文档中注释的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(htmlStr, <span class="string">'lxml'</span>, from_encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.a.string)</span><br><span class="line">print(type(soup.a.string))</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-10%2014-32-08.png" alt=""></p><h4 id="5-BeautifulSoup-支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。"><a href="#5-BeautifulSoup-支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。" class="headerlink" title="5. BeautifulSoup 支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。"></a>5. BeautifulSoup 支持文档树遍历，可以根据子节点、父节点、兄弟节点和前后节点进行遍历。</h4><table><thead><tr><th>遍历方面</th><th>属性描述</th></tr></thead><tbody><tr><td>子节点</td><td>.contents, .children, .descendants</td></tr><tr><td>父节点</td><td>.parent, .parents</td></tr><tr><td>兄弟节点</td><td>.previous_sibling(s), .next_sibling(s)</td></tr><tr><td>前后节点</td><td>.previous_element(s), .next_element(s)</td></tr></tbody></table><p>BeautifulSoup 还支持 find*() 方法搜索文档树，以及支持 select() 方法根据　CSS 选择器查找文档中指定的标签。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BeautifulSoup 是一个可以从 HTML 或 XML 文件中提取数据的 python 库，它能通过解析器实现文档的查找提取和修改等功能。&lt;/p&gt;
&lt;h3 id=&quot;1-BeautifulSoup-的安装&quot;&gt;&lt;a href=&quot;#1-BeautifulSoup-的安装&quot;
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="BeautifulSoup" scheme="http://yoursite.com/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>python实现正则</title>
    <link href="http://yoursite.com/2018/08/08/python%E5%AE%9E%E7%8E%B0%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2018/08/08/python实现正则/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-01-09T12:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>python 通过 re 模块实现对正则表达式的支持，一般先将正则表达式的字符串形式编译为 Pattern 实例，然后使用 Pattern 实例处理文本并获得匹配结果，最后使用 Match 实例获得信息。</p><p>python 中常用的实现正则表达式匹配函数有两种调用方式 re 调用和 pattern 调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re 调用</span></span><br><span class="line">&gt; <span class="number">1.</span> re.compile(string[,flag])</span><br><span class="line">&gt; <span class="number">2.</span> re.match(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">3.</span> re.search(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">4.</span> re.split(pattern, string[,maxsplit[,flags]])</span><br><span class="line">&gt; <span class="number">5.</span> re.findall(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">6.</span> re.finditer(pattern, string[,flags])</span><br><span class="line">&gt; <span class="number">7.</span> re.sub(pattern, repl, string[,flags[,count]])</span><br><span class="line">&gt; <span class="number">8.</span> re.subn(pattern, repl, string[,flags[,count]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pattern 调用</span></span><br><span class="line">&gt; <span class="number">1.</span> re.compile(string[,flag])</span><br><span class="line">&gt; <span class="number">2.</span> pattern.match(string[,flags])</span><br><span class="line">&gt; <span class="number">3.</span> pattern.search(string[,flags])</span><br><span class="line">&gt; <span class="number">4.</span> pattern.split(string[,maxsplit[,flags]])</span><br><span class="line">&gt; <span class="number">5.</span> pattern.findall(string[,flags])</span><br><span class="line">&gt; <span class="number">6.</span> pattern.finditer(string[,flags])</span><br><span class="line">&gt; <span class="number">7.</span> pattern.sub(repl, string[,flags[,count]])</span><br><span class="line">&gt; <span class="number">8.</span> pattern.subn(repl, string[,flags[,count]])</span><br></pre></td></tr></table></figure><p>其中，flags 参数表示匹配模式，取值有以下几种情况，并且可以使用 “|” 同时使用多种匹配模式。</p><blockquote><ol><li>re.I: 忽略大小写</li><li>re.M: 多行模式，改变 “^” 和 “$” 的含义</li><li>re.S: 点任意匹配模式，改变 “.” 的含义</li><li>re.L: 使预定义字符类 \w\W\b\B\s\S 取决于当前区域设定</li><li>re.U: 使预定义字符类\w\W\b\B\s\S\d\D 取决于 unicode 定义的字符属性<br>6.re.X: 详细模式，这个模式下正则表达式可以是多行的，忽略空白符，并可以加入注释</li></ol></blockquote><p>以上 7 个函数在 re 模块中进行搜索匹配，如果需要获得匹配的数据，这时可以利用 Match 对象，Match 对象保存了正则表达式匹配的过程。Match 对象的属性有：</p><blockquote><ol><li>string: 匹配时使用的文本。</li><li>re: 匹配时使用的 pattern 对象。</li><li>pos: 文本中正则表达式开始搜索的索引。</li><li>endpos: 文本中正则表达式结束搜索的索引。</li><li>lastindex: 最后一个被捕获的分组在文本中的索引。</li><li>lastgroup: 最后一个被捕获的分组的别名。</li><li>group(group1,…): 获得一个或多个分组截获的字符串。</li><li>groups(): 以元组形式返回全部分组截获的字符串。</li><li>groupdict(): 返回以有别名的组的别名为键，以改组截获的子串为值的字典，没有别名的组不包含在内。</li><li>start(group): 返回指定的组截获的子串在 string 中的起始索引。<br>11.end(group): 返回指定的组截获的子串在 string 中的结束索引。</li><li>span(group): 返回 (start(group), end(group))。</li><li>expand(template): 将匹配到的分组代入 template 中然后返回。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r'(\w+) (\w+) (?P&lt;word&gt;.*)'</span>)</span><br><span class="line"></span><br><span class="line">match = pattern.match(<span class="string">'My website is yhw-miracle.win.'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'match.string:'</span> + match.string)</span><br><span class="line">print(<span class="string">'match.re:'</span>, match.re)</span><br><span class="line">print(<span class="string">'match.pos:'</span>, match.pos)</span><br><span class="line">print(<span class="string">'match.endpos:'</span>, match.endpos)</span><br><span class="line">print(<span class="string">'match.lastindex:'</span>, match.lastindex)</span><br><span class="line">print(<span class="string">'match.lastgroup:'</span>, match.lastgroup)</span><br><span class="line">print(<span class="string">'match.group(1,2):'</span>, match.group(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(<span class="string">'match.groups():'</span>, match.groups())</span><br><span class="line">print(<span class="string">'match.groupdict():'</span>, match.groupdict())</span><br><span class="line">print(<span class="string">'match.start(2):'</span>, match.start(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">'match.end(2):'</span>, match.end(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">'match.span(2):'</span>, match.span(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">"match.expand(r'\2 \1 \3'):"</span>, match.expand(<span class="string">r'\2 \1 \3'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/August/Screenshot%20from%202018-08-08%2013-38-48.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python 通过 re 模块实现对正则表达式的支持，一般先将正则表达式的字符串形式编译为 Pattern 实例，然后使用 Pattern 实例处理文本并获得匹配结果，最后使用 Match 实例获得信息。&lt;/p&gt;
&lt;p&gt;python 中常用的实现正则表达式匹配函数有两种调用
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/08/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/07/正则表达式/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2019-01-09T12:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是由普通字符以及特殊字符（称为“元字符”）组成的文字模式，可以作为模板，用来描述在搜索文本时要匹配的一个或多个字符串。</p><h3 id="1-常见元字符"><a href="#1-常见元字符" class="headerlink" title="1. 常见元字符"></a>1. 常见元字符</h3><p>元字符主要作用有：用来匹配字符、用来匹配位置、用来匹配数量和用来匹配模式。常见的元字符如下表所示。</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线和汉子</td></tr><tr><td>\s</td><td>匹配任意空白符，包括空格、制表符、换行符、中午全角空格</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h3 id="2-字符转义"><a href="#2-字符转义" class="headerlink" title="2. 字符转义"></a>2. 字符转义</h3><p>如果需要匹配元字符本身，我们需要用到字符转义来实现，使用 “\” 来取消元字符的特殊含义。</p><blockquote><p>例如，需求是匹配 <a href="https://yhw-miracle.win/" target="_blank" rel="noopener">https://yhw-miracle.win/</a> 这个网址时，正则表达式可以写成 <a href="https://yhw-miracle\.win/。" target="_blank" rel="noopener">https://yhw-miracle\.win/。</a></p></blockquote><h3 id="3-重复"><a href="#3-重复" class="headerlink" title="3. 重复"></a>3. 重复</h3><p>正则表达式中用于匹配重复的字符串，可以使用限定符描述，简化正则表达式的书写。</p><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复 n 次</td></tr><tr><td>{n,}</td><td>重复 n 次或更多次</td></tr><tr><td>{n,m}</td><td>重复 n 到 m 次</td></tr></tbody></table><h3 id="4-字符集合"><a href="#4-字符集合" class="headerlink" title="4. 字符集合"></a>4. 字符集合</h3><p>如果需求是匹配没有预定义元字符的字符集合，例如需求是匹配 a,b,c,d,e 中任意一个字符，可以使用自定义字符集合。正则表达式支持自定义字符集合，用 [] 来实现自定义字符集合，中括号内写要匹配的自定义字符集合。对于上述需求，可以使用 [abcde] 来匹配待定字符串。</p><p>中括号内不仅可以写自定义的字符集合，还可以指定自定义字符范围，例如 [0-9] 与 “\d” 是等价的，[a-z0-9A-Z_] 与 “\w” 是等价的（英文情况下）。</p><h3 id="5-分支条件"><a href="#5-分支条件" class="headerlink" title="5. 分支条件"></a>5. 分支条件</h3><p>正则表达式支持多种匹配规则，满足任意一种规则都是匹配成功，这叫作分支条件，用 “|” 把不同匹配规则分隔开即可。</p><blockquote><p>例如匹配 7－11 位 QQ 号，可以利用分支条件。<br>正则表达式为：[1-9]\d{6} | [1-9]\d{7} | [1-9]\d{9} | [1-9]\d{9} | [1-9]\d{10}</p></blockquote><h3 id="6-分组"><a href="#6-分组" class="headerlink" title="6. 分组"></a>6. 分组</h3><p>对于有规律的字符串，我们可以将其分组，分组每一组，从而写出可以匹配的正则表达式。</p><blockquote><p>需求：匹配 IP 地址。<br>分析：IP 地址可以分为四组，以 . 分隔开，每一组数字不能大于 255。<br>正则表达式：((25[0-5] | 2[0-4]\d | [0-1]\d{2} | [1-9]?\d).){3}(25[0-5] | 2[0-4]\d | [0-1]\d{2} | [1-9]?\d).)</p></blockquote><p>正则表达式中使用小括号指定的表达式为一个分组，默认情况下，每一个分组自动有一个组号，从左到右，以分组的左括号为标志，第一个出现的分组组号为 1，第二个出现是分组组号为 2，以此类推。正则表达式可以利用分组号引用前面组的表达式，这叫做后向引用，简化正则表达式的书写。</p><p>对于分组，我们也可以自定义分组名，利用自定义分组名引用相应的分组。语法为：(?\d+) 或 (?”group”\d+)，这样就把 “\d+” 的组名定义为 “group” 了。如果要引用这个分组的内容，可以使用 \k 来实现。常见的分组形式如下表所示。</p><table><thead><tr><th>分类</th><th>语法</th><th>含义</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配 exp，并捕获文本到自动命名的组里</td></tr><tr><td>捕获</td><td>(?exp) or (?”name”exp)</td><td>匹配 exp，并捕获文本到名称为 name 的组里</td></tr><tr><td>捕获</td><td>(?:exp)</td><td>匹配 exp，不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配 exp 前面的位置</td></tr><tr><td>零宽断言</td><td>(?&lt;=exp)</td><td>匹配 exp 后面的位置</td></tr><tr><td>零宽断言</td><td>(?!exp)</td><td>匹配后面跟的不是 exp　位置</td></tr><tr><td>零宽断言</td><td>(?&lt;!exp)</td><td>匹配前面不是 exp 位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>提供注释</td></tr></tbody></table><h3 id="7-反义"><a href="#7-反义" class="headerlink" title="7. 反义"></a>7. 反义</h3><p>如果需求是匹配除了某一类字符集合之外的字符，这时候可以使用反义来实现。</p><table><thead><tr><th>反义</th><th>含义</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母、数字、下划线、汉子的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符和字符</td></tr><tr><td>\D</td><td>匹配任意不是非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^a]</td><td>匹配除了 a 之外的任意字符</td></tr><tr><td>[^abcde]</td><td>匹配除了 a、b、c、d、e 这几个字母之外的任意字符</td></tr><tr><td>[^(123 ｜ abc)]</td><td>匹配除了 1、2、3 或者 a、b、c 这几个字符之外的任意字符</td></tr></tbody></table><h3 id="8-贪婪与懒惰"><a href="#8-贪婪与懒惰" class="headerlink" title="8. 贪婪与懒惰"></a>8. 贪婪与懒惰</h3><p>正则表达式中包含能接受重复的限定符时，通常情况是匹配尽可能多的字符，这是贪婪模式。有时，需求不希望匹配尽可能多的字符，这时可以使用懒惰模式，就是尽可能少的匹配字符，使用 “?” 启用懒惰模式。</p><table><thead><tr><th>懒惰限定符</th><th>含义</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复 1 次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复 0 次或 1 次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复 n 到 m 次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复 n 次以上，但尽可能少重复</td></tr></tbody></table><h3 id="9-处理选项"><a href="#9-处理选项" class="headerlink" title="9. 处理选项"></a>9. 处理选项</h3><table><thead><tr><th>处理选项</th><th>含义</th></tr></thead><tbody><tr><td>忽略大小写</td><td>匹配时不区分大小写</td></tr><tr><td>多行模式</td><td>更改 “^” 和 “$” 的含义，使得它们在任意一行的行首和行尾进行匹配</td></tr><tr><td>单行模式</td><td>更改 “.” 的含义，使得它与任意字符匹配，包括换行符</td></tr><tr><td>忽略空白</td><td>忽略表达式中非转义空白并启用有 “#” 标记的注释</td></tr><tr><td>显示捕获</td><td>仅捕获已被显示命名的分组</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是由普通字符以及特殊字符（称为“元字符”）组成的文字模式，可以作为模板，用来描述在搜索文本时要匹配的一个或多个字符串。&lt;/p&gt;
&lt;h3 id=&quot;1-常见元字符&quot;&gt;&lt;a href=&quot;#1-常见元字符&quot; class=&quot;headerlink&quot; title=&quot;1. 常见元
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
